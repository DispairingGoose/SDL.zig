[
{
    "comment": "/**\n * Get the window which currently has mouse focus.\n *\n * \\returns the window with mouse focus.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
    "header": "SDL_mouse.h",
    "name": "SDL_GetMouseFocus",
    "parameter": [
        "void"
    ],
    "parameter_name": [
        ""
    ],
    "retval": "SDL_Window*"
},
    {
        "comment": "/**\n * Retrieve the current state of the mouse.\n *\n * The current button state is returned as a button bitmask, which can be\n * tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the\n * left, 2 for middle, 3 for the right button), and `x` and `y` are set to the\n * mouse cursor position relative to the focus window. You can pass NULL for\n * either `x` or `y`.\n *\n * \\param x the x coordinate of the mouse cursor position relative to the\n *          focus window\n * \\param y the y coordinate of the mouse cursor position relative to the\n *          focus window\n * \\returns a 32-bit button bitmask of the current button state.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGlobalMouseState\n * \\sa SDL_GetRelativeMouseState\n * \\sa SDL_PumpEvents\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_GetMouseState",
        "parameter": [
            "float *REWRITE_NAME",
            "float *REWRITE_NAME"
        ],
        "parameter_name": [
            "x",
            "y"
        ],
        "retval": "Uint32"
    },
    {
        "comment": "/**\n * Get the current state of the mouse in relation to the desktop.\n *\n * This works similarly to SDL_GetMouseState(), but the coordinates will be\n * reported relative to the top-left of the desktop. This can be useful if you\n * need to track the mouse outside of a specific window and SDL_CaptureMouse()\n * doesn't fit your needs. For example, it could be useful if you need to\n * track the mouse while dragging a window, where coordinates relative to a\n * window might not be in sync at all times.\n *\n * Note: SDL_GetMouseState() returns the mouse position as SDL understands it\n * from the last pump of the event queue. This function, however, queries the\n * OS for the current mouse position, and as such, might be a slightly less\n * efficient function. Unless you know what you're doing and have a good\n * reason to use this function, you probably want SDL_GetMouseState() instead.\n *\n * \\param x filled in with the current X coord relative to the desktop; can be\n *          NULL\n * \\param y filled in with the current Y coord relative to the desktop; can be\n *          NULL\n * \\returns the current button state as a bitmask which can be tested using\n *          the SDL_BUTTON(X) macros.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CaptureMouse\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_GetGlobalMouseState",
        "parameter": [
            "float *REWRITE_NAME",
            "float *REWRITE_NAME"
        ],
        "parameter_name": [
            "x",
            "y"
        ],
        "retval": "Uint32"
    },
    {
        "comment": "/**\n * Retrieve the relative state of the mouse.\n *\n * The current button state is returned as a button bitmask, which can be\n * tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the\n * left, 2 for middle, 3 for the right button), and `x` and `y` are set to the\n * mouse deltas since the last call to SDL_GetRelativeMouseState() or since\n * event initialization. You can pass NULL for either `x` or `y`.\n *\n * \\param x a pointer filled with the last recorded x coordinate of the mouse\n * \\param y a pointer filled with the last recorded y coordinate of the mouse\n * \\returns a 32-bit button bitmask of the relative button state.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetMouseState\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_GetRelativeMouseState",
        "parameter": [
            "float *REWRITE_NAME",
            "float *REWRITE_NAME"
        ],
        "parameter_name": [
            "x",
            "y"
        ],
        "retval": "Uint32"
    },
    {
        "comment": "/**\n * Move the mouse cursor to the given position within the window.\n *\n * This function generates a mouse motion event if relative mode is not\n * enabled. If relative mode is enabled, you can force mouse events for the\n * warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.\n *\n * Note that this function will appear to succeed, but not actually move the\n * mouse when used over Microsoft Remote Desktop.\n *\n * \\param window the window to move the mouse into, or NULL for the current\n *               mouse focus\n * \\param x the x coordinate within the window\n * \\param y the y coordinate within the window\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_WarpMouseGlobal\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_WarpMouseInWindow",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "float REWRITE_NAME",
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "x",
            "y"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Move the mouse to the given position in global screen space.\n *\n * This function generates a mouse motion event.\n *\n * A failure of this function usually means that it is unsupported by a\n * platform.\n *\n * Note that this function will appear to succeed, but not actually move the\n * mouse when used over Microsoft Remote Desktop.\n *\n * \\param x the x coordinate\n * \\param y the y coordinate\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_WarpMouseInWindow\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_WarpMouseGlobal",
        "parameter": [
            "float REWRITE_NAME",
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x",
            "y"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set relative mouse mode.\n *\n * While the mouse is in relative mode, the cursor is hidden, and the driver\n * will try to report continuous motion in the current window. Only relative\n * motion events will be delivered, the mouse position will not change.\n *\n * Note that this function will not be able to provide continuous relative\n * motion when used over Microsoft Remote Desktop, instead motion is limited\n * to the bounds of the screen.\n *\n * This function will flush any pending mouse motion.\n *\n * \\param enabled SDL_TRUE to enable relative mode, SDL_FALSE to disable.\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n *          If relative mode is not supported, this returns -1.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRelativeMouseMode\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_SetRelativeMouseMode",
        "parameter": [
            "SDL_bool REWRITE_NAME"
        ],
        "parameter_name": [
            "enabled"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Capture the mouse and to track input outside an SDL window.\n *\n * Capturing enables your app to obtain mouse events globally, instead of just\n * within your window. Not all video targets support this function. When\n * capturing is enabled, the current window will get all mouse events, but\n * unlike relative mode, no change is made to the cursor and it is not\n * restrained to your window.\n *\n * This function may also deny mouse input to other windows--both those in\n * your application and others on the system--so you should use this function\n * sparingly, and in small bursts. For example, you might want to track the\n * mouse while the user is dragging something, until the user releases a mouse\n * button. It is not recommended that you capture the mouse for long periods\n * of time, such as the entire time your app is running. For that, you should\n * probably use SDL_SetRelativeMouseMode() or SDL_SetWindowGrab(), depending\n * on your goals.\n *\n * While captured, mouse events still report coordinates relative to the\n * current (foreground) window, but those coordinates may be outside the\n * bounds of the window (including negative values). Capturing is only allowed\n * for the foreground window. If the window loses focus while capturing, the\n * capture will be disabled automatically.\n *\n * While capturing is enabled, the current window will have the\n * `SDL_WINDOW_MOUSE_CAPTURE` flag set.\n *\n * Please note that as of SDL 2.0.22, SDL will attempt to \"auto capture\" the\n * mouse while the user is pressing a button; this is to try and make mouse\n * behavior more consistent between platforms, and deal with the common case\n * of a user dragging the mouse outside of the window. This means that if you\n * are calling SDL_CaptureMouse() only to deal with this situation, you no\n * longer have to (although it is safe to do so). If this causes problems for\n * your app, you can disable auto capture by setting the\n * `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.\n *\n * \\param enabled SDL_TRUE to enable capturing, SDL_FALSE to disable.\n * \\returns 0 on success or -1 if not supported; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGlobalMouseState\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_CaptureMouse",
        "parameter": [
            "SDL_bool REWRITE_NAME"
        ],
        "parameter_name": [
            "enabled"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Query whether relative mouse mode is enabled.\n *\n * \\returns SDL_TRUE if relative mode is enabled or SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetRelativeMouseMode\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_GetRelativeMouseMode",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Create a cursor using the specified bitmap data and mask (in MSB format).\n *\n * `mask` has to be in MSB (Most Significant Bit) format.\n *\n * The cursor width (`w`) must be a multiple of 8 bits.\n *\n * The cursor is created in black and white according to the following:\n *\n * - data=0, mask=1: white\n * - data=1, mask=1: black\n * - data=0, mask=0: transparent\n * - data=1, mask=0: inverted color if possible, black if not.\n *\n * Cursors created with this function must be freed with SDL_DestroyCursor().\n *\n * If you want to have a color cursor, or create your cursor from an\n * SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can\n * hide the cursor and draw your own as part of your game's rendering, but it\n * will be bound to the framerate.\n *\n * Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which\n * provides twelve readily available system cursors to pick from.\n *\n * \\param data the color value for each pixel of the cursor\n * \\param mask the mask value for each pixel of the cursor\n * \\param w the width of the cursor\n * \\param h the height of the cursor\n * \\param hot_x the X-axis location of the upper left corner of the cursor\n *              relative to the actual mouse position\n * \\param hot_y the Y-axis location of the upper left corner of the cursor\n *              relative to the actual mouse position\n * \\returns a new cursor with the specified parameters on success or NULL on\n *          failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_DestroyCursor\n * \\sa SDL_SetCursor\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_CreateCursor",
        "parameter": [
            "const Uint8 *REWRITE_NAME",
            "const Uint8 *REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "data",
            "mask",
            "w",
            "h",
            "hot_x",
            "hot_y"
        ],
        "retval": "SDL_Cursor*"
    },
    {
        "comment": "/**\n * Create a color cursor.\n *\n * \\param surface an SDL_Surface structure representing the cursor image\n * \\param hot_x the x position of the cursor hot spot\n * \\param hot_y the y position of the cursor hot spot\n * \\returns the new cursor on success or NULL on failure; call SDL_GetError()\n *          for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateCursor\n * \\sa SDL_DestroyCursor\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_CreateColorCursor",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "surface",
            "hot_x",
            "hot_y"
        ],
        "retval": "SDL_Cursor*"
    },
    {
        "comment": "/**\n * Create a system cursor.\n *\n * \\param id an SDL_SystemCursor enum value\n * \\returns a cursor on success or NULL on failure; call SDL_GetError() for\n *          more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_DestroyCursor\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_CreateSystemCursor",
        "parameter": [
            "SDL_SystemCursor REWRITE_NAME"
        ],
        "parameter_name": [
            "id"
        ],
        "retval": "SDL_Cursor*"
    },
    {
        "comment": "/**\n * Set the active cursor.\n *\n * This function sets the currently active cursor to the specified one. If the\n * cursor is currently visible, the change will be immediately represented on\n * the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if\n * this is desired for any reason.\n *\n * \\param cursor a cursor to make active\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateCursor\n * \\sa SDL_GetCursor\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_SetCursor",
        "parameter": [
            "SDL_Cursor *REWRITE_NAME"
        ],
        "parameter_name": [
            "cursor"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the active cursor.\n *\n * This function returns a pointer to the current cursor which is owned by the\n * library. It is not necessary to free the cursor with SDL_DestroyCursor().\n *\n * \\returns the active cursor or NULL if there is no mouse.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetCursor\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_GetCursor",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_Cursor*"
    },
    {
        "comment": "/**\n * Get the default cursor.\n *\n * You do not have to call SDL_DestroyCursor() on the return value,\n * but it is safe to do so.\n *\n * \\returns the default cursor on success or NULL on failure.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateSystemCursor\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_GetDefaultCursor",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_Cursor*"
    },
    {
        "comment": "/**\n * Free a previously-created cursor.\n *\n * Use this function to free cursor resources created with SDL_CreateCursor(),\n * SDL_CreateColorCursor() or SDL_CreateSystemCursor().\n *\n * \\param cursor the cursor to free\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateColorCursor\n * \\sa SDL_CreateCursor\n * \\sa SDL_CreateSystemCursor\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_DestroyCursor",
        "parameter": [
            "SDL_Cursor *REWRITE_NAME"
        ],
        "parameter_name": [
            "cursor"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Show the cursor.\n *\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CursorVisible\n * \\sa SDL_HideCursor\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_ShowCursor",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Hide the cursor.\n *\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CursorVisible\n * \\sa SDL_ShowCursor\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_HideCursor",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Return whether the cursor is currently being shown.\n *\n * \\returns `SDL_TRUE` if the cursor is being shown, or `SDL_FALSE` if the\n *          cursor is hidden.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HideCursor\n * \\sa SDL_ShowCursor\n */\n",
        "header": "SDL_mouse.h",
        "name": "SDL_CursorVisible",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Get the directory where the application was run from.\n *\n * This is not necessarily a fast call, so you should call this once near\n * startup and save the string if you need it.\n *\n * **macOS and iOS Specific Functionality**: If the application is in a \".app\"\n * bundle, this function returns the Resource directory (e.g.\n * MyApp.app/Contents/Resources/). This behaviour can be overridden by adding\n * a property to the Info.plist file. Adding a string key with the name\n * SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the\n * behaviour.\n *\n * Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an\n * application in /Applications/SDLApp/MyApp.app):\n *\n * - `resource`: bundle resource directory (the default). For example:\n *   `/Applications/SDLApp/MyApp.app/Contents/Resources`\n * - `bundle`: the Bundle directory. For example:\n *   `/Applications/SDLApp/MyApp.app/`\n * - `parent`: the containing directory of the bundle. For example:\n *   `/Applications/SDLApp/`\n *\n * **Nintendo 3DS Specific Functionality**: This function returns \"romfs\"\n * directory of the application as it is uncommon to store resources outside\n * the executable. As such it is not a writable directory.\n *\n * The returned path is guaranteed to end with a path separator ('\\' on\n * Windows, '/' on most other platforms).\n *\n * The pointer returned is owned by the caller. Please call SDL_free() on the\n * pointer when done with it.\n *\n * \\returns an absolute path in UTF-8 encoding to the application data\n *          directory. NULL will be returned on error or when the platform\n *          doesn't implement this functionality, call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetPrefPath\n */\n",
        "header": "SDL_filesystem.h",
        "name": "SDL_GetBasePath",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "char*"
    },
    {
        "comment": "/**\n * Get the user-and-app-specific path where files can be written.\n *\n * Get the \"pref dir\". This is meant to be where users can write personal\n * files (preferences and save games, etc) that are specific to your\n * application. This directory is unique per user, per application.\n *\n * This function will decide the appropriate location in the native\n * filesystem, create the directory if necessary, and return a string of the\n * absolute path to the directory in UTF-8 encoding.\n *\n * On Windows, the string might look like:\n *\n * `C:\\\\Users\\\\bob\\\\AppData\\\\Roaming\\\\My Company\\\\My Program Name\\\\`\n *\n * On Linux, the string might look like:\n *\n * `/home/bob/.local/share/My Program Name/`\n *\n * On macOS, the string might look like:\n *\n * `/Users/bob/Library/Application Support/My Program Name/`\n *\n * You should assume the path returned by this function is the only safe place\n * to write files (and that SDL_GetBasePath(), while it might be writable, or\n * even the parent of the returned path, isn't where you should be writing\n * things).\n *\n * Both the org and app strings may become part of a directory name, so please\n * follow these rules:\n *\n * - Try to use the same org string (_including case-sensitivity_) for all\n *   your applications that use this function.\n * - Always use a unique app string for each one, and make sure it never\n *   changes for an app once you've decided on it.\n * - Unicode characters are legal, as long as it's UTF-8 encoded, but...\n * - ...only use letters, numbers, and spaces. Avoid punctuation like \"Game\n *   Name 2: Bad Guy's Revenge!\" ... \"Game Name 2\" is sufficient.\n *\n * The returned path is guaranteed to end with a path separator ('\\' on\n * Windows, '/' on most other platforms).\n *\n * The pointer returned is owned by the caller. Please call SDL_free() on the\n * pointer when done with it.\n *\n * \\param org the name of your organization\n * \\param app the name of your application\n * \\returns a UTF-8 string of the user directory in platform-dependent\n *          notation. NULL if there's a problem (creating directory failed,\n *          etc.).\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetBasePath\n */\n",
        "header": "SDL_filesystem.h",
        "name": "SDL_GetPrefPath",
        "parameter": [
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "org",
            "app"
        ],
        "retval": "char*"
    },
    {
        "comment": "/**\n * Determine whether two rectangles intersect.\n *\n * If either pointer is NULL the function will return SDL_FALSE.\n *\n * \\param A an SDL_Rect structure representing the first rectangle\n * \\param B an SDL_Rect structure representing the second rectangle\n * \\returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRectIntersection\n */\n",
        "header": "SDL_rect.h",
        "name": "SDL_HasRectIntersection",
        "parameter": [
            "const SDL_Rect *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "A",
            "B"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Calculate the intersection of two rectangles.\n *\n * If `result` is NULL then this function will return SDL_FALSE.\n *\n * \\param A an SDL_Rect structure representing the first rectangle\n * \\param B an SDL_Rect structure representing the second rectangle\n * \\param result an SDL_Rect structure filled in with the intersection of\n *               rectangles `A` and `B`\n * \\returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasRectIntersection\n */\n",
        "header": "SDL_rect.h",
        "name": "SDL_GetRectIntersection",
        "parameter": [
            "const SDL_Rect *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "A",
            "B",
            "result"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Calculate the union of two rectangles.\n *\n * \\param A an SDL_Rect structure representing the first rectangle\n * \\param B an SDL_Rect structure representing the second rectangle\n * \\param result an SDL_Rect structure filled in with the union of rectangles\n *               `A` and `B`\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_rect.h",
        "name": "SDL_GetRectUnion",
        "parameter": [
            "const SDL_Rect *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "A",
            "B",
            "result"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Calculate a minimal rectangle enclosing a set of points.\n *\n * If `clip` is not NULL then only points inside of the clipping rectangle are\n * considered.\n *\n * \\param points an array of SDL_Point structures representing points to be\n *               enclosed\n * \\param count the number of structures in the `points` array\n * \\param clip an SDL_Rect used for clipping or NULL to enclose all points\n * \\param result an SDL_Rect structure filled in with the minimal enclosing\n *               rectangle\n * \\returns SDL_TRUE if any points were enclosed or SDL_FALSE if all the\n *          points were outside of the clipping rectangle.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_rect.h",
        "name": "SDL_GetRectEnclosingPoints",
        "parameter": [
            "const SDL_Point *REWRITE_NAME",
            "int REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "points",
            "count",
            "clip",
            "result"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Calculate the intersection of a rectangle and line segment.\n *\n * This function is used to clip a line segment to a rectangle. A line segment\n * contained entirely within the rectangle or that does not intersect will\n * remain unchanged. A line segment that crosses the rectangle at either or\n * both ends will be clipped to the boundary of the rectangle and the new\n * coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.\n *\n * \\param rect an SDL_Rect structure representing the rectangle to intersect\n * \\param X1 a pointer to the starting X-coordinate of the line\n * \\param Y1 a pointer to the starting Y-coordinate of the line\n * \\param X2 a pointer to the ending X-coordinate of the line\n * \\param Y2 a pointer to the ending Y-coordinate of the line\n * \\returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_rect.h",
        "name": "SDL_GetRectAndLineIntersection",
        "parameter": [
            "const SDL_Rect *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "rect",
            "X1",
            "Y1",
            "X2",
            "Y2"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Determine whether two rectangles intersect with float precision.\n *\n * If either pointer is NULL the function will return SDL_FALSE.\n *\n * \\param A an SDL_FRect structure representing the first rectangle\n * \\param B an SDL_FRect structure representing the second rectangle\n * \\returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRectIntersection\n */\n",
        "header": "SDL_rect.h",
        "name": "SDL_HasRectIntersectionFloat",
        "parameter": [
            "const SDL_FRect *REWRITE_NAME",
            "const SDL_FRect *REWRITE_NAME"
        ],
        "parameter_name": [
            "A",
            "B"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Calculate the intersection of two rectangles with float precision.\n *\n * If `result` is NULL then this function will return SDL_FALSE.\n *\n * \\param A an SDL_FRect structure representing the first rectangle\n * \\param B an SDL_FRect structure representing the second rectangle\n * \\param result an SDL_FRect structure filled in with the intersection of\n *               rectangles `A` and `B`\n * \\returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasRectIntersectionFloat\n */\n",
        "header": "SDL_rect.h",
        "name": "SDL_GetRectIntersectionFloat",
        "parameter": [
            "const SDL_FRect *REWRITE_NAME",
            "const SDL_FRect *REWRITE_NAME",
            "SDL_FRect *REWRITE_NAME"
        ],
        "parameter_name": [
            "A",
            "B",
            "result"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Calculate the union of two rectangles with float precision.\n *\n * \\param A an SDL_FRect structure representing the first rectangle\n * \\param B an SDL_FRect structure representing the second rectangle\n * \\param result an SDL_FRect structure filled in with the union of rectangles\n *               `A` and `B`\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_rect.h",
        "name": "SDL_GetRectUnionFloat",
        "parameter": [
            "const SDL_FRect *REWRITE_NAME",
            "const SDL_FRect *REWRITE_NAME",
            "SDL_FRect *REWRITE_NAME"
        ],
        "parameter_name": [
            "A",
            "B",
            "result"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Calculate a minimal rectangle enclosing a set of points with float\n * precision.\n *\n * If `clip` is not NULL then only points inside of the clipping rectangle are\n * considered.\n *\n * \\param points an array of SDL_FPoint structures representing points to be\n *               enclosed\n * \\param count the number of structures in the `points` array\n * \\param clip an SDL_FRect used for clipping or NULL to enclose all points\n * \\param result an SDL_FRect structure filled in with the minimal enclosing\n *               rectangle\n * \\returns SDL_TRUE if any points were enclosed or SDL_FALSE if all the\n *          points were outside of the clipping rectangle.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_rect.h",
        "name": "SDL_GetRectEnclosingPointsFloat",
        "parameter": [
            "const SDL_FPoint *REWRITE_NAME",
            "int REWRITE_NAME",
            "const SDL_FRect *REWRITE_NAME",
            "SDL_FRect *REWRITE_NAME"
        ],
        "parameter_name": [
            "points",
            "count",
            "clip",
            "result"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Calculate the intersection of a rectangle and line segment with float\n * precision.\n *\n * This function is used to clip a line segment to a rectangle. A line segment\n * contained entirely within the rectangle or that does not intersect will\n * remain unchanged. A line segment that crosses the rectangle at either or\n * both ends will be clipped to the boundary of the rectangle and the new\n * coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.\n *\n * \\param rect an SDL_FRect structure representing the rectangle to intersect\n * \\param X1 a pointer to the starting X-coordinate of the line\n * \\param Y1 a pointer to the starting Y-coordinate of the line\n * \\param X2 a pointer to the ending X-coordinate of the line\n * \\param Y2 a pointer to the ending Y-coordinate of the line\n * \\returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_rect.h",
        "name": "SDL_GetRectAndLineIntersectionFloat",
        "parameter": [
            "const SDL_FRect *REWRITE_NAME",
            "float *REWRITE_NAME",
            "float *REWRITE_NAME",
            "float *REWRITE_NAME",
            "float *REWRITE_NAME"
        ],
        "parameter_name": [
            "rect",
            "X1",
            "Y1",
            "X2",
            "Y2"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Query the window which currently has keyboard focus.\n *\n * \\returns the window with keyboard focus.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_GetKeyboardFocus",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_Window*"
    },
    {
        "comment": "/**\n * Get a snapshot of the current state of the keyboard.\n *\n * The pointer returned is a pointer to an internal SDL array. It will be\n * valid for the whole lifetime of the application and should not be freed by\n * the caller.\n *\n * A array element with a value of 1 means that the key is pressed and a value\n * of 0 means that it is not. Indexes into this array are obtained by using\n * SDL_Scancode values.\n *\n * Use SDL_PumpEvents() to update the state array.\n *\n * This function gives you the current state after all events have been\n * processed, so if a key or button has been pressed and released before you\n * process events, then the pressed state will never show up in the\n * SDL_GetKeyboardState() calls.\n *\n * Note: This function doesn't take into account whether shift has been\n * pressed or not.\n *\n * \\param numkeys if non-NULL, receives the length of the returned array\n * \\returns a pointer to an array of key states.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_PumpEvents\n * \\sa SDL_ResetKeyboard\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_GetKeyboardState",
        "parameter": [
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "numkeys"
        ],
        "retval": "const Uint8*"
    },
    {
        "comment": "/**\n * Clear the state of the keyboard\n *\n * This function will generate key up events for all pressed keys.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetKeyboardState\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_ResetKeyboard",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the current key modifier state for the keyboard.\n *\n * \\returns an OR'd combination of the modifier keys for the keyboard. See\n *          SDL_Keymod for details.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetKeyboardState\n * \\sa SDL_SetModState\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_GetModState",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_Keymod"
    },
    {
        "comment": "/**\n * Set the current key modifier state for the keyboard.\n *\n * The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose\n * modifier key states on your application. Simply pass your desired modifier\n * states into `modstate`. This value may be a bitwise, OR'd combination of\n * SDL_Keymod values.\n *\n * This does not change the keyboard state, only the key modifier flags that\n * SDL reports.\n *\n * \\param modstate the desired SDL_Keymod for the keyboard\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetModState\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_SetModState",
        "parameter": [
            "SDL_Keymod REWRITE_NAME"
        ],
        "parameter_name": [
            "modstate"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the key code corresponding to the given scancode according to the\n * current keyboard layout.\n *\n * See SDL_Keycode for details.\n *\n * \\param scancode the desired SDL_Scancode to query\n * \\returns the SDL_Keycode that corresponds to the given SDL_Scancode.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetKeyName\n * \\sa SDL_GetScancodeFromKey\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_GetKeyFromScancode",
        "parameter": [
            "SDL_Scancode REWRITE_NAME"
        ],
        "parameter_name": [
            "scancode"
        ],
        "retval": "SDL_Keycode"
    },
    {
        "comment": "/**\n * Get the scancode corresponding to the given key code according to the\n * current keyboard layout.\n *\n * See SDL_Scancode for details.\n *\n * \\param key the desired SDL_Keycode to query\n * \\returns the SDL_Scancode that corresponds to the given SDL_Keycode.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetKeyFromScancode\n * \\sa SDL_GetScancodeName\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_GetScancodeFromKey",
        "parameter": [
            "SDL_Keycode REWRITE_NAME"
        ],
        "parameter_name": [
            "key"
        ],
        "retval": "SDL_Scancode"
    },
    {
        "comment": "/**\n * Get a human-readable name for a scancode.\n *\n * See SDL_Scancode for details.\n *\n * **Warning**: The returned name is by design not stable across platforms,\n * e.g. the name for `SDL_SCANCODE_LGUI` is \"Left GUI\" under Linux but \"Left\n * Windows\" under Microsoft Windows, and some scancodes like\n * `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even\n * scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and\n * `SDL_SCANCODE_RETURN2` (both called \"Return\"). This function is therefore\n * unsuitable for creating a stable cross-platform two-way mapping between\n * strings and scancodes.\n *\n * \\param scancode the desired SDL_Scancode to query\n * \\returns a pointer to the name for the scancode. If the scancode doesn't\n *          have a name this function returns an empty string (\"\").\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetScancodeFromKey\n * \\sa SDL_GetScancodeFromName\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_GetScancodeName",
        "parameter": [
            "SDL_Scancode REWRITE_NAME"
        ],
        "parameter_name": [
            "scancode"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get a scancode from a human-readable name.\n *\n * \\param name the human-readable scancode name\n * \\returns the SDL_Scancode, or `SDL_SCANCODE_UNKNOWN` if the name wasn't\n *          recognized; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetKeyFromName\n * \\sa SDL_GetScancodeFromKey\n * \\sa SDL_GetScancodeName\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_GetScancodeFromName",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "name"
        ],
        "retval": "SDL_Scancode"
    },
    {
        "comment": "/**\n * Get a human-readable name for a key.\n *\n * See SDL_Scancode and SDL_Keycode for details.\n *\n * \\param key the desired SDL_Keycode to query\n * \\returns a pointer to a UTF-8 string that stays valid at least until the\n *          next call to this function. If you need it around any longer, you\n *          must copy it. If the key doesn't have a name, this function\n *          returns an empty string (\"\").\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetKeyFromName\n * \\sa SDL_GetKeyFromScancode\n * \\sa SDL_GetScancodeFromKey\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_GetKeyName",
        "parameter": [
            "SDL_Keycode REWRITE_NAME"
        ],
        "parameter_name": [
            "key"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get a key code from a human-readable name.\n *\n * \\param name the human-readable key name\n * \\returns key code, or `SDLK_UNKNOWN` if the name wasn't recognized; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetKeyFromScancode\n * \\sa SDL_GetKeyName\n * \\sa SDL_GetScancodeFromName\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_GetKeyFromName",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "name"
        ],
        "retval": "SDL_Keycode"
    },
    {
        "comment": "/**\n * Start accepting Unicode text input events.\n *\n * This function will start accepting Unicode text input events in the focused\n * SDL window, and start emitting SDL_TextInputEvent (SDL_TEXTINPUT) and\n * SDL_TextEditingEvent (SDL_TEXTEDITING) events. Please use this function in\n * pair with SDL_StopTextInput().\n *\n * On some platforms using this function activates the screen keyboard.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetTextInputRect\n * \\sa SDL_StopTextInput\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_StartTextInput",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Check whether or not Unicode text input events are enabled.\n *\n * \\returns SDL_TRUE if text input events are enabled else SDL_FALSE.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_StartTextInput\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_TextInputActive",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Stop receiving any text input events.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_StartTextInput\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_StopTextInput",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Dismiss the composition window/IME without disabling the subsystem.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_StartTextInput\n * \\sa SDL_StopTextInput\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_ClearComposition",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Returns if an IME Composite or Candidate window is currently shown.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_TextInputShown",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Set the rectangle used to type Unicode text inputs.\n *\n * To start text input in a given location, this function is intended to be\n * called before SDL_StartTextInput, although some platforms support moving\n * the rectangle even while text input (and a composition) is active.\n *\n * Note: If you want to use the system native IME window, try setting hint\n * **SDL_HINT_IME_SHOW_UI** to **1**, otherwise this function won't give you\n * any feedback.\n *\n * \\param rect the SDL_Rect structure representing the rectangle to receive\n *             text (ignored if NULL)\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_StartTextInput\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_SetTextInputRect",
        "parameter": [
            "const SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "rect"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Check whether the platform has screen keyboard support.\n *\n * \\returns SDL_TRUE if the platform has some screen keyboard support or\n *          SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_StartTextInput\n * \\sa SDL_ScreenKeyboardShown\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_HasScreenKeyboardSupport",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Check whether the screen keyboard is shown for given window.\n *\n * \\param window the window for which screen keyboard should be queried\n * \\returns SDL_TRUE if screen keyboard is shown or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasScreenKeyboardSupport\n */\n",
        "header": "SDL_keyboard.h",
        "name": "SDL_ScreenKeyboardShown",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Set the priority of all log categories.\n *\n * \\param priority the SDL_LogPriority to assign\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_LogSetPriority\n */\n",
        "header": "SDL_log.h",
        "name": "SDL_LogSetAllPriority",
        "parameter": [
            "SDL_LogPriority REWRITE_NAME"
        ],
        "parameter_name": [
            "priority"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set the priority of a particular log category.\n *\n * \\param category the category to assign a priority to\n * \\param priority the SDL_LogPriority to assign\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_LogGetPriority\n * \\sa SDL_LogSetAllPriority\n */\n",
        "header": "SDL_log.h",
        "name": "SDL_LogSetPriority",
        "parameter": [
            "int REWRITE_NAME",
            "SDL_LogPriority REWRITE_NAME"
        ],
        "parameter_name": [
            "category",
            "priority"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the priority of a particular log category.\n *\n * \\param category the category to query\n * \\returns the SDL_LogPriority for the requested category\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_LogSetPriority\n */\n",
        "header": "SDL_log.h",
        "name": "SDL_LogGetPriority",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "category"
        ],
        "retval": "SDL_LogPriority"
    },
    {
        "comment": "/**\n * Reset all priorities to default.\n *\n * This is called by SDL_Quit().\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_LogSetAllPriority\n * \\sa SDL_LogSetPriority\n */\n",
        "header": "SDL_log.h",
        "name": "SDL_LogResetPriorities",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO.\n *\n * = * \\param fmt a printf() style message format string\n *\n * \\param ... additional parameters matching % tokens in the `fmt` string, if\n *            any\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_LogCritical\n * \\sa SDL_LogDebug\n * \\sa SDL_LogError\n * \\sa SDL_LogInfo\n * \\sa SDL_LogMessage\n * \\sa SDL_LogMessageV\n * \\sa SDL_LogVerbose\n * \\sa SDL_LogWarn\n */\n",
        "header": "SDL_log.h",
        "name": "SDL_Log",
        "parameter": [
            "SDL_PRINTF_FORMAT_STRING const char *REWRITE_NAME",
            "..."
        ],
        "parameter_name": [
            "fmt",
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Log a message with SDL_LOG_PRIORITY_VERBOSE.\n *\n * \\param category the category of the message\n * \\param fmt a printf() style message format string\n * \\param ... additional parameters matching % tokens in the **fmt** string,\n *            if any\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Log\n * \\sa SDL_LogCritical\n * \\sa SDL_LogDebug\n * \\sa SDL_LogError\n * \\sa SDL_LogInfo\n * \\sa SDL_LogMessage\n * \\sa SDL_LogMessageV\n * \\sa SDL_LogWarn\n */\n",
        "header": "SDL_log.h",
        "name": "SDL_LogVerbose",
        "parameter": [
            "int REWRITE_NAME",
            "SDL_PRINTF_FORMAT_STRING const char *REWRITE_NAME",
            "..."
        ],
        "parameter_name": [
            "category",
            "fmt",
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Log a message with SDL_LOG_PRIORITY_DEBUG.\n *\n * \\param category the category of the message\n * \\param fmt a printf() style message format string\n * \\param ... additional parameters matching % tokens in the **fmt** string,\n *            if any\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Log\n * \\sa SDL_LogCritical\n * \\sa SDL_LogError\n * \\sa SDL_LogInfo\n * \\sa SDL_LogMessage\n * \\sa SDL_LogMessageV\n * \\sa SDL_LogVerbose\n * \\sa SDL_LogWarn\n */\n",
        "header": "SDL_log.h",
        "name": "SDL_LogDebug",
        "parameter": [
            "int REWRITE_NAME",
            "SDL_PRINTF_FORMAT_STRING const char *REWRITE_NAME",
            "..."
        ],
        "parameter_name": [
            "category",
            "fmt",
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Log a message with SDL_LOG_PRIORITY_INFO.\n *\n * \\param category the category of the message\n * \\param fmt a printf() style message format string\n * \\param ... additional parameters matching % tokens in the **fmt** string,\n *            if any\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Log\n * \\sa SDL_LogCritical\n * \\sa SDL_LogDebug\n * \\sa SDL_LogError\n * \\sa SDL_LogMessage\n * \\sa SDL_LogMessageV\n * \\sa SDL_LogVerbose\n * \\sa SDL_LogWarn\n */\n",
        "header": "SDL_log.h",
        "name": "SDL_LogInfo",
        "parameter": [
            "int REWRITE_NAME",
            "SDL_PRINTF_FORMAT_STRING const char *REWRITE_NAME",
            "..."
        ],
        "parameter_name": [
            "category",
            "fmt",
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Log a message with SDL_LOG_PRIORITY_WARN.\n *\n * \\param category the category of the message\n * \\param fmt a printf() style message format string\n * \\param ... additional parameters matching % tokens in the **fmt** string,\n *            if any\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Log\n * \\sa SDL_LogCritical\n * \\sa SDL_LogDebug\n * \\sa SDL_LogError\n * \\sa SDL_LogInfo\n * \\sa SDL_LogMessage\n * \\sa SDL_LogMessageV\n * \\sa SDL_LogVerbose\n */\n",
        "header": "SDL_log.h",
        "name": "SDL_LogWarn",
        "parameter": [
            "int REWRITE_NAME",
            "SDL_PRINTF_FORMAT_STRING const char *REWRITE_NAME",
            "..."
        ],
        "parameter_name": [
            "category",
            "fmt",
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Log a message with SDL_LOG_PRIORITY_ERROR.\n *\n * \\param category the category of the message\n * \\param fmt a printf() style message format string\n * \\param ... additional parameters matching % tokens in the **fmt** string,\n *            if any\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Log\n * \\sa SDL_LogCritical\n * \\sa SDL_LogDebug\n * \\sa SDL_LogInfo\n * \\sa SDL_LogMessage\n * \\sa SDL_LogMessageV\n * \\sa SDL_LogVerbose\n * \\sa SDL_LogWarn\n */\n",
        "header": "SDL_log.h",
        "name": "SDL_LogError",
        "parameter": [
            "int REWRITE_NAME",
            "SDL_PRINTF_FORMAT_STRING const char *REWRITE_NAME",
            "..."
        ],
        "parameter_name": [
            "category",
            "fmt",
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Log a message with SDL_LOG_PRIORITY_CRITICAL.\n *\n * \\param category the category of the message\n * \\param fmt a printf() style message format string\n * \\param ... additional parameters matching % tokens in the **fmt** string,\n *            if any\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Log\n * \\sa SDL_LogDebug\n * \\sa SDL_LogError\n * \\sa SDL_LogInfo\n * \\sa SDL_LogMessage\n * \\sa SDL_LogMessageV\n * \\sa SDL_LogVerbose\n * \\sa SDL_LogWarn\n */\n",
        "header": "SDL_log.h",
        "name": "SDL_LogCritical",
        "parameter": [
            "int REWRITE_NAME",
            "SDL_PRINTF_FORMAT_STRING const char *REWRITE_NAME",
            "..."
        ],
        "parameter_name": [
            "category",
            "fmt",
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Log a message with the specified category and priority.\n *\n * \\param category the category of the message\n * \\param priority the priority of the message\n * \\param fmt a printf() style message format string\n * \\param ... additional parameters matching % tokens in the **fmt** string,\n *            if any\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Log\n * \\sa SDL_LogCritical\n * \\sa SDL_LogDebug\n * \\sa SDL_LogError\n * \\sa SDL_LogInfo\n * \\sa SDL_LogMessageV\n * \\sa SDL_LogVerbose\n * \\sa SDL_LogWarn\n */\n",
        "header": "SDL_log.h",
        "name": "SDL_LogMessage",
        "parameter": [
            "int REWRITE_NAME",
            "SDL_LogPriority REWRITE_NAME",
            "SDL_PRINTF_FORMAT_STRING const char *REWRITE_NAME",
            "..."
        ],
        "parameter_name": [
            "category",
            "priority",
            "fmt",
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Log a message with the specified category and priority.\n *\n * \\param category the category of the message\n * \\param priority the priority of the message\n * \\param fmt a printf() style message format string\n * \\param ap a variable argument list\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Log\n * \\sa SDL_LogCritical\n * \\sa SDL_LogDebug\n * \\sa SDL_LogError\n * \\sa SDL_LogInfo\n * \\sa SDL_LogMessage\n * \\sa SDL_LogVerbose\n * \\sa SDL_LogWarn\n */\n",
        "header": "SDL_log.h",
        "name": "SDL_LogMessageV",
        "parameter": [
            "int REWRITE_NAME",
            "SDL_LogPriority REWRITE_NAME",
            "const char *REWRITE_NAME",
            "va_list REWRITE_NAME"
        ],
        "parameter_name": [
            "category",
            "priority",
            "fmt",
            "ap"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the current log output function.\n *\n * \\param callback an SDL_LogOutputFunction filled in with the current log\n *                 callback\n * \\param userdata a pointer filled in with the pointer that is passed to\n *                 `callback`\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_LogSetOutputFunction\n */\n",
        "header": "SDL_log.h",
        "name": "SDL_LogGetOutputFunction",
        "parameter": [
            "SDL_LogOutputFunction *REWRITE_NAME",
            "void **REWRITE_NAME"
        ],
        "parameter_name": [
            "callback",
            "userdata"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Replace the default log output function with one of your own.\n *\n * \\param callback an SDL_LogOutputFunction to call instead of the default\n * \\param userdata a pointer that is passed to `callback`\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_LogGetOutputFunction\n */\n",
        "header": "SDL_log.h",
        "name": "SDL_LogSetOutputFunction",
        "parameter": [
            "SDL_LogOutputFunction REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "callback",
            "userdata"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Put UTF-8 text into the clipboard.\n *\n * \\param text the text to store in the clipboard\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetClipboardText\n * \\sa SDL_HasClipboardText\n */\n",
        "header": "SDL_clipboard.h",
        "name": "SDL_SetClipboardText",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "text"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get UTF-8 text from the clipboard, which must be freed with SDL_free().\n *\n * This functions returns empty string if there was not enough memory left for\n * a copy of the clipboard's content.\n *\n * \\returns the clipboard text on success or an empty string on failure; call\n *          SDL_GetError() for more information. Caller must call SDL_free()\n *          on the returned pointer when done with it (even if there was an\n *          error).\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasClipboardText\n * \\sa SDL_SetClipboardText\n */\n",
        "header": "SDL_clipboard.h",
        "name": "SDL_GetClipboardText",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "char*"
    },
    {
        "comment": "/**\n * Query whether the clipboard exists and contains a non-empty text string.\n *\n * \\returns SDL_TRUE if the clipboard has text, or SDL_FALSE if it does not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetClipboardText\n * \\sa SDL_SetClipboardText\n */\n",
        "header": "SDL_clipboard.h",
        "name": "SDL_HasClipboardText",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Put UTF-8 text into the primary selection.\n *\n * \\param text the text to store in the primary selection\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetPrimarySelectionText\n * \\sa SDL_HasPrimarySelectionText\n */\n",
        "header": "SDL_clipboard.h",
        "name": "SDL_SetPrimarySelectionText",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "text"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get UTF-8 text from the primary selection, which must be freed with\n * SDL_free().\n *\n * This functions returns empty string if there was not enough memory left for\n * a copy of the primary selection's content.\n *\n * \\returns the primary selection text on success or an empty string on\n *          failure; call SDL_GetError() for more information. Caller must\n *          call SDL_free() on the returned pointer when done with it (even if\n *          there was an error).\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasPrimarySelectionText\n * \\sa SDL_SetPrimarySelectionText\n */\n",
        "header": "SDL_clipboard.h",
        "name": "SDL_GetPrimarySelectionText",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "char*"
    },
    {
        "comment": "/**\n * Query whether the primary selection exists and contains a non-empty text\n * string.\n *\n * \\returns SDL_TRUE if the primary selection has text, or SDL_FALSE if it\n *          does not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetPrimarySelectionText\n * \\sa SDL_SetPrimarySelectionText\n */\n",
        "header": "SDL_clipboard.h",
        "name": "SDL_HasPrimarySelectionText",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Get the number of registered touch devices.\n *\n * On some platforms SDL first sees the touch device if it was actually used.\n * Therefore SDL_GetNumTouchDevices() may return 0 although devices are\n * available. After using all devices at least once the number will be\n * correct.\n *\n * This was fixed for Android in SDL 2.0.1.\n *\n * \\returns the number of registered touch devices.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetTouchDevice\n */\n",
        "header": "SDL_touch.h",
        "name": "SDL_GetNumTouchDevices",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the touch ID with the given index.\n *\n * \\param index the touch device index\n * \\returns the touch ID with the given index on success or 0 if the index is\n *          invalid; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetNumTouchDevices\n */\n",
        "header": "SDL_touch.h",
        "name": "SDL_GetTouchDevice",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "index"
        ],
        "retval": "SDL_TouchID"
    },
    {
        "comment": "/**\n * Get the touch device name as reported from the driver or NULL if the index\n * is invalid.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_touch.h",
        "name": "SDL_GetTouchName",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "index"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the type of the given touch device.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_touch.h",
        "name": "SDL_GetTouchDeviceType",
        "parameter": [
            "SDL_TouchID REWRITE_NAME"
        ],
        "parameter_name": [
            "touchID"
        ],
        "retval": "SDL_TouchDeviceType"
    },
    {
        "comment": "/**\n * Get the number of active fingers for a given touch device.\n *\n * \\param touchID the ID of a touch device\n * \\returns the number of active fingers for a given touch device on success\n *          or 0 on failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetTouchFinger\n */\n",
        "header": "SDL_touch.h",
        "name": "SDL_GetNumTouchFingers",
        "parameter": [
            "SDL_TouchID REWRITE_NAME"
        ],
        "parameter_name": [
            "touchID"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the finger object for specified touch device ID and finger index.\n *\n * The returned resource is owned by SDL and should not be deallocated.\n *\n * \\param touchID the ID of the requested touch device\n * \\param index the index of the requested finger\n * \\returns a pointer to the SDL_Finger object or NULL if no object at the\n *          given ID and index could be found.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_touch.h",
        "name": "SDL_GetTouchFinger",
        "parameter": [
            "SDL_TouchID REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "touchID",
            "index"
        ],
        "retval": "SDL_Finger*"
    },
    {
        "comment": "/**\n * Try to lock a spin lock by setting it to a non-zero value.\n *\n * ***Please note that spinlocks are dangerous if you don't know what you're\n * doing. Please be careful using any sort of spinlock!***\n *\n * \\param lock a pointer to a lock variable\n * \\returns SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already\n *          held.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AtomicLock\n * \\sa SDL_AtomicUnlock\n */\n",
        "header": "SDL_atomic.h",
        "name": "SDL_AtomicTryLock",
        "parameter": [
            "SDL_SpinLock *REWRITE_NAME"
        ],
        "parameter_name": [
            "lock"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Lock a spin lock by setting it to a non-zero value.\n *\n * ***Please note that spinlocks are dangerous if you don't know what you're\n * doing. Please be careful using any sort of spinlock!***\n *\n * \\param lock a pointer to a lock variable\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AtomicTryLock\n * \\sa SDL_AtomicUnlock\n */\n",
        "header": "SDL_atomic.h",
        "name": "SDL_AtomicLock",
        "parameter": [
            "SDL_SpinLock *REWRITE_NAME"
        ],
        "parameter_name": [
            "lock"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Unlock a spin lock by setting it to 0.\n *\n * Always returns immediately.\n *\n * ***Please note that spinlocks are dangerous if you don't know what you're\n * doing. Please be careful using any sort of spinlock!***\n *\n * \\param lock a pointer to a lock variable\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AtomicLock\n * \\sa SDL_AtomicTryLock\n */\n",
        "header": "SDL_atomic.h",
        "name": "SDL_AtomicUnlock",
        "parameter": [
            "SDL_SpinLock *REWRITE_NAME"
        ],
        "parameter_name": [
            "lock"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Memory barriers are designed to prevent reads and writes from being\n * reordered by the compiler and being seen out of order on multi-core CPUs.\n *\n * A typical pattern would be for thread A to write some data and a flag, and\n * for thread B to read the flag and get the data. In this case you would\n * insert a release barrier between writing the data and the flag,\n * guaranteeing that the data write completes no later than the flag is\n * written, and you would insert an acquire barrier between reading the flag\n * and reading the data, to ensure that all the reads associated with the flag\n * have completed.\n *\n * In this pattern you should always see a release barrier paired with an\n * acquire barrier and you should gate the data reads/writes with a single\n * flag variable.\n *\n * For more information on these semantics, take a look at the blog post:\n * http://preshing.com/20120913/acquire-and-release-semantics\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_atomic.h",
        "name": "SDL_MemoryBarrierReleaseFunction",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "",
        "header": "SDL_atomic.h",
        "name": "SDL_MemoryBarrierAcquireFunction",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set an atomic variable to a new value if it is currently an old value.\n *\n * ***Note: If you don't know what this function is for, you shouldn't use\n * it!***\n *\n * \\param a a pointer to an SDL_atomic_t variable to be modified\n * \\param oldval the old value\n * \\param newval the new value\n * \\returns SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AtomicCASPtr\n * \\sa SDL_AtomicGet\n * \\sa SDL_AtomicSet\n */\n",
        "header": "SDL_atomic.h",
        "name": "SDL_AtomicCAS",
        "parameter": [
            "SDL_atomic_t *REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "a",
            "oldval",
            "newval"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Set an atomic variable to a value.\n *\n * This function also acts as a full memory barrier.\n *\n * ***Note: If you don't know what this function is for, you shouldn't use\n * it!***\n *\n * \\param a a pointer to an SDL_atomic_t variable to be modified\n * \\param v the desired value\n * \\returns the previous value of the atomic variable.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AtomicGet\n */\n",
        "header": "SDL_atomic.h",
        "name": "SDL_AtomicSet",
        "parameter": [
            "SDL_atomic_t *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "a",
            "v"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the value of an atomic variable.\n *\n * ***Note: If you don't know what this function is for, you shouldn't use\n * it!***\n *\n * \\param a a pointer to an SDL_atomic_t variable\n * \\returns the current value of an atomic variable.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AtomicSet\n */\n",
        "header": "SDL_atomic.h",
        "name": "SDL_AtomicGet",
        "parameter": [
            "SDL_atomic_t *REWRITE_NAME"
        ],
        "parameter_name": [
            "a"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Add to an atomic variable.\n *\n * This function also acts as a full memory barrier.\n *\n * ***Note: If you don't know what this function is for, you shouldn't use\n * it!***\n *\n * \\param a a pointer to an SDL_atomic_t variable to be modified\n * \\param v the desired value to add\n * \\returns the previous value of the atomic variable.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AtomicDecRef\n * \\sa SDL_AtomicIncRef\n */\n",
        "header": "SDL_atomic.h",
        "name": "SDL_AtomicAdd",
        "parameter": [
            "SDL_atomic_t *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "a",
            "v"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set a pointer to a new value if it is currently an old value.\n *\n * ***Note: If you don't know what this function is for, you shouldn't use\n * it!***\n *\n * \\param a a pointer to a pointer\n * \\param oldval the old pointer value\n * \\param newval the new pointer value\n * \\returns SDL_TRUE if the pointer was set, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AtomicCAS\n * \\sa SDL_AtomicGetPtr\n * \\sa SDL_AtomicSetPtr\n */\n",
        "header": "SDL_atomic.h",
        "name": "SDL_AtomicCASPtr",
        "parameter": [
            "void **REWRITE_NAME",
            "void *REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "a",
            "oldval",
            "newval"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Set a pointer to a value atomically.\n *\n * ***Note: If you don't know what this function is for, you shouldn't use\n * it!***\n *\n * \\param a a pointer to a pointer\n * \\param v the desired pointer value\n * \\returns the previous value of the pointer.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AtomicCASPtr\n * \\sa SDL_AtomicGetPtr\n */\n",
        "header": "SDL_atomic.h",
        "name": "SDL_AtomicSetPtr",
        "parameter": [
            "void **REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "a",
            "v"
        ],
        "retval": "void*"
    },
    {
        "comment": "/**\n * Get the value of a pointer atomically.\n *\n * ***Note: If you don't know what this function is for, you shouldn't use\n * it!***\n *\n * \\param a a pointer to a pointer\n * \\returns the current value of a pointer.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AtomicCASPtr\n * \\sa SDL_AtomicSetPtr\n */\n",
        "header": "SDL_atomic.h",
        "name": "SDL_AtomicGetPtr",
        "parameter": [
            "void **REWRITE_NAME"
        ],
        "parameter_name": [
            "a"
        ],
        "retval": "void*"
    },
    {
        "comment": "/**\n * Pump the event loop, gathering events from the input devices.\n *\n * This function updates the event queue and internal input device state.\n *\n * **WARNING**: This should only be run in the thread that initialized the\n * video subsystem, and for extra safety, you should consider only doing those\n * things on the main thread in any case.\n *\n * SDL_PumpEvents() gathers all the pending input information from devices and\n * places it in the event queue. Without calls to SDL_PumpEvents() no events\n * would ever be placed on the queue. Often the need for calls to\n * SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and\n * SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not\n * polling or waiting for events (e.g. you are filtering them), then you must\n * call SDL_PumpEvents() to force an event queue update.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_PollEvent\n * \\sa SDL_WaitEvent\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_PumpEvents",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Check the event queue for messages and optionally return them.\n *\n * `action` may be any of the following:\n *\n * - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the\n *   event queue.\n * - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,\n *   within the specified minimum and maximum type, will be returned to the\n *   caller and will _not_ be removed from the queue.\n * - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,\n *   within the specified minimum and maximum type, will be returned to the\n *   caller and will be removed from the queue.\n *\n * You may have to call SDL_PumpEvents() before calling this function.\n * Otherwise, the events may not be ready to be filtered when you call\n * SDL_PeepEvents().\n *\n * This function is thread-safe.\n *\n * \\param events destination buffer for the retrieved events\n * \\param numevents if action is SDL_ADDEVENT, the number of events to add\n *                  back to the event queue; if action is SDL_PEEKEVENT or\n *                  SDL_GETEVENT, the maximum number of events to retrieve\n * \\param action action to take; see [[#action|Remarks]] for details\n * \\param minType minimum value of the event type to be considered;\n *                SDL_FIRSTEVENT is a safe choice\n * \\param maxType maximum value of the event type to be considered;\n *                SDL_LASTEVENT is a safe choice\n * \\returns the number of events actually stored or a negative error code on\n *          failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_PollEvent\n * \\sa SDL_PumpEvents\n * \\sa SDL_PushEvent\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_PeepEvents",
        "parameter": [
            "SDL_Event *REWRITE_NAME",
            "int REWRITE_NAME",
            "SDL_eventaction REWRITE_NAME",
            "Uint32 REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "events",
            "numevents",
            "action",
            "minType",
            "maxType"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Check for the existence of a certain event type in the event queue.\n *\n * If you need to check for a range of event types, use SDL_HasEvents()\n * instead.\n *\n * \\param type the type of event to be queried; see SDL_EventType for details\n * \\returns SDL_TRUE if events matching `type` are present, or SDL_FALSE if\n *          events matching `type` are not present.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasEvents\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_HasEvent",
        "parameter": [
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "type"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Check for the existence of certain event types in the event queue.\n *\n * If you need to check for a single event type, use SDL_HasEvent() instead.\n *\n * \\param minType the low end of event type to be queried, inclusive; see\n *                SDL_EventType for details\n * \\param maxType the high end of event type to be queried, inclusive; see\n *                SDL_EventType for details\n * \\returns SDL_TRUE if events with type >= `minType` and <= `maxType` are\n *          present, or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasEvents\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_HasEvents",
        "parameter": [
            "Uint32 REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "minType",
            "maxType"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Clear events of a specific type from the event queue.\n *\n * This will unconditionally remove any events from the queue that match\n * `type`. If you need to remove a range of event types, use SDL_FlushEvents()\n * instead.\n *\n * It's also normal to just ignore events you don't care about in your event\n * loop without calling this function.\n *\n * This function only affects currently queued events. If you want to make\n * sure that all pending OS events are flushed, you can call SDL_PumpEvents()\n * on the main thread immediately before the flush call.\n *\n * \\param type the type of event to be cleared; see SDL_EventType for details\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_FlushEvents\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_FlushEvent",
        "parameter": [
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "type"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Clear events of a range of types from the event queue.\n *\n * This will unconditionally remove any events from the queue that are in the\n * range of `minType` to `maxType`, inclusive. If you need to remove a single\n * event type, use SDL_FlushEvent() instead.\n *\n * It's also normal to just ignore events you don't care about in your event\n * loop without calling this function.\n *\n * This function only affects currently queued events. If you want to make\n * sure that all pending OS events are flushed, you can call SDL_PumpEvents()\n * on the main thread immediately before the flush call.\n *\n * \\param minType the low end of event type to be cleared, inclusive; see\n *                SDL_EventType for details\n * \\param maxType the high end of event type to be cleared, inclusive; see\n *                SDL_EventType for details\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_FlushEvent\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_FlushEvents",
        "parameter": [
            "Uint32 REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "minType",
            "maxType"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Poll for currently pending events.\n *\n * If `event` is not NULL, the next event is removed from the queue and stored\n * in the SDL_Event structure pointed to by `event`. The 1 returned refers to\n * this event, immediately stored in the SDL Event structure -- not an event\n * to follow.\n *\n * If `event` is NULL, it simply returns 1 if there is an event in the queue,\n * but will not remove it from the queue.\n *\n * As this function may implicitly call SDL_PumpEvents(), you can only call\n * this function in the thread that set the video mode.\n *\n * SDL_PollEvent() is the favored way of receiving system events since it can\n * be done from the main loop and does not suspend the main loop while waiting\n * on an event to be posted.\n *\n * The common practice is to fully process the event queue once every frame,\n * usually as a first step before updating the game's state:\n *\n * ```c\n * while (game_is_still_running) {\n *     SDL_Event event;\n *     while (SDL_PollEvent(&event)) {  // poll until all events are handled!\n *         // decide what to do with this event.\n *     }\n *\n *     // update game state, draw the current frame\n * }\n * ```\n *\n * \\param event the SDL_Event structure to be filled with the next event from\n *              the queue, or NULL\n * \\returns 1 if there is a pending event or 0 if there are none available.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetEventFilter\n * \\sa SDL_PeepEvents\n * \\sa SDL_PushEvent\n * \\sa SDL_SetEventFilter\n * \\sa SDL_WaitEvent\n * \\sa SDL_WaitEventTimeout\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_PollEvent",
        "parameter": [
            "SDL_Event *REWRITE_NAME"
        ],
        "parameter_name": [
            "event"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Wait indefinitely for the next available event.\n *\n * If `event` is not NULL, the next event is removed from the queue and stored\n * in the SDL_Event structure pointed to by `event`.\n *\n * As this function may implicitly call SDL_PumpEvents(), you can only call\n * this function in the thread that initialized the video subsystem.\n *\n * \\param event the SDL_Event structure to be filled in with the next event\n *              from the queue, or NULL\n * \\returns 1 on success or 0 if there was an error while waiting for events;\n *          call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_PollEvent\n * \\sa SDL_PumpEvents\n * \\sa SDL_WaitEventTimeout\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_WaitEvent",
        "parameter": [
            "SDL_Event *REWRITE_NAME"
        ],
        "parameter_name": [
            "event"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Wait until the specified timeout (in milliseconds) for the next available\n * event.\n *\n * If `event` is not NULL, the next event is removed from the queue and stored\n * in the SDL_Event structure pointed to by `event`.\n *\n * As this function may implicitly call SDL_PumpEvents(), you can only call\n * this function in the thread that initialized the video subsystem.\n *\n * The timeout is not guaranteed, the actual wait time could be longer\n * due to system scheduling.\n *\n * \\param event the SDL_Event structure to be filled in with the next event\n *              from the queue, or NULL\n * \\param timeoutMS the maximum number of milliseconds to wait for the next\n *                  available event\n * \\returns 1 on success or 0 if there was an error while waiting for events;\n *          call SDL_GetError() for more information. This also returns 0 if\n *          the timeout elapsed without an event arriving.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_PollEvent\n * \\sa SDL_PumpEvents\n * \\sa SDL_WaitEvent\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_WaitEventTimeout",
        "parameter": [
            "SDL_Event *REWRITE_NAME",
            "Sint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "event",
            "timeoutMS"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Add an event to the event queue.\n *\n * The event queue can actually be used as a two way communication channel.\n * Not only can events be read from the queue, but the user can also push\n * their own events onto it. `event` is a pointer to the event structure you\n * wish to push onto the queue. The event is copied into the queue, and the\n * caller may dispose of the memory pointed to after SDL_PushEvent() returns.\n *\n * Note: Pushing device input events onto the queue doesn't modify the state\n * of the device within SDL.\n *\n * This function is thread-safe, and can be called from other threads safely.\n *\n * Note: Events pushed onto the queue with SDL_PushEvent() get passed through\n * the event filter but events added with SDL_PeepEvents() do not.\n *\n * For pushing application-specific events, please use SDL_RegisterEvents() to\n * get an event type that does not conflict with other code that also wants\n * its own custom event types.\n *\n * \\param event the SDL_Event to be added to the queue\n * \\returns 1 on success, 0 if the event was filtered, or a negative error\n *          code on failure; call SDL_GetError() for more information. A\n *          common reason for error is the event queue being full.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_PeepEvents\n * \\sa SDL_PollEvent\n * \\sa SDL_RegisterEvents\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_PushEvent",
        "parameter": [
            "SDL_Event *REWRITE_NAME"
        ],
        "parameter_name": [
            "event"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set up a filter to process all events before they change internal state and\n * are posted to the internal event queue.\n *\n * If the filter function returns 1 when called, then the event will be added\n * to the internal queue. If it returns 0, then the event will be dropped from\n * the queue, but the internal state will still be updated. This allows\n * selective filtering of dynamically arriving events.\n *\n * **WARNING**: Be very careful of what you do in the event filter function,\n * as it may run in a different thread!\n *\n * On platforms that support it, if the quit event is generated by an\n * interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the\n * application at the next event poll.\n *\n * There is one caveat when dealing with the ::SDL_QuitEvent event type. The\n * event filter is only called when the window manager desires to close the\n * application window. If the event filter returns 1, then the window will be\n * closed, otherwise the window will remain open if possible.\n *\n * Note: Disabled events never make it to the event filter function; see\n * SDL_SetEventEnabled().\n *\n * Note: If you just want to inspect events without filtering, you should use\n * SDL_AddEventWatch() instead.\n *\n * Note: Events pushed onto the queue with SDL_PushEvent() get passed through\n * the event filter, but events pushed onto the queue with SDL_PeepEvents() do\n * not.\n *\n * \\param filter An SDL_EventFilter function to call when an event happens\n * \\param userdata a pointer that is passed to `filter`\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AddEventWatch\n * \\sa SDL_SetEventEnabled\n * \\sa SDL_GetEventFilter\n * \\sa SDL_PeepEvents\n * \\sa SDL_PushEvent\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_SetEventFilter",
        "parameter": [
            "SDL_EventFilter REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "filter",
            "userdata"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Query the current event filter.\n *\n * This function can be used to \"chain\" filters, by saving the existing filter\n * before replacing it with a function that will call that saved filter.\n *\n * \\param filter the current callback function will be stored here\n * \\param userdata the pointer that is passed to the current event filter will\n *                 be stored here\n * \\returns SDL_TRUE on success or SDL_FALSE if there is no event filter set.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetEventFilter\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_GetEventFilter",
        "parameter": [
            "SDL_EventFilter *REWRITE_NAME",
            "void **REWRITE_NAME"
        ],
        "parameter_name": [
            "filter",
            "userdata"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Add a callback to be triggered when an event is added to the event queue.\n *\n * `filter` will be called when an event happens, and its return value is\n * ignored.\n *\n * **WARNING**: Be very careful of what you do in the event filter function,\n * as it may run in a different thread!\n *\n * If the quit event is generated by a signal (e.g. SIGINT), it will bypass\n * the internal queue and be delivered to the watch callback immediately, and\n * arrive at the next event poll.\n *\n * Note: the callback is called for events posted by the user through\n * SDL_PushEvent(), but not for disabled events, nor for events by a filter\n * callback set with SDL_SetEventFilter(), nor for events posted by the user\n * through SDL_PeepEvents().\n *\n * \\param filter an SDL_EventFilter function to call when an event happens.\n * \\param userdata a pointer that is passed to `filter`\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_DelEventWatch\n * \\sa SDL_SetEventFilter\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_AddEventWatch",
        "parameter": [
            "SDL_EventFilter REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "filter",
            "userdata"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Remove an event watch callback added with SDL_AddEventWatch().\n *\n * This function takes the same input as SDL_AddEventWatch() to identify and\n * delete the corresponding callback.\n *\n * \\param filter the function originally passed to SDL_AddEventWatch()\n * \\param userdata the pointer originally passed to SDL_AddEventWatch()\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AddEventWatch\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_DelEventWatch",
        "parameter": [
            "SDL_EventFilter REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "filter",
            "userdata"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Run a specific filter function on the current event queue, removing any\n * events for which the filter returns 0.\n *\n * See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),\n * this function does not change the filter permanently, it only uses the\n * supplied filter until this function returns.\n *\n * \\param filter the SDL_EventFilter function to call when an event happens\n * \\param userdata a pointer that is passed to `filter`\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetEventFilter\n * \\sa SDL_SetEventFilter\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_FilterEvents",
        "parameter": [
            "SDL_EventFilter REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "filter",
            "userdata"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set the state of processing events by type.\n *\n * \\param type the type of event; see SDL_EventType for details\n * \\param enabled whether to process the event or not\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_IsEventEnabled\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_SetEventEnabled",
        "parameter": [
            "Uint32 REWRITE_NAME",
            "SDL_bool REWRITE_NAME"
        ],
        "parameter_name": [
            "type",
            "enabled"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Query the state of processing events by type.\n *\n * \\param type the type of event; see SDL_EventType for details\n * \\returns SDL_TRUE if the event is being processed, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetEventEnabled\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_EventEnabled",
        "parameter": [
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "type"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Allocate a set of user-defined events, and return the beginning event\n * number for that set of events.\n *\n * Calling this function with `numevents` <= 0 is an error and will return\n * (Uint32)-1.\n *\n * Note, (Uint32)-1 means the maximum unsigned 32-bit integer value (or\n * 0xFFFFFFFF), but is clearer to write.\n *\n * \\param numevents the number of events to be allocated\n * \\returns the beginning event number, or (Uint32)-1 if there are not enough\n *          user-defined events left.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_PushEvent\n */\n",
        "header": "SDL_events.h",
        "name": "SDL_RegisterEvents",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "numevents"
        ],
        "retval": "Uint32"
    },
    {
        "comment": "/**\n * Locking for atomic access to the joystick API\n *\n * The SDL joystick functions are thread-safe, however you can lock the joysticks\n * while processing to guarantee that the joystick list won't change and joystick\n * and gamepad events will not be delivered.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_LockJoysticks",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Unlocking for atomic access to the joystick API\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_UnlockJoysticks",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get a list of currently connected joysticks.\n *\n * \\param count a pointer filled in with the number of joysticks returned\n * \\returns a 0 terminated array of joystick instance IDs which should be freed with SDL_free(), or NULL on error; call SDL_GetError() for more details.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_OpenJoystick\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoysticks",
        "parameter": [
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "count"
        ],
        "retval": "SDL_JoystickID*"
    },
    {
        "comment": "/**\n * Get the implementation dependent name of a joystick.\n *\n * This can be called before any joysticks are opened.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the name of the selected joystick. If no name can be found, this\n *          function returns NULL; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetJoystickName\n * \\sa SDL_OpenJoystick\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickInstanceName",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the implementation dependent path of a joystick.\n *\n * This can be called before any joysticks are opened.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the path of the selected joystick. If no path can be found, this\n *          function returns NULL; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetJoystickPath\n * \\sa SDL_OpenJoystick\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickInstancePath",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the player index of a joystick.\n *\n * This can be called before any joysticks are opened.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the player index of a joystick, or -1 if it's not available\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetJoystickPlayerIndex\n * \\sa SDL_OpenJoystick\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickInstancePlayerIndex",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the implementation-dependent GUID of a joystick.\n *\n * This can be called before any joysticks are opened.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the GUID of the selected joystick. If called on an invalid index,\n *          this function returns a zero GUID\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetJoystickGUID\n * \\sa SDL_GetJoystickGUIDString\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickInstanceGUID",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "SDL_JoystickGUID"
    },
    {
        "comment": "/**\n * Get the USB vendor ID of a joystick, if available.\n *\n * This can be called before any joysticks are opened. If the vendor ID isn't\n * available this function returns 0.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the USB vendor ID of the selected joystick. If called on an\n *          invalid index, this function returns zero\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickInstanceVendor",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "/**\n * Get the USB product ID of a joystick, if available.\n *\n * This can be called before any joysticks are opened. If the product ID isn't\n * available this function returns 0.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the USB product ID of the selected joystick. If called on an\n *          invalid index, this function returns zero\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickInstanceProduct",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "/**\n * Get the product version of a joystick, if available.\n *\n * This can be called before any joysticks are opened. If the product version\n * isn't available this function returns 0.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the product version of the selected joystick. If called on an\n *          invalid index, this function returns zero\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickInstanceProductVersion",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "/**\n * Get the type of a joystick, if available.\n *\n * This can be called before any joysticks are opened.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the SDL_JoystickType of the selected joystick. If called on an\n *          invalid index, this function returns `SDL_JOYSTICK_TYPE_UNKNOWN`\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickInstanceType",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "SDL_JoystickType"
    },
    {
        "comment": "/**\n * Open a joystick for use.\n *\n * The joystick subsystem must be initialized before a joystick can be opened\n * for use.\n *\n * \\param instance_id the joystick instance ID\n * \\returns a joystick identifier or NULL if an error occurred; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CloseJoystick\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_OpenJoystick",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "SDL_Joystick*"
    },
    {
        "comment": "/**\n * Get the SDL_Joystick associated with an instance ID.\n *\n * \\param instance_id the instance ID to get the SDL_Joystick for\n * \\returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()\n *          for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickFromInstanceID",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "SDL_Joystick*"
    },
    {
        "comment": "/**\n * Get the SDL_Joystick associated with a player index.\n *\n * \\param player_index the player index to get the SDL_Joystick for\n * \\returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()\n *          for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickFromPlayerIndex",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "player_index"
        ],
        "retval": "SDL_Joystick*"
    },
    {
        "comment": "/**\n * Attach a new virtual joystick.\n *\n * \\returns the joystick instance ID, or 0 if an error occurred; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_AttachVirtualJoystick",
        "parameter": [
            "SDL_JoystickType REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "type",
            "naxes",
            "nbuttons",
            "nhats"
        ],
        "retval": "SDL_JoystickID"
    },
    {
        "comment": "/**\n * Attach a new virtual joystick with extended properties.\n *\n * \\returns the joystick instance ID, or 0 if an error occurred; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_AttachVirtualJoystickEx",
        "parameter": [
            "const SDL_VirtualJoystickDesc *REWRITE_NAME"
        ],
        "parameter_name": [
            "desc"
        ],
        "retval": "SDL_JoystickID"
    },
    {
        "comment": "/**\n * Detach a virtual joystick.\n *\n * \\param instance_id the joystick instance ID, previously returned from SDL_AttachVirtualJoystick()\n * \\returns 0 on success, or -1 if an error occurred.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_DetachVirtualJoystick",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Query whether or not a joystick is virtual.\n *\n * \\param instance_id the joystick instance ID\n * \\returns SDL_TRUE if the joystick is virtual, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_IsJoystickVirtual",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Set values on an opened, virtual-joystick's axis.\n *\n * Please note that values set here will not be applied until the next call to\n * SDL_UpdateJoysticks, which can either be called directly, or can be called\n * indirectly through various other SDL APIs, including, but not limited to\n * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,\n * SDL_WaitEvent.\n *\n * Note that when sending trigger axes, you should scale the value to the full\n * range of Sint16. For example, a trigger at rest would have the value of\n * `SDL_JOYSTICK_AXIS_MIN`.\n *\n * \\param joystick the virtual joystick on which to set state.\n * \\param axis the specific axis on the virtual joystick to set.\n * \\param value the new value for the specified axis.\n * \\returns 0 on success, -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_SetJoystickVirtualAxis",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME",
            "int REWRITE_NAME",
            "Sint16 REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick",
            "axis",
            "value"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set values on an opened, virtual-joystick's button.\n *\n * Please note that values set here will not be applied until the next call to\n * SDL_UpdateJoysticks, which can either be called directly, or can be called\n * indirectly through various other SDL APIs, including, but not limited to\n * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,\n * SDL_WaitEvent.\n *\n * \\param joystick the virtual joystick on which to set state.\n * \\param button the specific button on the virtual joystick to set.\n * \\param value the new value for the specified button.\n * \\returns 0 on success, -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_SetJoystickVirtualButton",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME",
            "int REWRITE_NAME",
            "Uint8 REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick",
            "button",
            "value"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set values on an opened, virtual-joystick's hat.\n *\n * Please note that values set here will not be applied until the next call to\n * SDL_UpdateJoysticks, which can either be called directly, or can be called\n * indirectly through various other SDL APIs, including, but not limited to\n * the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,\n * SDL_WaitEvent.\n *\n * \\param joystick the virtual joystick on which to set state.\n * \\param hat the specific hat on the virtual joystick to set.\n * \\param value the new value for the specified hat.\n * \\returns 0 on success, -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_SetJoystickVirtualHat",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME",
            "int REWRITE_NAME",
            "Uint8 REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick",
            "hat",
            "value"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the implementation dependent name of a joystick.\n *\n * \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n * \\returns the name of the selected joystick. If no name can be found, this\n *          function returns NULL; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetJoystickInstanceName\n * \\sa SDL_OpenJoystick\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickName",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the implementation dependent path of a joystick.\n *\n * \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n * \\returns the path of the selected joystick. If no path can be found, this\n *          function returns NULL; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetJoystickInstancePath\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickPath",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the player index of an opened joystick.\n *\n * For XInput controllers this returns the XInput user index. Many joysticks\n * will not be able to supply this information.\n *\n * \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n * \\returns the player index, or -1 if it's not available.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickPlayerIndex",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set the player index of an opened joystick.\n *\n * \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n * \\param player_index Player index to assign to this joystick, or -1 to clear\n *                     the player index and turn off player LEDs.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_SetJoystickPlayerIndex",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick",
            "player_index"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the implementation-dependent GUID for the joystick.\n *\n * This function requires an open joystick.\n *\n * \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n * \\returns the GUID of the given joystick. If called on an invalid index,\n *          this function returns a zero GUID; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetJoystickInstanceGUID\n * \\sa SDL_GetJoystickGUIDString\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickGUID",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "SDL_JoystickGUID"
    },
    {
        "comment": "/**\n * Get the USB vendor ID of an opened joystick, if available.\n *\n * If the vendor ID isn't available this function returns 0.\n *\n * \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n * \\returns the USB vendor ID of the selected joystick, or 0 if unavailable.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickVendor",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "/**\n * Get the USB product ID of an opened joystick, if available.\n *\n * If the product ID isn't available this function returns 0.\n *\n * \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n * \\returns the USB product ID of the selected joystick, or 0 if unavailable.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickProduct",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "/**\n * Get the product version of an opened joystick, if available.\n *\n * If the product version isn't available this function returns 0.\n *\n * \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n * \\returns the product version of the selected joystick, or 0 if unavailable.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickProductVersion",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "/**\n * Get the firmware version of an opened joystick, if available.\n *\n * If the firmware version isn't available this function returns 0.\n *\n * \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n * \\returns the firmware version of the selected joystick, or 0 if\n *          unavailable.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickFirmwareVersion",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "/**\n * Get the serial number of an opened joystick, if available.\n *\n * Returns the serial number of the joystick, or NULL if it is not available.\n *\n * \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n * \\returns the serial number of the selected joystick, or NULL if\n *          unavailable.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickSerial",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the type of an opened joystick.\n *\n * \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n * \\returns the SDL_JoystickType of the selected joystick.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickType",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "SDL_JoystickType"
    },
    {
        "comment": "/**\n * Get an ASCII string representation for a given SDL_JoystickGUID.\n *\n * You should supply at least 33 bytes for pszGUID.\n *\n * \\param guid the SDL_JoystickGUID you wish to convert to string\n * \\param pszGUID buffer in which to write the ASCII string\n * \\param cbGUID the size of pszGUID\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetJoystickInstanceGUID\n * \\sa SDL_GetJoystickGUID\n * \\sa SDL_GetJoystickGUIDFromString\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickGUIDString",
        "parameter": [
            "SDL_JoystickGUID REWRITE_NAME",
            "char *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "guid",
            "pszGUID",
            "cbGUID"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Convert a GUID string into a SDL_JoystickGUID structure.\n *\n * Performs no error checking. If this function is given a string containing\n * an invalid GUID, the function will silently succeed, but the GUID generated\n * will not be useful.\n *\n * \\param pchGUID string containing an ASCII representation of a GUID\n * \\returns a SDL_JoystickGUID structure.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetJoystickGUIDString\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickGUIDFromString",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "pchGUID"
        ],
        "retval": "SDL_JoystickGUID"
    },
    {
        "comment": "/**\n * Get the device information encoded in a SDL_JoystickGUID structure\n *\n * \\param guid the SDL_JoystickGUID you wish to get info about\n * \\param vendor A pointer filled in with the device VID, or 0 if not\n *               available\n * \\param product A pointer filled in with the device PID, or 0 if not\n *                available\n * \\param version A pointer filled in with the device version, or 0 if not\n *                available\n * \\param crc16 A pointer filled in with a CRC used to distinguish different\n *              products with the same VID/PID, or 0 if not available\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetJoystickInstanceGUID\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickGUIDInfo",
        "parameter": [
            "SDL_JoystickGUID REWRITE_NAME",
            "Uint16 *REWRITE_NAME",
            "Uint16 *REWRITE_NAME",
            "Uint16 *REWRITE_NAME",
            "Uint16 *REWRITE_NAME"
        ],
        "parameter_name": [
            "guid",
            "vendor",
            "product",
            "version",
            "crc16"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the status of a specified joystick.\n *\n * \\param joystick the joystick to query\n * \\returns SDL_TRUE if the joystick has been opened, SDL_FALSE if it has not;\n *          call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CloseJoystick\n * \\sa SDL_OpenJoystick\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_JoystickConnected",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Get the instance ID of an opened joystick.\n *\n * \\param joystick an SDL_Joystick structure containing joystick information\n * \\returns the instance ID of the specified joystick on success or a negative\n *          error code on failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_OpenJoystick\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickInstanceID",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "SDL_JoystickID"
    },
    {
        "comment": "/**\n * Get the number of general axis controls on a joystick.\n *\n * Often, the directional pad on a game controller will either look like 4\n * separate buttons or a POV hat, and not axes, but all of this is up to the\n * device and platform.\n *\n * \\param joystick an SDL_Joystick structure containing joystick information\n * \\returns the number of axis controls/number of axes on success or a\n *          negative error code on failure; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetJoystickAxis\n * \\sa SDL_OpenJoystick\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetNumJoystickAxes",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the number of POV hats on a joystick.\n *\n * \\param joystick an SDL_Joystick structure containing joystick information\n * \\returns the number of POV hats on success or a negative error code on\n *          failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetJoystickHat\n * \\sa SDL_OpenJoystick\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetNumJoystickHats",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the number of buttons on a joystick.\n *\n * \\param joystick an SDL_Joystick structure containing joystick information\n * \\returns the number of buttons on success or a negative error code on\n *          failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetJoystickButton\n * \\sa SDL_OpenJoystick\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetNumJoystickButtons",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set the state of joystick event processing.\n *\n * If joystick events are disabled, you must call SDL_UpdateJoysticks()\n * yourself and check the state of the joystick when you want joystick\n * information.\n *\n * \\param enabled whether to process joystick events or not\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_JoystickEventsEnabled\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_SetJoystickEventsEnabled",
        "parameter": [
            "SDL_bool REWRITE_NAME"
        ],
        "parameter_name": [
            "enabled"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Query the state of joystick event processing.\n *\n * If joystick events are disabled, you must call SDL_UpdateJoysticks()\n * yourself and check the state of the joystick when you want joystick\n * information.\n *\n * \\returns SDL_TRUE if joystick events are being processed, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetJoystickEventsEnabled\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_JoystickEventsEnabled",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Update the current state of the open joysticks.\n *\n * This is called automatically by the event loop if any joystick events are\n * enabled.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_UpdateJoysticks",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the current state of an axis control on a joystick.\n *\n * SDL makes no promises about what part of the joystick any given axis refers\n * to. Your game should have some sort of configuration UI to let users\n * specify what each axis should be bound to. Alternately, SDL's higher-level\n * Game Controller API makes a great effort to apply order to this lower-level\n * interface, so you know that a specific axis is the \"left thumb stick,\" etc.\n *\n * The value returned by SDL_GetJoystickAxis() is a signed integer (-32768 to\n * 32767) representing the current position of the axis. It may be necessary\n * to impose certain tolerances on these values to account for jitter.\n *\n * \\param joystick an SDL_Joystick structure containing joystick information\n * \\param axis the axis to query; the axis indices start at index 0\n * \\returns a 16-bit signed integer representing the current position of the\n *          axis or 0 on failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetNumJoystickAxes\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickAxis",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick",
            "axis"
        ],
        "retval": "Sint16"
    },
    {
        "comment": "/**\n * Get the initial state of an axis control on a joystick.\n *\n * The state is a value ranging from -32768 to 32767.\n *\n * The axis indices start at index 0.\n *\n * \\param joystick an SDL_Joystick structure containing joystick information\n * \\param axis the axis to query; the axis indices start at index 0\n * \\param state Upon return, the initial value is supplied here.\n * \\return SDL_TRUE if this axis has any initial value, or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickAxisInitialState",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME",
            "int REWRITE_NAME",
            "Sint16 *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick",
            "axis",
            "state"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Get the current state of a POV hat on a joystick.\n *\n * The returned value will be one of the following positions:\n *\n * - `SDL_HAT_CENTERED`\n * - `SDL_HAT_UP`\n * - `SDL_HAT_RIGHT`\n * - `SDL_HAT_DOWN`\n * - `SDL_HAT_LEFT`\n * - `SDL_HAT_RIGHTUP`\n * - `SDL_HAT_RIGHTDOWN`\n * - `SDL_HAT_LEFTUP`\n * - `SDL_HAT_LEFTDOWN`\n *\n * \\param joystick an SDL_Joystick structure containing joystick information\n * \\param hat the hat index to get the state from; indices start at index 0\n * \\returns the current hat position.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetNumJoystickHats\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickHat",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick",
            "hat"
        ],
        "retval": "Uint8"
    },
    {
        "comment": "/**\n * Get the current state of a button on a joystick.\n *\n * \\param joystick an SDL_Joystick structure containing joystick information\n * \\param button the button index to get the state from; indices start at\n *               index 0\n * \\returns 1 if the specified button is pressed, 0 otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetNumJoystickButtons\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickButton",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick",
            "button"
        ],
        "retval": "Uint8"
    },
    {
        "comment": "/**\n * Start a rumble effect.\n *\n * Each call to this function cancels any previous rumble effect, and calling\n * it with 0 intensity stops any rumbling.\n *\n * \\param joystick The joystick to vibrate\n * \\param low_frequency_rumble The intensity of the low frequency (left)\n *                             rumble motor, from 0 to 0xFFFF\n * \\param high_frequency_rumble The intensity of the high frequency (right)\n *                              rumble motor, from 0 to 0xFFFF\n * \\param duration_ms The duration of the rumble effect, in milliseconds\n * \\returns 0, or -1 if rumble isn't supported on this joystick\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_JoystickHasRumble\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_RumbleJoystick",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME",
            "Uint16 REWRITE_NAME",
            "Uint16 REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick",
            "low_frequency_rumble",
            "high_frequency_rumble",
            "duration_ms"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Start a rumble effect in the joystick's triggers\n *\n * Each call to this function cancels any previous trigger rumble effect, and\n * calling it with 0 intensity stops any rumbling.\n *\n * Note that this is rumbling of the _triggers_ and not the game controller as\n * a whole. This is currently only supported on Xbox One controllers. If you\n * want the (more common) whole-controller rumble, use SDL_RumbleJoystick()\n * instead.\n *\n * \\param joystick The joystick to vibrate\n * \\param left_rumble The intensity of the left trigger rumble motor, from 0\n *                    to 0xFFFF\n * \\param right_rumble The intensity of the right trigger rumble motor, from 0\n *                     to 0xFFFF\n * \\param duration_ms The duration of the rumble effect, in milliseconds\n * \\returns 0, or -1 if trigger rumble isn't supported on this joystick\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_JoystickHasRumbleTriggers\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_RumbleJoystickTriggers",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME",
            "Uint16 REWRITE_NAME",
            "Uint16 REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick",
            "left_rumble",
            "right_rumble",
            "duration_ms"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Query whether a joystick has an LED.\n *\n * An example of a joystick LED is the light on the back of a PlayStation 4's\n * DualShock 4 controller.\n *\n * \\param joystick The joystick to query\n * \\return SDL_TRUE if the joystick has a modifiable LED, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_JoystickHasLED",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Query whether a joystick has rumble support.\n *\n * \\param joystick The joystick to query\n * \\return SDL_TRUE if the joystick has rumble, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RumbleJoystick\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_JoystickHasRumble",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Query whether a joystick has rumble support on triggers.\n *\n * \\param joystick The joystick to query\n * \\return SDL_TRUE if the joystick has trigger rumble, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RumbleJoystickTriggers\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_JoystickHasRumbleTriggers",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Update a joystick's LED color.\n *\n * An example of a joystick LED is the light on the back of a PlayStation 4's\n * DualShock 4 controller.\n *\n * \\param joystick The joystick to update\n * \\param red The intensity of the red LED\n * \\param green The intensity of the green LED\n * \\param blue The intensity of the blue LED\n * \\returns 0 on success, -1 if this joystick does not have a modifiable LED\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_SetJoystickLED",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "Uint8 REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick",
            "red",
            "green",
            "blue"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Send a joystick specific effect packet\n *\n * \\param joystick The joystick to affect\n * \\param data The data to send to the joystick\n * \\param size The size of the data to send to the joystick\n * \\returns 0, or -1 if this joystick or driver doesn't support effect packets\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_SendJoystickEffect",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME",
            "const void *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick",
            "data",
            "size"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Close a joystick previously opened with SDL_OpenJoystick().\n *\n * \\param joystick The joystick device to close\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_OpenJoystick\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_CloseJoystick",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the battery level of a joystick as SDL_JoystickPowerLevel.\n *\n * \\param joystick the SDL_Joystick to query\n * \\returns the current battery level as SDL_JoystickPowerLevel on success or\n *          `SDL_JOYSTICK_POWER_UNKNOWN` if it is unknown\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_joystick.h",
        "name": "SDL_GetJoystickPowerLevel",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "SDL_JoystickPowerLevel"
    },
    {
        "comment": "/* Check to make sure enums are the size of ints, for structure packing.\n   For both Watcom C/C++ and Borland C/C++ the compiler option that makes\n   enums having the size of an int must be enabled.\n   This is \"-b\" for Borland C/C++ and \"-ei\" for Watcom C/C++ (v11).\n*/\n",
        "header": "SDL_stdinc.h",
        "name": "SDL_malloc",
        "parameter": [
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "size"
        ],
        "retval": "void*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_calloc",
        "parameter": [
            "size_t REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "nmemb",
            "size"
        ],
        "retval": "void*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_realloc",
        "parameter": [
            "void *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "mem",
            "size"
        ],
        "retval": "void*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_free",
        "parameter": [
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "mem"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the original set of SDL memory functions\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_stdinc.h",
        "name": "SDL_GetOriginalMemoryFunctions",
        "parameter": [
            "SDL_malloc_func *REWRITE_NAME",
            "SDL_calloc_func *REWRITE_NAME",
            "SDL_realloc_func *REWRITE_NAME",
            "SDL_free_func *REWRITE_NAME"
        ],
        "parameter_name": [
            "malloc_func",
            "calloc_func",
            "realloc_func",
            "free_func"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the current set of SDL memory functions\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_stdinc.h",
        "name": "SDL_GetMemoryFunctions",
        "parameter": [
            "SDL_malloc_func *REWRITE_NAME",
            "SDL_calloc_func *REWRITE_NAME",
            "SDL_realloc_func *REWRITE_NAME",
            "SDL_free_func *REWRITE_NAME"
        ],
        "parameter_name": [
            "malloc_func",
            "calloc_func",
            "realloc_func",
            "free_func"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Replace SDL's memory allocation functions with a custom set\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_stdinc.h",
        "name": "SDL_SetMemoryFunctions",
        "parameter": [
            "SDL_malloc_func REWRITE_NAME",
            "SDL_calloc_func REWRITE_NAME",
            "SDL_realloc_func REWRITE_NAME",
            "SDL_free_func REWRITE_NAME"
        ],
        "parameter_name": [
            "malloc_func",
            "calloc_func",
            "realloc_func",
            "free_func"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Allocate memory aligned to a specific value\n *\n * If `alignment` is less than the size of `void *`, then it will be increased to match that.\n *\n * The returned memory address will be a multiple of the alignment value, and the amount of memory allocated will be a multiple of the alignment value.\n *\n * The memory returned by this function must be freed with SDL_aligned_free()\n *\n * \\param alignment the alignment requested\n * \\param size the size to allocate\n * \\returns a pointer to the aligned memory\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_aligned_free\n */\n",
        "header": "SDL_stdinc.h",
        "name": "SDL_aligned_alloc",
        "parameter": [
            "size_t REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "alignment",
            "size"
        ],
        "retval": "void*"
    },
    {
        "comment": "/**\n * Free memory allocated by SDL_aligned_alloc()\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_aligned_alloc\n */\n",
        "header": "SDL_stdinc.h",
        "name": "SDL_aligned_free",
        "parameter": [
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "mem"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the number of outstanding (unfreed) allocations\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_stdinc.h",
        "name": "SDL_GetNumAllocations",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_getenv",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "name"
        ],
        "retval": "char*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_setenv",
        "parameter": [
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "name",
            "value",
            "overwrite"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_qsort",
        "parameter": [
            "void *REWRITE_NAME",
            "size_t REWRITE_NAME",
            "size_t REWRITE_NAME",
            "int (SDLCALL *REWRITE_NAME)(const void *, const void *)"
        ],
        "parameter_name": [
            "base",
            "nmemb",
            "size",
            "compare"
        ],
        "retval": "void"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_bsearch",
        "parameter": [
            "const void *REWRITE_NAME",
            "const void *REWRITE_NAME",
            "size_t REWRITE_NAME",
            "size_t REWRITE_NAME",
            "int (SDLCALL *REWRITE_NAME)(const void *, const void *)"
        ],
        "parameter_name": [
            "key",
            "base",
            "nmemb",
            "size",
            "compare"
        ],
        "retval": "void*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_abs",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_isalpha",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_isalnum",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_isblank",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_iscntrl",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_isdigit",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_isxdigit",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_ispunct",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_isspace",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_isupper",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_islower",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_isprint",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_isgraph",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_toupper",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_tolower",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_crc16",
        "parameter": [
            "Uint16 REWRITE_NAME",
            "const void *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "crc",
            "data",
            "len"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_crc32",
        "parameter": [
            "Uint32 REWRITE_NAME",
            "const void *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "crc",
            "data",
            "len"
        ],
        "retval": "Uint32"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_memset",
        "parameter": [
            "SDL_OUT_BYTECAP (SDL_OUT_BYTECAP(len) void *dst *REWRITE_NAME)void *dst",
            "int REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "param_name_not_specified",
            "c",
            "len"
        ],
        "retval": "void*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_memset4",
        "parameter": [
            "void *REWRITE_NAME",
            "Uint32 REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "dst",
            "val",
            "dwords"
        ],
        "retval": "void*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_memcpy",
        "parameter": [
            "SDL_OUT_BYTECAP (SDL_OUT_BYTECAP(len) void *dst *REWRITE_NAME)void *dst",
            "SDL_IN_BYTECAP (SDL_IN_BYTECAP(len) const void *src *REWRITE_NAME)const void *src",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "param_name_not_specified",
            "param_name_not_specified",
            "len"
        ],
        "retval": "void*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_memmove",
        "parameter": [
            "SDL_OUT_BYTECAP (SDL_OUT_BYTECAP(len) void *dst *REWRITE_NAME)void *dst",
            "SDL_IN_BYTECAP (SDL_IN_BYTECAP(len) const void *src *REWRITE_NAME)const void *src",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "param_name_not_specified",
            "param_name_not_specified",
            "len"
        ],
        "retval": "void*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_memcmp",
        "parameter": [
            "const void *REWRITE_NAME",
            "const void *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "s1",
            "s2",
            "len"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_wcslen",
        "parameter": [
            "const wchar_t *REWRITE_NAME"
        ],
        "parameter_name": [
            "wstr"
        ],
        "retval": "size_t"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_wcslcpy",
        "parameter": [
            "SDL_OUT_Z_CAP (SDL_OUT_Z_CAP(maxlen) wchar_t *dst *REWRITE_NAME)wchar_t *dst",
            "const wchar_t *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "param_name_not_specified",
            "src",
            "maxlen"
        ],
        "retval": "size_t"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_wcslcat",
        "parameter": [
            "SDL_INOUT_Z_CAP (SDL_INOUT_Z_CAP(maxlen) wchar_t *dst *REWRITE_NAME)wchar_t *dst",
            "const wchar_t *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "param_name_not_specified",
            "src",
            "maxlen"
        ],
        "retval": "size_t"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_wcsdup",
        "parameter": [
            "const wchar_t *REWRITE_NAME"
        ],
        "parameter_name": [
            "wstr"
        ],
        "retval": "wchar_t*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_wcsstr",
        "parameter": [
            "const wchar_t *REWRITE_NAME",
            "const wchar_t *REWRITE_NAME"
        ],
        "parameter_name": [
            "haystack",
            "needle"
        ],
        "retval": "wchar_t*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_wcscmp",
        "parameter": [
            "const wchar_t *REWRITE_NAME",
            "const wchar_t *REWRITE_NAME"
        ],
        "parameter_name": [
            "str1",
            "str2"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_wcsncmp",
        "parameter": [
            "const wchar_t *REWRITE_NAME",
            "const wchar_t *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "str1",
            "str2",
            "maxlen"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_wcscasecmp",
        "parameter": [
            "const wchar_t *REWRITE_NAME",
            "const wchar_t *REWRITE_NAME"
        ],
        "parameter_name": [
            "str1",
            "str2"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_wcsncasecmp",
        "parameter": [
            "const wchar_t *REWRITE_NAME",
            "const wchar_t *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "str1",
            "str2",
            "len"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strlen",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "str"
        ],
        "retval": "size_t"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strlcpy",
        "parameter": [
            "SDL_OUT_Z_CAP (SDL_OUT_Z_CAP(maxlen) char *dst *REWRITE_NAME)char *dst",
            "const char *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "param_name_not_specified",
            "src",
            "maxlen"
        ],
        "retval": "size_t"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_utf8strlcpy",
        "parameter": [
            "SDL_OUT_Z_CAP (SDL_OUT_Z_CAP(dst_bytes) char *dst *REWRITE_NAME)char *dst",
            "const char *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "param_name_not_specified",
            "src",
            "dst_bytes"
        ],
        "retval": "size_t"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strlcat",
        "parameter": [
            "SDL_INOUT_Z_CAP (SDL_INOUT_Z_CAP(maxlen) char *dst *REWRITE_NAME)char *dst",
            "const char *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "param_name_not_specified",
            "src",
            "maxlen"
        ],
        "retval": "size_t"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strdup",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "str"
        ],
        "retval": "char*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strrev",
        "parameter": [
            "char *REWRITE_NAME"
        ],
        "parameter_name": [
            "str"
        ],
        "retval": "char*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strupr",
        "parameter": [
            "char *REWRITE_NAME"
        ],
        "parameter_name": [
            "str"
        ],
        "retval": "char*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strlwr",
        "parameter": [
            "char *REWRITE_NAME"
        ],
        "parameter_name": [
            "str"
        ],
        "retval": "char*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strchr",
        "parameter": [
            "const char *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "str",
            "c"
        ],
        "retval": "char*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strrchr",
        "parameter": [
            "const char *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "str",
            "c"
        ],
        "retval": "char*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strstr",
        "parameter": [
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "haystack",
            "needle"
        ],
        "retval": "char*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strcasestr",
        "parameter": [
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "haystack",
            "needle"
        ],
        "retval": "char*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strtokr",
        "parameter": [
            "char *REWRITE_NAME",
            "const char *REWRITE_NAME",
            "char **REWRITE_NAME"
        ],
        "parameter_name": [
            "s1",
            "s2",
            "saveptr"
        ],
        "retval": "char*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_utf8strlen",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "str"
        ],
        "retval": "size_t"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_utf8strnlen",
        "parameter": [
            "const char *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "str",
            "bytes"
        ],
        "retval": "size_t"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_itoa",
        "parameter": [
            "int REWRITE_NAME",
            "char *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "value",
            "str",
            "radix"
        ],
        "retval": "char*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_uitoa",
        "parameter": [
            "unsigned int REWRITE_NAME",
            "char *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "value",
            "str",
            "radix"
        ],
        "retval": "char*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_ltoa",
        "parameter": [
            "long REWRITE_NAME",
            "char *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "value",
            "str",
            "radix"
        ],
        "retval": "char*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_ultoa",
        "parameter": [
            "unsigned long REWRITE_NAME",
            "char *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "value",
            "str",
            "radix"
        ],
        "retval": "char*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_lltoa",
        "parameter": [
            "Sint64 REWRITE_NAME",
            "char *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "value",
            "str",
            "radix"
        ],
        "retval": "char*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_ulltoa",
        "parameter": [
            "Uint64 REWRITE_NAME",
            "char *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "value",
            "str",
            "radix"
        ],
        "retval": "char*"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_atoi",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "str"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_atof",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "str"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strtol",
        "parameter": [
            "const char *REWRITE_NAME",
            "char **REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "str",
            "endp",
            "base"
        ],
        "retval": "long"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strtoul",
        "parameter": [
            "const char *REWRITE_NAME",
            "char **REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "str",
            "endp",
            "base"
        ],
        "retval": "unsigned long"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strtoll",
        "parameter": [
            "const char *REWRITE_NAME",
            "char **REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "str",
            "endp",
            "base"
        ],
        "retval": "Sint64"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strtoull",
        "parameter": [
            "const char *REWRITE_NAME",
            "char **REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "str",
            "endp",
            "base"
        ],
        "retval": "Uint64"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strtod",
        "parameter": [
            "const char *REWRITE_NAME",
            "char **REWRITE_NAME"
        ],
        "parameter_name": [
            "str",
            "endp"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strcmp",
        "parameter": [
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "str1",
            "str2"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strncmp",
        "parameter": [
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "str1",
            "str2",
            "maxlen"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strcasecmp",
        "parameter": [
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "str1",
            "str2"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_strncasecmp",
        "parameter": [
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "str1",
            "str2",
            "len"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_sscanf",
        "parameter": [
            "const char *REWRITE_NAME",
            "SDL_SCANF_FORMAT_STRING const char *REWRITE_NAME",
            "..."
        ],
        "parameter_name": [
            "text",
            "fmt",
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_vsscanf",
        "parameter": [
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME",
            "va_list REWRITE_NAME"
        ],
        "parameter_name": [
            "text",
            "fmt",
            "ap"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_snprintf",
        "parameter": [
            "SDL_OUT_Z_CAP (SDL_OUT_Z_CAP(maxlen) char *text *REWRITE_NAME)char *text",
            "size_t REWRITE_NAME",
            "SDL_PRINTF_FORMAT_STRING const char *REWRITE_NAME",
            "..."
        ],
        "parameter_name": [
            "param_name_not_specified",
            "maxlen",
            "fmt",
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_vsnprintf",
        "parameter": [
            "SDL_OUT_Z_CAP (SDL_OUT_Z_CAP(maxlen) char *text *REWRITE_NAME)char *text",
            "size_t REWRITE_NAME",
            "const char *REWRITE_NAME",
            "va_list REWRITE_NAME"
        ],
        "parameter_name": [
            "param_name_not_specified",
            "maxlen",
            "fmt",
            "ap"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_asprintf",
        "parameter": [
            "char **REWRITE_NAME",
            "SDL_PRINTF_FORMAT_STRING const char *REWRITE_NAME",
            "..."
        ],
        "parameter_name": [
            "strp",
            "fmt",
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_vasprintf",
        "parameter": [
            "char **REWRITE_NAME",
            "const char *REWRITE_NAME",
            "va_list REWRITE_NAME"
        ],
        "parameter_name": [
            "strp",
            "fmt",
            "ap"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Use this function to compute arc cosine of `x`.\n *\n * The definition of `y = acos(x)` is `x = cos(y)`.\n *\n * Domain: `-1 <= x <= 1`\n *\n * Range: `0 <= y <= Pi`\n *\n * \\param x floating point value, in radians.\n * \\returns arc cosine of `x`.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_stdinc.h",
        "name": "SDL_acos",
        "parameter": [
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_acosf",
        "parameter": [
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_asin",
        "parameter": [
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_asinf",
        "parameter": [
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_atan",
        "parameter": [
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_atanf",
        "parameter": [
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_atan2",
        "parameter": [
            "double REWRITE_NAME",
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "y",
            "x"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_atan2f",
        "parameter": [
            "float REWRITE_NAME",
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "y",
            "x"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_ceil",
        "parameter": [
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_ceilf",
        "parameter": [
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_copysign",
        "parameter": [
            "double REWRITE_NAME",
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x",
            "y"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_copysignf",
        "parameter": [
            "float REWRITE_NAME",
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x",
            "y"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_cos",
        "parameter": [
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_cosf",
        "parameter": [
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_exp",
        "parameter": [
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_expf",
        "parameter": [
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_fabs",
        "parameter": [
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_fabsf",
        "parameter": [
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_floor",
        "parameter": [
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_floorf",
        "parameter": [
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_trunc",
        "parameter": [
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_truncf",
        "parameter": [
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_fmod",
        "parameter": [
            "double REWRITE_NAME",
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x",
            "y"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_fmodf",
        "parameter": [
            "float REWRITE_NAME",
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x",
            "y"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_log",
        "parameter": [
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_logf",
        "parameter": [
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_log10",
        "parameter": [
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_log10f",
        "parameter": [
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_modf",
        "parameter": [
            "double REWRITE_NAME",
            "double *REWRITE_NAME"
        ],
        "parameter_name": [
            "x",
            "y"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_modff",
        "parameter": [
            "float REWRITE_NAME",
            "float *REWRITE_NAME"
        ],
        "parameter_name": [
            "x",
            "y"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_pow",
        "parameter": [
            "double REWRITE_NAME",
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x",
            "y"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_powf",
        "parameter": [
            "float REWRITE_NAME",
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x",
            "y"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_round",
        "parameter": [
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_roundf",
        "parameter": [
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_lround",
        "parameter": [
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "long"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_lroundf",
        "parameter": [
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "long"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_scalbn",
        "parameter": [
            "double REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x",
            "n"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_scalbnf",
        "parameter": [
            "float REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "x",
            "n"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_sin",
        "parameter": [
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_sinf",
        "parameter": [
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_sqrt",
        "parameter": [
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_sqrtf",
        "parameter": [
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_tan",
        "parameter": [
            "double REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "double"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_tanf",
        "parameter": [
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "x"
        ],
        "retval": "float"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_iconv_open",
        "parameter": [
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "tocode",
            "fromcode"
        ],
        "retval": "SDL_iconv_t"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_iconv_close",
        "parameter": [
            "SDL_iconv_t REWRITE_NAME"
        ],
        "parameter_name": [
            "cd"
        ],
        "retval": "int"
    },
    {
        "comment": "",
        "header": "SDL_stdinc.h",
        "name": "SDL_iconv",
        "parameter": [
            "SDL_iconv_t REWRITE_NAME",
            "const char **REWRITE_NAME",
            "size_t *REWRITE_NAME",
            "char **REWRITE_NAME",
            "size_t *REWRITE_NAME"
        ],
        "parameter_name": [
            "cd",
            "inbuf",
            "inbytesleft",
            "outbuf",
            "outbytesleft"
        ],
        "retval": "size_t"
    },
    {
        "comment": "/**\n * This function converts a string between encodings in one pass, returning a\n * string that must be freed with SDL_free() or NULL on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_stdinc.h",
        "name": "SDL_iconv_string",
        "parameter": [
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "tocode",
            "fromcode",
            "inbuf",
            "inbytesleft"
        ],
        "retval": "char*"
    },
    {
        "comment": "/**\n * Circumvent failure of SDL_Init() when not using SDL_main() as an entry\n * point.\n *\n * This function is defined in SDL_main.h, along with the preprocessor rule to\n * redefine main() as SDL_main(). Thus to ensure that your main() function\n * will not be changed it is necessary to define SDL_MAIN_HANDLED before\n * including SDL.h.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Init\n */\n",
        "header": "SDL_main.h",
        "name": "SDL_SetMainReady",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Initializes and launches an SDL application, by doing platform-specific\n * initialization before calling your mainFunction and cleanups after it returns,\n * if that is needed for a specific platform, otherwise it just calls mainFunction.\n * You can use this if you want to use your own main() implementation\n * without using SDL_main (like when using SDL_MAIN_HANDLED).\n * When using this, you do *not* need SDL_SetMainReady().\n *\n * \\param argc The argc parameter from the application's main() function,\n *             or 0 if the platform's main-equivalent has no argc\n * \\param argv The argv parameter from the application's main() function,\n *             or NULL  if the platform's main-equivalent has no argv\n * \\param mainFunction Your SDL app's C-style main(), an SDL_main_func.\n *                     NOT the function you're calling this from!\n *                     Its name doesn't matter, but its signature must be\n *                     like int my_main(int argc, char* argv[])\n * \\param reserved should be NULL (reserved for future use, will probably\n *                 be platform-specific then)\n * \\return the return value from mainFunction: 0 on success, -1 on failure;\n *         SDL_GetError() might have more information on the failure\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_main.h",
        "name": "SDL_RunApp",
        "parameter": [
            "int REWRITE_NAME",
            "char *REWRITE_NAME[]",
            "SDL_main_func REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "argc",
            "argv",
            "mainFunction",
            "reserved"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Register a win32 window class for SDL's use.\n *\n * This can be called to set the application window class at startup. It is\n * safe to call this multiple times, as long as every call is eventually\n * paired with a call to SDL_UnregisterApp, but a second registration attempt\n * while a previous registration is still active will be ignored, other than\n * to increment a counter.\n *\n * Most applications do not need to, and should not, call this directly; SDL\n * will call it when initializing the video subsystem.\n *\n * \\param name the window class name, in UTF-8 encoding. If NULL, SDL\n *             currently uses \"SDL_app\" but this isn't guaranteed.\n * \\param style the value to use in WNDCLASSEX::style. If `name` is NULL, SDL\n *              currently uses `(CS_BYTEALIGNCLIENT | CS_OWNDC)` regardless of\n *              what is specified here.\n * \\param hInst the HINSTANCE to use in WNDCLASSEX::hInstance. If zero, SDL\n *              will use `GetModuleHandle(NULL)` instead.\n * \\returns 0 on success, -1 on error. SDL_GetError() may have details.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_main.h",
        "name": "SDL_RegisterApp",
        "parameter": [
            "const char *REWRITE_NAME",
            "Uint32 REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "name",
            "style",
            "hInst"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Deregister the win32 window class from an SDL_RegisterApp call.\n *\n * This can be called to undo the effects of SDL_RegisterApp.\n *\n * Most applications do not need to, and should not, call this directly; SDL\n * will call it when deinitializing the video subsystem.\n *\n * It is safe to call this multiple times, as long as every call is eventually\n * paired with a prior call to SDL_RegisterApp. The window class will only be\n * deregistered when the registration counter in SDL_RegisterApp decrements to\n * zero through calls to this function.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_main.h",
        "name": "SDL_UnregisterApp",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Callback from the application to let the suspend continue.\n *\n * \\since This function is available since SDL 2.28.0.\n */\n",
        "header": "SDL_main.h",
        "name": "SDL_GDKSuspendComplete",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get a list of currently connected sensors.\n *\n * \\param count a pointer filled in with the number of sensors returned\n * \\returns a 0 terminated array of sensor instance IDs which should be freed with SDL_free(), or NULL on error; call SDL_GetError() for more details.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_sensor.h",
        "name": "SDL_GetSensors",
        "parameter": [
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "count"
        ],
        "retval": "SDL_SensorID*"
    },
    {
        "comment": "/**\n * Get the implementation dependent name of a sensor.\n *\n * \\param instance_id the sensor instance ID\n * \\returns the sensor name, or NULL if `instance_id` is not valid\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_sensor.h",
        "name": "SDL_GetSensorInstanceName",
        "parameter": [
            "SDL_SensorID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the type of a sensor.\n *\n * \\param instance_id the sensor instance ID\n * \\returns the SDL_SensorType, or `SDL_SENSOR_INVALID` if `instance_id` is not valid\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_sensor.h",
        "name": "SDL_GetSensorInstanceType",
        "parameter": [
            "SDL_SensorID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "SDL_SensorType"
    },
    {
        "comment": "/**\n * Get the platform dependent type of a sensor.\n *\n * \\param instance_id the sensor instance ID\n * \\returns the sensor platform dependent type, or -1 if `instance_id` is not valid\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_sensor.h",
        "name": "SDL_GetSensorInstanceNonPortableType",
        "parameter": [
            "SDL_SensorID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Open a sensor for use.\n *\n * \\param instance_id the sensor instance ID\n * \\returns an SDL_Sensor sensor object, or NULL if an error occurred.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_sensor.h",
        "name": "SDL_OpenSensor",
        "parameter": [
            "SDL_SensorID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "SDL_Sensor*"
    },
    {
        "comment": "/**\n * Return the SDL_Sensor associated with an instance ID.\n *\n * \\param instance_id the sensor instance ID\n * \\returns an SDL_Sensor object.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_sensor.h",
        "name": "SDL_GetSensorFromInstanceID",
        "parameter": [
            "SDL_SensorID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "SDL_Sensor*"
    },
    {
        "comment": "/**\n * Get the implementation dependent name of a sensor\n *\n * \\param sensor The SDL_Sensor object\n * \\returns the sensor name, or NULL if `sensor` is NULL.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_sensor.h",
        "name": "SDL_GetSensorName",
        "parameter": [
            "SDL_Sensor *REWRITE_NAME"
        ],
        "parameter_name": [
            "sensor"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the type of a sensor.\n *\n * \\param sensor The SDL_Sensor object to inspect\n * \\returns the SDL_SensorType type, or `SDL_SENSOR_INVALID` if `sensor` is\n *          NULL.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_sensor.h",
        "name": "SDL_GetSensorType",
        "parameter": [
            "SDL_Sensor *REWRITE_NAME"
        ],
        "parameter_name": [
            "sensor"
        ],
        "retval": "SDL_SensorType"
    },
    {
        "comment": "/**\n * Get the platform dependent type of a sensor.\n *\n * \\param sensor The SDL_Sensor object to inspect\n * \\returns the sensor platform dependent type, or -1 if `sensor` is NULL.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_sensor.h",
        "name": "SDL_GetSensorNonPortableType",
        "parameter": [
            "SDL_Sensor *REWRITE_NAME"
        ],
        "parameter_name": [
            "sensor"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the instance ID of a sensor.\n *\n * \\param sensor The SDL_Sensor object to inspect\n * \\returns the sensor instance ID, or -1 if `sensor` is NULL.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_sensor.h",
        "name": "SDL_GetSensorInstanceID",
        "parameter": [
            "SDL_Sensor *REWRITE_NAME"
        ],
        "parameter_name": [
            "sensor"
        ],
        "retval": "SDL_SensorID"
    },
    {
        "comment": "/**\n * Get the current state of an opened sensor.\n *\n * The number of values and interpretation of the data is sensor dependent.\n *\n * \\param sensor The SDL_Sensor object to query\n * \\param data A pointer filled with the current sensor state\n * \\param num_values The number of values to write to data\n * \\returns 0 or -1 if an error occurred.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_sensor.h",
        "name": "SDL_GetSensorData",
        "parameter": [
            "SDL_Sensor *REWRITE_NAME",
            "float *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "sensor",
            "data",
            "num_values"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Close a sensor previously opened with SDL_OpenSensor().\n *\n * \\param sensor The SDL_Sensor object to close\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_sensor.h",
        "name": "SDL_CloseSensor",
        "parameter": [
            "SDL_Sensor *REWRITE_NAME"
        ],
        "parameter_name": [
            "sensor"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Update the current state of the open sensors.\n *\n * This is called automatically by the event loop if sensor events are\n * enabled.\n *\n * This needs to be called from the thread that initialized the sensor\n * subsystem.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_sensor.h",
        "name": "SDL_UpdateSensors",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Report the user's preferred locale.\n *\n * This returns an array of SDL_Locale structs, the final item zeroed out.\n * When the caller is done with this array, it should call SDL_free() on the\n * returned value; all the memory involved is allocated in a single block, so\n * a single SDL_free() will suffice.\n *\n * Returned language strings are in the format xx, where 'xx' is an ISO-639\n * language specifier (such as \"en\" for English, \"de\" for German, etc).\n * Country strings are in the format YY, where \"YY\" is an ISO-3166 country\n * code (such as \"US\" for the United States, \"CA\" for Canada, etc). Country\n * might be NULL if there's no specific guidance on them (so you might get {\n * \"en\", \"US\" } for American English, but { \"en\", NULL } means \"English\n * language, generically\"). Language strings are never NULL, except to\n * terminate the array.\n *\n * Please note that not all of these strings are 2 characters; some are three\n * or more.\n *\n * The returned list of locales are in the order of the user's preference. For\n * example, a German citizen that is fluent in US English and knows enough\n * Japanese to navigate around Tokyo might have a list like: { \"de\", \"en_US\",\n * \"jp\", NULL }. Someone from England might prefer British English (where\n * \"color\" is spelled \"colour\", etc), but will settle for anything like it: {\n * \"en_GB\", \"en\", NULL }.\n *\n * This function returns NULL on error, including when the platform does not\n * supply this information at all.\n *\n * This might be a \"slow\" call that has to query the operating system. It's\n * best to ask for this once and save the results. However, this list can\n * change, usually because the user has changed a system preference outside of\n * your program; SDL will send an SDL_LOCALECHANGED event in this case, if\n * possible, and you can call this function again to get an updated copy of\n * preferred locales.\n *\n * \\return array of locales, terminated with a locale with a NULL language\n *         field. Will return NULL on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_locale.h",
        "name": "SDL_GetPreferredLocales",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_Locale*"
    },
    {
        "comment": "/**\n * Create a modal message box.\n *\n * If your needs aren't complex, it might be easier to use\n * SDL_ShowSimpleMessageBox.\n *\n * This function should be called on the thread that created the parent\n * window, or on the main thread if the messagebox has no parent. It will\n * block execution of that thread until the user clicks a button or closes the\n * messagebox.\n *\n * This function may be called at any time, even before SDL_Init(). This makes\n * it useful for reporting errors like a failure to create a renderer or\n * OpenGL context.\n *\n * On X11, SDL rolls its own dialog box with X11 primitives instead of a\n * formal toolkit like GTK+ or Qt.\n *\n * Note that if SDL_Init() would fail because there isn't any available video\n * target, this function is likely to fail for the same reasons. If this is a\n * concern, check the return value from this function and fall back to writing\n * to stderr if you can.\n *\n * \\param messageboxdata the SDL_MessageBoxData structure with title, text and\n *                       other options\n * \\param buttonid the pointer to which user id of hit button should be copied\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ShowSimpleMessageBox\n */\n",
        "header": "SDL_messagebox.h",
        "name": "SDL_ShowMessageBox",
        "parameter": [
            "const SDL_MessageBoxData *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "messageboxdata",
            "buttonid"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Display a simple modal message box.\n *\n * If your needs aren't complex, this function is preferred over\n * SDL_ShowMessageBox.\n *\n * `flags` may be any of the following:\n *\n * - `SDL_MESSAGEBOX_ERROR`: error dialog\n * - `SDL_MESSAGEBOX_WARNING`: warning dialog\n * - `SDL_MESSAGEBOX_INFORMATION`: informational dialog\n *\n * This function should be called on the thread that created the parent\n * window, or on the main thread if the messagebox has no parent. It will\n * block execution of that thread until the user clicks a button or closes the\n * messagebox.\n *\n * This function may be called at any time, even before SDL_Init(). This makes\n * it useful for reporting errors like a failure to create a renderer or\n * OpenGL context.\n *\n * On X11, SDL rolls its own dialog box with X11 primitives instead of a\n * formal toolkit like GTK+ or Qt.\n *\n * Note that if SDL_Init() would fail because there isn't any available video\n * target, this function is likely to fail for the same reasons. If this is a\n * concern, check the return value from this function and fall back to writing\n * to stderr if you can.\n *\n * \\param flags an SDL_MessageBoxFlags value\n * \\param title UTF-8 title text\n * \\param message UTF-8 message text\n * \\param window the parent window, or NULL for no parent\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ShowMessageBox\n */\n",
        "header": "SDL_messagebox.h",
        "name": "SDL_ShowSimpleMessageBox",
        "parameter": [
            "Uint32 REWRITE_NAME",
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME",
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "flags",
            "title",
            "message",
            "window"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Initialize the SDL library.\n *\n * SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the\n * two may be used interchangeably. Though for readability of your code\n * SDL_InitSubSystem() might be preferred.\n *\n * The file I/O (for example: SDL_RWFromFile) and threading (SDL_CreateThread)\n * subsystems are initialized by default. Message boxes\n * (SDL_ShowSimpleMessageBox) also attempt to work without initializing the\n * video subsystem, in hopes of being useful in showing an error dialog when\n * SDL_Init fails. You must specifically initialize other subsystems if you\n * use them in your application.\n *\n * Logging (such as SDL_Log) works without initialization, too.\n *\n * `flags` may be any of the following OR'd together:\n *\n * - `SDL_INIT_TIMER`: timer subsystem\n * - `SDL_INIT_AUDIO`: audio subsystem\n * - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events\n *   subsystem\n * - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the\n *   events subsystem\n * - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem\n * - `SDL_INIT_GAMEPAD`: gamepad subsystem; automatically\n *   initializes the joystick subsystem\n * - `SDL_INIT_EVENTS`: events subsystem\n * - `SDL_INIT_EVERYTHING`: all of the above subsystems\n * - `SDL_INIT_NOPARACHUTE`: compatibility; this flag is ignored\n *\n * Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()\n * for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or\n * call SDL_Quit() to force shutdown). If a subsystem is already loaded then\n * this call will increase the ref-count and return.\n *\n * \\param flags subsystem initialization flags\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_InitSubSystem\n * \\sa SDL_Quit\n * \\sa SDL_SetMainReady\n * \\sa SDL_WasInit\n */\n",
        "header": "SDL_init.h",
        "name": "SDL_Init",
        "parameter": [
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "flags"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Compatibility function to initialize the SDL library.\n *\n * This function and SDL_Init() are interchangeable.\n *\n * \\param flags any of the flags used by SDL_Init(); see SDL_Init for details.\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Init\n * \\sa SDL_Quit\n * \\sa SDL_QuitSubSystem\n */\n",
        "header": "SDL_init.h",
        "name": "SDL_InitSubSystem",
        "parameter": [
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "flags"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Shut down specific SDL subsystems.\n *\n * You still need to call SDL_Quit() even if you close all open subsystems\n * with SDL_QuitSubSystem().\n *\n * \\param flags any of the flags used by SDL_Init(); see SDL_Init for details.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_InitSubSystem\n * \\sa SDL_Quit\n */\n",
        "header": "SDL_init.h",
        "name": "SDL_QuitSubSystem",
        "parameter": [
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "flags"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get a mask of the specified subsystems which are currently initialized.\n *\n * \\param flags any of the flags used by SDL_Init(); see SDL_Init for details.\n * \\returns a mask of all initialized subsystems if `flags` is 0, otherwise it\n *          returns the initialization status of the specified subsystems.\n *\n *          The return value does not include SDL_INIT_NOPARACHUTE.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Init\n * \\sa SDL_InitSubSystem\n */\n",
        "header": "SDL_init.h",
        "name": "SDL_WasInit",
        "parameter": [
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "flags"
        ],
        "retval": "Uint32"
    },
    {
        "comment": "/**\n * Clean up all initialized subsystems.\n *\n * You should call this function even if you have already shutdown each\n * initialized subsystem with SDL_QuitSubSystem(). It is safe to call this\n * function even in the case of errors in initialization.\n *\n * You can use this function with atexit() to ensure that it is run when your\n * application is shutdown, but it is not wise to do this from a library or\n * other dynamically loaded code.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Init\n * \\sa SDL_QuitSubSystem\n */\n",
        "header": "SDL_init.h",
        "name": "SDL_Quit",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Dynamically load a shared object.\n *\n * \\param sofile a system-dependent name of the object file\n * \\returns an opaque pointer to the object handle or NULL if there was an\n *          error; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_LoadFunction\n * \\sa SDL_UnloadObject\n */\n",
        "header": "SDL_loadso.h",
        "name": "SDL_LoadObject",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "sofile"
        ],
        "retval": "void*"
    },
    {
        "comment": "/**\n * Unload a shared object from memory.\n *\n * \\param handle a valid shared object handle returned by SDL_LoadObject()\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_LoadFunction\n * \\sa SDL_LoadObject\n */\n",
        "header": "SDL_loadso.h",
        "name": "SDL_UnloadObject",
        "parameter": [
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "handle"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set a hint with a specific priority.\n *\n * The priority controls the behavior when setting a hint that already has a\n * value. Hints will replace existing hints of their priority and lower.\n * Environment variables are considered to have override priority.\n *\n * \\param name the hint to set\n * \\param value the value of the hint variable\n * \\param priority the SDL_HintPriority level for the hint\n * \\returns SDL_TRUE if the hint was set, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetHint\n * \\sa SDL_SetHint\n */\n",
        "header": "SDL_hints.h",
        "name": "SDL_SetHintWithPriority",
        "parameter": [
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME",
            "SDL_HintPriority REWRITE_NAME"
        ],
        "parameter_name": [
            "name",
            "value",
            "priority"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Set a hint with normal priority.\n *\n * Hints will not be set if there is an existing override hint or environment\n * variable that takes precedence. You can use SDL_SetHintWithPriority() to\n * set the hint with override priority instead.\n *\n * \\param name the hint to set\n * \\param value the value of the hint variable\n * \\returns SDL_TRUE if the hint was set, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetHint\n * \\sa SDL_SetHintWithPriority\n */\n",
        "header": "SDL_hints.h",
        "name": "SDL_SetHint",
        "parameter": [
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "name",
            "value"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Reset a hint to the default value.\n *\n * This will reset a hint to the value of the environment variable, or NULL if\n * the environment isn't set. Callbacks will be called normally with this\n * change.\n *\n * \\param name the hint to set\n * \\returns SDL_TRUE if the hint was set, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetHint\n * \\sa SDL_SetHint\n */\n",
        "header": "SDL_hints.h",
        "name": "SDL_ResetHint",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "name"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Reset all hints to the default values.\n *\n * This will reset all hints to the value of the associated environment\n * variable, or NULL if the environment isn't set. Callbacks will be called\n * normally with this change.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetHint\n * \\sa SDL_SetHint\n * \\sa SDL_ResetHint\n */\n",
        "header": "SDL_hints.h",
        "name": "SDL_ResetHints",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the value of a hint.\n *\n * \\param name the hint to query\n * \\returns the string value of a hint or NULL if the hint isn't set.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetHint\n * \\sa SDL_SetHintWithPriority\n */\n",
        "header": "SDL_hints.h",
        "name": "SDL_GetHint",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "name"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the boolean value of a hint variable.\n *\n * \\param name the name of the hint to get the boolean value from\n * \\param default_value the value to return if the hint does not exist\n * \\returns the boolean value of a hint or the provided default value if the\n *          hint does not exist.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetHint\n * \\sa SDL_SetHint\n */\n",
        "header": "SDL_hints.h",
        "name": "SDL_GetHintBoolean",
        "parameter": [
            "const char *REWRITE_NAME",
            "SDL_bool REWRITE_NAME"
        ],
        "parameter_name": [
            "name",
            "default_value"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Add a function to watch a particular hint.\n *\n * \\param name the hint to watch\n * \\param callback An SDL_HintCallback function that will be called when the\n *                 hint value changes\n * \\param userdata a pointer to pass to the callback function\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_DelHintCallback\n */\n",
        "header": "SDL_hints.h",
        "name": "SDL_AddHintCallback",
        "parameter": [
            "const char *REWRITE_NAME",
            "SDL_HintCallback REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "name",
            "callback",
            "userdata"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Remove a function watching a particular hint.\n *\n * \\param name the hint being watched\n * \\param callback An SDL_HintCallback function that will be called when the\n *                 hint value changes\n * \\param userdata a pointer being passed to the callback function\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AddHintCallback\n */\n",
        "header": "SDL_hints.h",
        "name": "SDL_DelHintCallback",
        "parameter": [
            "const char *REWRITE_NAME",
            "SDL_HintCallback REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "name",
            "callback",
            "userdata"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Clear all hints.\n *\n * This function is automatically called during SDL_Quit(), and deletes all\n * callbacks without calling them and frees all memory associated with hints.\n * If you're calling this from application code you probably want to call\n * SDL_ResetHints() instead.\n *\n * This function will be removed from the API the next time we rev the ABI.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ResetHints\n */\n",
        "header": "SDL_hints.h",
        "name": "SDL_ClearHints",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Dynamically load the Vulkan loader library.\n *\n * This should be called after initializing the video driver, but before\n * creating any Vulkan windows. If no Vulkan loader library is loaded, the\n * default library will be loaded upon creation of the first Vulkan window.\n *\n * It is fairly common for Vulkan applications to link with libvulkan instead\n * of explicitly loading it at run time. This will work with SDL provided the\n * application links to a dynamic library and both it and SDL use the same\n * search path.\n *\n * If you specify a non-NULL `path`, an application should retrieve all of the\n * Vulkan functions it uses from the dynamic library using\n * SDL_Vulkan_GetVkGetInstanceProcAddr unless you can guarantee `path` points\n * to the same vulkan loader library the application linked to.\n *\n * On Apple devices, if `path` is NULL, SDL will attempt to find the\n * `vkGetInstanceProcAddr` address within all the Mach-O images of the current\n * process. This is because it is fairly common for Vulkan applications to\n * link with libvulkan (and historically MoltenVK was provided as a static\n * library). If it is not found, on macOS, SDL will attempt to load\n * `vulkan.framework/vulkan`, `libvulkan.1.dylib`,\n * `MoltenVK.framework/MoltenVK`, and `libMoltenVK.dylib`, in that order. On\n * iOS, SDL will attempt to load `libMoltenVK.dylib`. Applications using a\n * dynamic framework or .dylib must ensure it is included in its application\n * bundle.\n *\n * On non-Apple devices, application linking with a static libvulkan is not\n * supported. Either do not link to the Vulkan loader or link to a dynamic\n * library version.\n *\n * \\param path The platform dependent Vulkan loader library name or NULL\n * \\returns 0 on success or -1 if the library couldn't be loaded; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Vulkan_GetVkInstanceProcAddr\n * \\sa SDL_Vulkan_UnloadLibrary\n */\n",
        "header": "SDL_vulkan.h",
        "name": "SDL_Vulkan_LoadLibrary",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "path"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the address of the `vkGetInstanceProcAddr` function.\n *\n * This should be called after either calling SDL_Vulkan_LoadLibrary() or\n * creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.\n *\n * The actual type of the returned function pointer is PFN_vkGetInstanceProcAddr,\n * but that isn't available because the Vulkan headers are not included here. You\n * should cast the return value of this function to that type, e.g.\n *\n *  `vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)SDL_Vulkan_GetVkGetInstanceProcAddr();`\n *\n * \\returns the function pointer for `vkGetInstanceProcAddr` or NULL on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_vulkan.h",
        "name": "SDL_Vulkan_GetVkGetInstanceProcAddr",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_FunctionPointer"
    },
    {
        "comment": "/**\n * Unload the Vulkan library previously loaded by SDL_Vulkan_LoadLibrary()\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Vulkan_LoadLibrary\n */\n",
        "header": "SDL_vulkan.h",
        "name": "SDL_Vulkan_UnloadLibrary",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the names of the Vulkan instance extensions needed to create a surface\n * with SDL_Vulkan_CreateSurface.\n *\n * This should be called after either calling SDL_Vulkan_LoadLibrary() or\n * creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.\n *\n * If `pNames` is NULL, then the number of required Vulkan instance extensions\n * is returned in `pCount`. Otherwise, `pCount` must point to a variable set\n * to the number of elements in the `pNames` array, and on return the variable\n * is overwritten with the number of names actually written to `pNames`. If\n * `pCount` is less than the number of required extensions, at most `pCount`\n * structures will be written. If `pCount` is smaller than the number of\n * required extensions, SDL_FALSE will be returned instead of SDL_TRUE, to\n * indicate that not all the required extensions were returned.\n *\n * \\param pCount A pointer to an unsigned int corresponding to the number of\n *               extensions to be returned\n * \\param pNames NULL or a pointer to an array to be filled with required\n *               Vulkan instance extensions\n * \\returns SDL_TRUE on success, SDL_FALSE on error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Vulkan_CreateSurface\n */\n",
        "header": "SDL_vulkan.h",
        "name": "SDL_Vulkan_GetInstanceExtensions",
        "parameter": [
            "unsigned int *REWRITE_NAME",
            "const char **REWRITE_NAME"
        ],
        "parameter_name": [
            "pCount",
            "pNames"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Create a Vulkan rendering surface for a window.\n *\n * The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and\n * `instance` must have been created with extensions returned by\n * SDL_Vulkan_GetInstanceExtensions() enabled.\n *\n * \\param window The window to which to attach the Vulkan surface\n * \\param instance The Vulkan instance handle\n * \\param surface A pointer to a VkSurfaceKHR handle to output the newly\n *                created surface\n * \\returns SDL_TRUE on success, SDL_FALSE on error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Vulkan_GetInstanceExtensions\n * \\sa SDL_Vulkan_GetDrawableSize\n */\n",
        "header": "SDL_vulkan.h",
        "name": "SDL_Vulkan_CreateSurface",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "VkInstance REWRITE_NAME",
            "VkSurfaceKHR *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "instance",
            "surface"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Get the size of the window's underlying drawable dimensions in pixels.\n *\n * This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI\n * drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a\n * platform with high-DPI support (Apple calls this \"Retina\"), and not\n * disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.\n *\n * \\param window an SDL_Window for which the size is to be queried\n * \\param w Pointer to the variable to write the width to or NULL\n * \\param h Pointer to the variable to write the height to or NULL\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowSize\n * \\sa SDL_CreateWindow\n * \\sa SDL_Vulkan_CreateSurface\n */\n",
        "header": "SDL_vulkan.h",
        "name": "SDL_Vulkan_GetDrawableSize",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "w",
            "h"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Add support for gamepads that SDL is unaware of or change the binding of an\n * existing gamepad.\n *\n * The mapping string has the format \"GUID,name,mapping\", where GUID is the\n * string value from SDL_GetJoystickGUIDString(), name is the human readable\n * string for the device and mappings are gamepad mappings to joystick\n * ones. Under Windows there is a reserved GUID of \"xinput\" that covers all\n * XInput devices. The mapping format for joystick is: {| |bX |a joystick\n * button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick\n * |} Buttons can be used as a gamepad axes and vice versa.\n *\n * This string shows an example of a valid mapping for a gamepad:\n *\n * ```c\n * \"341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7\"\n * ```\n *\n * \\param mappingString the mapping string\n * \\returns 1 if a new mapping is added, 0 if an existing mapping is updated,\n *          -1 on error; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadMapping\n * \\sa SDL_GetGamepadMappingForGUID\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_AddGamepadMapping",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "mappingString"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Load a set of gamepad mappings from a seekable SDL data stream.\n *\n * You can call this function several times, if needed, to load different\n * database files.\n *\n * If a new mapping is loaded for an already known gamepad GUID, the later\n * version will overwrite the one currently loaded.\n *\n * Mappings not belonging to the current platform or with no platform field\n * specified will be ignored (i.e. mappings for Linux will be ignored in\n * Windows, etc).\n *\n * This function will load the text database entirely in memory before\n * processing it, so take this into consideration if you are in a memory\n * constrained environment.\n *\n * \\param rw the data stream for the mappings to be added\n * \\param freerw non-zero to close the stream after being read\n * \\returns the number of mappings added or -1 on error; call SDL_GetError()\n *          for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AddGamepadMapping\n * \\sa SDL_AddGamepadMappingsFromFile\n * \\sa SDL_GetGamepadMappingForGUID\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_AddGamepadMappingsFromRW",
        "parameter": [
            "SDL_RWops *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "rw",
            "freerw"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the number of mappings installed.\n *\n * \\returns the number of mappings.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetNumGamepadMappings",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the mapping at a particular index.\n *\n * \\returns the mapping string. Must be freed with SDL_free(). Returns NULL if\n *          the index is out of range.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadMappingForIndex",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "mapping_index"
        ],
        "retval": "char*"
    },
    {
        "comment": "/**\n * Get the gamepad mapping string for a given GUID.\n *\n * The returned string must be freed with SDL_free().\n *\n * \\param guid a structure containing the GUID for which a mapping is desired\n * \\returns a mapping string or NULL on error; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetJoystickInstanceGUID\n * \\sa SDL_GetJoystickGUID\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadMappingForGUID",
        "parameter": [
            "SDL_JoystickGUID REWRITE_NAME"
        ],
        "parameter_name": [
            "guid"
        ],
        "retval": "char*"
    },
    {
        "comment": "/**\n * Get the current mapping of a gamepad.\n *\n * The returned string must be freed with SDL_free().\n *\n * Details about mappings are discussed with SDL_AddGamepadMapping().\n *\n * \\param gamepad the gamepad you want to get the current\n *                       mapping for\n * \\returns a string that has the gamepad's mapping or NULL if no mapping\n *          is available; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AddGamepadMapping\n * \\sa SDL_GetGamepadMappingForGUID\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadMapping",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "char*"
    },
    {
        "comment": "/**\n * Get a list of currently connected gamepads.\n *\n * \\param count a pointer filled in with the number of gamepads returned\n * \\returns a 0 terminated array of joystick instance IDs which should be freed with SDL_free(), or NULL on error; call SDL_GetError() for more details.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_OpenGamepad\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepads",
        "parameter": [
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "count"
        ],
        "retval": "SDL_JoystickID*"
    },
    {
        "comment": "/**\n * Check if the given joystick is supported by the gamepad interface.\n *\n * \\param instance_id the joystick instance ID\n * \\returns SDL_TRUE if the given joystick is supported by the gamepad\n *          interface, SDL_FALSE if it isn't or it's an invalid index.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadNameForIndex\n * \\sa SDL_OpenGamepad\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_IsGamepad",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Get the implementation dependent name of a gamepad.\n *\n * This can be called before any gamepads are opened.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the name of the selected gamepad. If no name can be found, this\n *          function returns NULL; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadName\n * \\sa SDL_OpenGamepad\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadInstanceName",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the implementation dependent path of a gamepad.\n *\n * This can be called before any gamepads are opened.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the path of the selected gamepad. If no path can be found, this\n *          function returns NULL; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadPath\n * \\sa SDL_OpenGamepad\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadInstancePath",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the player index of a gamepad.\n *\n * This can be called before any gamepads are opened.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the player index of a gamepad, or -1 if it's not available\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadPlayerIndex\n * \\sa SDL_OpenGamepad\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadInstancePlayerIndex",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the implementation-dependent GUID of a gamepad.\n *\n * This can be called before any gamepads are opened.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the GUID of the selected gamepad. If called on an invalid index,\n *          this function returns a zero GUID\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadGUID\n * \\sa SDL_GetGamepadGUIDString\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadInstanceGUID",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "SDL_JoystickGUID"
    },
    {
        "comment": "/**\n * Get the USB vendor ID of a gamepad, if available.\n *\n * This can be called before any gamepads are opened. If the vendor ID isn't\n * available this function returns 0.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the USB vendor ID of the selected gamepad. If called on an\n *          invalid index, this function returns zero\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadInstanceVendor",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "/**\n * Get the USB product ID of a gamepad, if available.\n *\n * This can be called before any gamepads are opened. If the product ID isn't\n * available this function returns 0.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the USB product ID of the selected gamepad. If called on an\n *          invalid index, this function returns zero\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadInstanceProduct",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "/**\n * Get the product version of a gamepad, if available.\n *\n * This can be called before any gamepads are opened. If the product version\n * isn't available this function returns 0.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the product version of the selected gamepad. If called on an\n *          invalid index, this function returns zero\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadInstanceProductVersion",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "/**\n * Get the type of a gamepad.\n *\n * This can be called before any gamepads are opened.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the gamepad type.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadInstanceType",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "SDL_GamepadType"
    },
    {
        "comment": "/**\n * Get the mapping of a gamepad.\n *\n * This can be called before any gamepads are opened.\n *\n * \\param instance_id the joystick instance ID\n * \\returns the mapping string. Must be freed with SDL_free(). Returns NULL if\n *          no mapping is available.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadInstanceMapping",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "char*"
    },
    {
        "comment": "/**\n * Open a gamepad for use.\n *\n * \\param instance_id the joystick instance ID\n * \\returns a gamepad identifier or NULL if an error occurred; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CloseGamepad\n * \\sa SDL_GetGamepadNameForIndex\n * \\sa SDL_IsGamepad\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_OpenGamepad",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "SDL_Gamepad*"
    },
    {
        "comment": "/**\n * Get the SDL_Gamepad associated with a joystick instance ID.\n *\n * \\param instance_id the joystick instance ID of the gamepad\n * \\returns an SDL_Gamepad on success or NULL on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadFromInstanceID",
        "parameter": [
            "SDL_JoystickID REWRITE_NAME"
        ],
        "parameter_name": [
            "instance_id"
        ],
        "retval": "SDL_Gamepad*"
    },
    {
        "comment": "/**\n * Get the SDL_Gamepad associated with a player index.\n *\n * \\param player_index the player index, which different from the instance ID\n * \\returns the SDL_Gamepad associated with a player index.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadPlayerIndex\n * \\sa SDL_SetGamepadPlayerIndex\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadFromPlayerIndex",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "player_index"
        ],
        "retval": "SDL_Gamepad*"
    },
    {
        "comment": "/**\n * Get the implementation-dependent name for an opened gamepad.\n *\n * This is the same name as returned by SDL_GetGamepadNameForIndex(), but\n * it takes a gamepad identifier instead of the (unstable) device index.\n *\n * \\param gamepad a gamepad identifier previously returned by\n *                       SDL_OpenGamepad()\n * \\returns the implementation dependent name for the gamepad, or NULL\n *          if there is no name or the identifier passed is invalid.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadNameForIndex\n * \\sa SDL_OpenGamepad\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadName",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the implementation-dependent path for an opened gamepad.\n *\n * This is the same path as returned by SDL_GetGamepadNameForIndex(), but\n * it takes a gamepad identifier instead of the (unstable) device index.\n *\n * \\param gamepad a gamepad identifier previously returned by\n *                       SDL_OpenGamepad()\n * \\returns the implementation dependent path for the gamepad, or NULL\n *          if there is no path or the identifier passed is invalid.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadInstancePath\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadPath",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the type of this currently opened gamepad\n *\n * This is the same name as returned by SDL_GetGamepadInstanceType(), but\n * it takes a gamepad identifier instead of the (unstable) device index.\n *\n * \\param gamepad the gamepad object to query.\n * \\returns the gamepad type.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadType",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "SDL_GamepadType"
    },
    {
        "comment": "/**\n * Get the player index of an opened gamepad.\n *\n * For XInput gamepads this returns the XInput user index.\n *\n * \\param gamepad the gamepad object to query.\n * \\returns the player index for gamepad, or -1 if it's not available.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadPlayerIndex",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set the player index of an opened gamepad.\n *\n * \\param gamepad the gamepad object to adjust.\n * \\param player_index Player index to assign to this gamepad, or -1 to\n *                     clear the player index and turn off player LEDs.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_SetGamepadPlayerIndex",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "player_index"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the USB vendor ID of an opened gamepad, if available.\n *\n * If the vendor ID isn't available this function returns 0.\n *\n * \\param gamepad the gamepad object to query.\n * \\return the USB vendor ID, or zero if unavailable.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadVendor",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "/**\n * Get the USB product ID of an opened gamepad, if available.\n *\n * If the product ID isn't available this function returns 0.\n *\n * \\param gamepad the gamepad object to query.\n * \\return the USB product ID, or zero if unavailable.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadProduct",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "/**\n * Get the product version of an opened gamepad, if available.\n *\n * If the product version isn't available this function returns 0.\n *\n * \\param gamepad the gamepad object to query.\n * \\return the USB product version, or zero if unavailable.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadProductVersion",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "/**\n * Get the firmware version of an opened gamepad, if available.\n *\n * If the firmware version isn't available this function returns 0.\n *\n * \\param gamepad the gamepad object to query.\n * \\return the gamepad firmware version, or zero if unavailable.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadFirmwareVersion",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "/**\n * Get the serial number of an opened gamepad, if available.\n *\n * Returns the serial number of the gamepad, or NULL if it is not\n * available.\n *\n * \\param gamepad the gamepad object to query.\n * \\return the serial number, or NULL if unavailable.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadSerial",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Check if a gamepad has been opened and is currently connected.\n *\n * \\param gamepad a gamepad identifier previously returned by\n *                       SDL_OpenGamepad()\n * \\returns SDL_TRUE if the gamepad has been opened and is currently\n *          connected, or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CloseGamepad\n * \\sa SDL_OpenGamepad\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GamepadConnected",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Get the underlying joystick from a gamepad\n *\n * This function will give you a SDL_Joystick object, which allows you to use\n * the SDL_Joystick functions with a SDL_Gamepad object. This would be\n * useful for getting a joystick's position at any given time, even if it\n * hasn't moved (moving it would produce an event, which would have the axis'\n * value).\n *\n * The pointer returned is owned by the SDL_Gamepad. You should not\n * call SDL_CloseJoystick() on it, for example, since doing so will likely\n * cause SDL to crash.\n *\n * \\param gamepad the gamepad object that you want to get a\n *                       joystick from\n * \\returns an SDL_Joystick object; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadJoystick",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "SDL_Joystick*"
    },
    {
        "comment": "/**\n * Set the state of gamepad event processing.\n *\n * If gamepad events are disabled, you must call SDL_UpdateGamepads()\n * yourself and check the state of the gamepad when you want gamepad\n * information.\n *\n * \\param enabled whether to process gamepad events or not\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GamepadEventsEnabled\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_SetGamepadEventsEnabled",
        "parameter": [
            "SDL_bool REWRITE_NAME"
        ],
        "parameter_name": [
            "enabled"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Query the state of gamepad event processing.\n *\n * If gamepad events are disabled, you must call SDL_UpdateGamepads()\n * yourself and check the state of the gamepad when you want gamepad\n * information.\n *\n * \\returns SDL_TRUE if gamepad events are being processed, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetGamepadEventsEnabled\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GamepadEventsEnabled",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Manually pump gamepad updates if not using the loop.\n *\n * This function is called automatically by the event loop if events are\n * enabled. Under such circumstances, it will not be necessary to call this\n * function.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_UpdateGamepads",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Convert a string into SDL_GamepadAxis enum.\n *\n * This function is called internally to translate SDL_Gamepad mapping\n * strings for the underlying joystick device into the consistent\n * SDL_Gamepad mapping. You do not normally need to call this function\n * unless you are parsing SDL_Gamepad mappings in your own code.\n *\n * Note specially that \"righttrigger\" and \"lefttrigger\" map to\n * `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,\n * respectively.\n *\n * \\param str string representing a SDL_Gamepad axis\n * \\returns the SDL_GamepadAxis enum corresponding to the input string,\n *          or `SDL_GAMEPAD_AXIS_INVALID` if no match was found.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadStringForAxis\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadAxisFromString",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "str"
        ],
        "retval": "SDL_GamepadAxis"
    },
    {
        "comment": "/**\n * Convert from an SDL_GamepadAxis enum to a string.\n *\n * The caller should not SDL_free() the returned string.\n *\n * \\param axis an enum value for a given SDL_GamepadAxis\n * \\returns a string for the given axis, or NULL if an invalid axis is\n *          specified. The string returned is of the format used by\n *          SDL_Gamepad mapping strings.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadAxisFromString\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadStringForAxis",
        "parameter": [
            "SDL_GamepadAxis REWRITE_NAME"
        ],
        "parameter_name": [
            "axis"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the SDL joystick layer binding for a gamepad axis mapping.\n *\n * \\param gamepad a gamepad\n * \\param axis an axis enum value (one of the SDL_GamepadAxis values)\n * \\returns a SDL_GamepadBinding describing the bind. On failure\n *          (like the given Controller axis doesn't exist on the device), its\n *          `.bindType` will be `SDL_GAMEPAD_BINDTYPE_NONE`.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadBindForButton\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadBindForAxis",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "SDL_GamepadAxis REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "axis"
        ],
        "retval": "SDL_GamepadBinding"
    },
    {
        "comment": "/**\n * Query whether a gamepad has a given axis.\n *\n * This merely reports whether the gamepad's mapping defined this axis, as\n * that is all the information SDL has about the physical device.\n *\n * \\param gamepad a gamepad\n * \\param axis an axis enum value (an SDL_GamepadAxis value)\n * \\returns SDL_TRUE if the gamepad has this axis, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GamepadHasAxis",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "SDL_GamepadAxis REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "axis"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Get the current state of an axis control on a gamepad.\n *\n * The axis indices start at index 0.\n *\n * The state is a value ranging from -32768 to 32767. Triggers, however, range\n * from 0 to 32767 (they never return a negative value).\n *\n * \\param gamepad a gamepad\n * \\param axis an axis index (one of the SDL_GamepadAxis values)\n * \\returns axis state (including 0) on success or 0 (also) on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadButton\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadAxis",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "SDL_GamepadAxis REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "axis"
        ],
        "retval": "Sint16"
    },
    {
        "comment": "/**\n * Convert a string into an SDL_GamepadButton enum.\n *\n * This function is called internally to translate SDL_Gamepad mapping\n * strings for the underlying joystick device into the consistent\n * SDL_Gamepad mapping. You do not normally need to call this function\n * unless you are parsing SDL_Gamepad mappings in your own code.\n *\n * \\param str string representing a SDL_Gamepad axis\n * \\returns the SDL_GamepadButton enum corresponding to the input\n *          string, or `SDL_GAMEPAD_AXIS_INVALID` if no match was found.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadButtonFromString",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "str"
        ],
        "retval": "SDL_GamepadButton"
    },
    {
        "comment": "/**\n * Convert from an SDL_GamepadButton enum to a string.\n *\n * The caller should not SDL_free() the returned string.\n *\n * \\param button an enum value for a given SDL_GamepadButton\n * \\returns a string for the given button, or NULL if an invalid button is\n *          specified. The string returned is of the format used by\n *          SDL_Gamepad mapping strings.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadButtonFromString\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadStringForButton",
        "parameter": [
            "SDL_GamepadButton REWRITE_NAME"
        ],
        "parameter_name": [
            "button"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the SDL joystick layer binding for a gamepad button mapping.\n *\n * \\param gamepad a gamepad\n * \\param button an button enum value (an SDL_GamepadButton value)\n * \\returns a SDL_GamepadBinding describing the bind. On failure\n *          (like the given Controller button doesn't exist on the device),\n *          its `.bindType` will be `SDL_GAMEPAD_BINDTYPE_NONE`.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadBindForAxis\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadBindForButton",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "SDL_GamepadButton REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "button"
        ],
        "retval": "SDL_GamepadBinding"
    },
    {
        "comment": "/**\n * Query whether a gamepad has a given button.\n *\n * This merely reports whether the gamepad's mapping defined this button,\n * as that is all the information SDL has about the physical device.\n *\n * \\param gamepad a gamepad\n * \\param button a button enum value (an SDL_GamepadButton value)\n * \\returns SDL_TRUE if the gamepad has this button, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GamepadHasButton",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "SDL_GamepadButton REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "button"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Get the current state of a button on a gamepad.\n *\n * \\param gamepad a gamepad\n * \\param button a button index (one of the SDL_GamepadButton values)\n * \\returns 1 for pressed state or 0 for not pressed state or error; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadAxis\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadButton",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "SDL_GamepadButton REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "button"
        ],
        "retval": "Uint8"
    },
    {
        "comment": "/**\n * Get the number of touchpads on a gamepad.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadNumTouchpads",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the number of supported simultaneous fingers on a touchpad on a game\n * gamepad.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadNumTouchpadFingers",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "touchpad"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the current state of a finger on a touchpad on a gamepad.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadTouchpadFinger",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "Uint8 *REWRITE_NAME",
            "float *REWRITE_NAME",
            "float *REWRITE_NAME",
            "float *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "touchpad",
            "finger",
            "state",
            "x",
            "y",
            "pressure"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Return whether a gamepad has a particular sensor.\n *\n * \\param gamepad The gamepad to query\n * \\param type The type of sensor to query\n * \\returns SDL_TRUE if the sensor exists, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GamepadHasSensor",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "SDL_SensorType REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "type"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Set whether data reporting for a gamepad sensor is enabled.\n *\n * \\param gamepad The gamepad to update\n * \\param type The type of sensor to enable/disable\n * \\param enabled Whether data reporting should be enabled\n * \\returns 0 or -1 if an error occurred.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_SetGamepadSensorEnabled",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "SDL_SensorType REWRITE_NAME",
            "SDL_bool REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "type",
            "enabled"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Query whether sensor data reporting is enabled for a gamepad.\n *\n * \\param gamepad The gamepad to query\n * \\param type The type of sensor to query\n * \\returns SDL_TRUE if the sensor is enabled, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GamepadSensorEnabled",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "SDL_SensorType REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "type"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Get the data rate (number of events per second) of a gamepad\n * sensor.\n *\n * \\param gamepad The gamepad to query\n * \\param type The type of sensor to query\n * \\return the data rate, or 0.0f if the data rate is not available.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadSensorDataRate",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "SDL_SensorType REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "type"
        ],
        "retval": "float"
    },
    {
        "comment": "/**\n * Get the current state of a gamepad sensor.\n *\n * The number of values and interpretation of the data is sensor dependent.\n * See SDL_sensor.h for the details for each type of sensor.\n *\n * \\param gamepad The gamepad to query\n * \\param type The type of sensor to query\n * \\param data A pointer filled with the current sensor state\n * \\param num_values The number of values to write to data\n * \\return 0 or -1 if an error occurred.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadSensorData",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "SDL_SensorType REWRITE_NAME",
            "float *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "type",
            "data",
            "num_values"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Start a rumble effect on a gamepad.\n *\n * Each call to this function cancels any previous rumble effect, and calling\n * it with 0 intensity stops any rumbling.\n *\n * \\param gamepad The gamepad to vibrate\n * \\param low_frequency_rumble The intensity of the low frequency (left)\n *                             rumble motor, from 0 to 0xFFFF\n * \\param high_frequency_rumble The intensity of the high frequency (right)\n *                              rumble motor, from 0 to 0xFFFF\n * \\param duration_ms The duration of the rumble effect, in milliseconds\n * \\returns 0, or -1 if rumble isn't supported on this gamepad\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GamepadHasRumble\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_RumbleGamepad",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "Uint16 REWRITE_NAME",
            "Uint16 REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "low_frequency_rumble",
            "high_frequency_rumble",
            "duration_ms"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Start a rumble effect in the gamepad's triggers.\n *\n * Each call to this function cancels any previous trigger rumble effect, and\n * calling it with 0 intensity stops any rumbling.\n *\n * Note that this is rumbling of the _triggers_ and not the gamepad as\n * a whole. This is currently only supported on Xbox One gamepads. If you\n * want the (more common) whole-gamepad rumble, use\n * SDL_RumbleGamepad() instead.\n *\n * \\param gamepad The gamepad to vibrate\n * \\param left_rumble The intensity of the left trigger rumble motor, from 0\n *                    to 0xFFFF\n * \\param right_rumble The intensity of the right trigger rumble motor, from 0\n *                     to 0xFFFF\n * \\param duration_ms The duration of the rumble effect, in milliseconds\n * \\returns 0, or -1 if trigger rumble isn't supported on this gamepad\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GamepadHasRumbleTriggers\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_RumbleGamepadTriggers",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "Uint16 REWRITE_NAME",
            "Uint16 REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "left_rumble",
            "right_rumble",
            "duration_ms"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Query whether a gamepad has an LED.\n *\n * \\param gamepad The gamepad to query\n * \\returns SDL_TRUE, or SDL_FALSE if this gamepad does not have a\n *          modifiable LED\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GamepadHasLED",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Query whether a gamepad has rumble support.\n *\n * \\param gamepad The gamepad to query\n * \\returns SDL_TRUE, or SDL_FALSE if this gamepad does not have rumble\n *          support\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RumbleGamepad\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GamepadHasRumble",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Query whether a gamepad has rumble support on triggers.\n *\n * \\param gamepad The gamepad to query\n * \\returns SDL_TRUE, or SDL_FALSE if this gamepad does not have trigger\n *          rumble support\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RumbleGamepadTriggers\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GamepadHasRumbleTriggers",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Update a gamepad's LED color.\n *\n * \\param gamepad The gamepad to update\n * \\param red The intensity of the red LED\n * \\param green The intensity of the green LED\n * \\param blue The intensity of the blue LED\n * \\returns 0, or -1 if this gamepad does not have a modifiable LED\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_SetGamepadLED",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "Uint8 REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "red",
            "green",
            "blue"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Send a gamepad specific effect packet\n *\n * \\param gamepad The gamepad to affect\n * \\param data The data to send to the gamepad\n * \\param size The size of the data to send to the gamepad\n * \\returns 0, or -1 if this gamepad or driver doesn't support effect\n *          packets\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_SendGamepadEffect",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "const void *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "data",
            "size"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Close a gamepad previously opened with SDL_OpenGamepad().\n *\n * \\param gamepad a gamepad identifier previously returned by SDL_OpenGamepad()\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_OpenGamepad\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_CloseGamepad",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Return the sfSymbolsName for a given button on a gamepad on Apple\n * platforms.\n *\n * \\param gamepad the gamepad to query\n * \\param button a button on the gamepad\n * \\returns the sfSymbolsName or NULL if the name can't be found\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadAppleSFSymbolsNameForAxis\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadAppleSFSymbolsNameForButton",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "SDL_GamepadButton REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "button"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Return the sfSymbolsName for a given axis on a gamepad on Apple\n * platforms.\n *\n * \\param gamepad the gamepad to query\n * \\param axis an axis on the gamepad\n * \\returns the sfSymbolsName or NULL if the name can't be found\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGamepadAppleSFSymbolsNameForButton\n */\n",
        "header": "SDL_gamepad.h",
        "name": "SDL_GetGamepadAppleSFSymbolsNameForAxis",
        "parameter": [
            "SDL_Gamepad *REWRITE_NAME",
            "SDL_GamepadAxis REWRITE_NAME"
        ],
        "parameter_name": [
            "gamepad",
            "axis"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the number of 2D rendering drivers available for the current display.\n *\n * A render driver is a set of code that handles rendering and texture\n * management on a particular display. Normally there is only one, but some\n * drivers may have several available with different capabilities.\n *\n * There may be none if SDL was compiled without render support.\n *\n * \\returns a number >= 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateRenderer\n * \\sa SDL_GetRenderDriver\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetNumRenderDrivers",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Use this function to get the name of a built in 2D rendering driver.\n *\n * The list of rendering drivers is given in the order that they are normally\n * initialized by default; the drivers that seem more reasonable to choose\n * first (as far as the SDL developers believe) are earlier in the list.\n *\n * The names of drivers are all simple, low-ASCII identifiers, like \"opengl\",\n * \"direct3d12\" or \"metal\". These never have Unicode characters, and are not\n * meant to be proper names.\n *\n * The returned value points to a static, read-only string; do not modify or\n * free it!\n *\n * \\param index the index of the rendering driver; the value ranges from 0 to\n *              SDL_GetNumRenderDrivers() - 1\n * \\returns the name of the rendering driver at the requested index, or NULL\n *          if an invalid index was specified.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetNumRenderDrivers\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetRenderDriver",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "index"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Create a window and default renderer.\n *\n * \\param width the width of the window\n * \\param height the height of the window\n * \\param window_flags the flags used to create the window (see\n *                     SDL_CreateWindow())\n * \\param window a pointer filled with the window, or NULL on error\n * \\param renderer a pointer filled with the renderer, or NULL on error\n * \\returns 0 on success, or -1 on error; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateRenderer\n * \\sa SDL_CreateWindow\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_CreateWindowAndRenderer",
        "parameter": [
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "Uint32 REWRITE_NAME",
            "SDL_Window **REWRITE_NAME",
            "SDL_Renderer **REWRITE_NAME"
        ],
        "parameter_name": [
            "width",
            "height",
            "window_flags",
            "window",
            "renderer"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Create a 2D rendering context for a window.\n *\n * If you want a specific renderer, you can specify its name here. A list\n * of available renderers can be obtained by calling SDL_GetRenderDriver\n * multiple times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If\n * you don't need a specific renderer, specify NULL and SDL will attempt\n * to chooes the best option for you, based on what is available on the\n * user's system.\n *\n * \\param window the window where rendering is displayed\n * \\param name the name of the rendering driver to initialize, or NULL to\n *             initialize the first one supporting the requested flags\n * \\param flags 0, or one or more SDL_RendererFlags OR'd together\n * \\returns a valid rendering context or NULL if there was an error; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateSoftwareRenderer\n * \\sa SDL_DestroyRenderer\n * \\sa SDL_GetNumRenderDrivers\n * \\sa SDL_GetRenderDriver\n * \\sa SDL_GetRendererInfo\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_CreateRenderer",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "const char *REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "name",
            "flags"
        ],
        "retval": "SDL_Renderer*"
    },
    {
        "comment": "/**\n * Create a 2D software rendering context for a surface.\n *\n * Two other API which can be used to create SDL_Renderer:\n * SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_\n * create a software renderer, but they are intended to be used with an\n * SDL_Window as the final destination and not an SDL_Surface.\n *\n * \\param surface the SDL_Surface structure representing the surface where\n *                rendering is done\n * \\returns a valid rendering context or NULL if there was an error; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateRenderer\n * \\sa SDL_CreateWindowRenderer\n * \\sa SDL_DestroyRenderer\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_CreateSoftwareRenderer",
        "parameter": [
            "SDL_Surface *REWRITE_NAME"
        ],
        "parameter_name": [
            "surface"
        ],
        "retval": "SDL_Renderer*"
    },
    {
        "comment": "/**\n * Get the renderer associated with a window.\n *\n * \\param window the window to query\n * \\returns the rendering context on success or NULL on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateRenderer\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetRenderer",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "SDL_Renderer*"
    },
    {
        "comment": "/**\n * Get the window associated with a renderer.\n *\n * \\param renderer the renderer to query\n * \\returns the window on success or NULL on failure; call SDL_GetError() for\n *          more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetRenderWindow",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer"
        ],
        "retval": "SDL_Window*"
    },
    {
        "comment": "/**\n * Get information about a rendering context.\n *\n * \\param renderer the rendering context\n * \\param info an SDL_RendererInfo structure filled with information about the\n *             current renderer\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateRenderer\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetRendererInfo",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "SDL_RendererInfo *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "info"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the output size in pixels of a rendering context.\n *\n * Due to high-dpi displays, you might end up with a rendering context that\n * has more pixels than the window that contains it, so use this instead of\n * SDL_GetWindowSize() to decide how much drawing area you have.\n *\n * \\param renderer the rendering context\n * \\param w an int filled with the width\n * \\param h an int filled with the height\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRenderer\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetRendererOutputSize",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "w",
            "h"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Create a texture for a rendering context.\n *\n * You can set the texture scaling method by setting\n * `SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture.\n *\n * \\param renderer the rendering context\n * \\param format one of the enumerated values in SDL_PixelFormatEnum\n * \\param access one of the enumerated values in SDL_TextureAccess\n * \\param w the width of the texture in pixels\n * \\param h the height of the texture in pixels\n * \\returns a pointer to the created texture or NULL if no rendering context\n *          was active, the format was unsupported, or the width or height\n *          were out of range; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateTextureFromSurface\n * \\sa SDL_DestroyTexture\n * \\sa SDL_QueryTexture\n * \\sa SDL_UpdateTexture\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_CreateTexture",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "Uint32 REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "format",
            "access",
            "w",
            "h"
        ],
        "retval": "SDL_Texture*"
    },
    {
        "comment": "/**\n * Create a texture from an existing surface.\n *\n * The surface is not modified or freed by this function.\n *\n * The SDL_TextureAccess hint for the created texture is\n * `SDL_TEXTUREACCESS_STATIC`.\n *\n * The pixel format of the created texture may be different from the pixel\n * format of the surface. Use SDL_QueryTexture() to query the pixel format of\n * the texture.\n *\n * \\param renderer the rendering context\n * \\param surface the SDL_Surface structure containing pixel data used to fill\n *                the texture\n * \\returns the created texture or NULL on failure; call SDL_GetError() for\n *          more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateTexture\n * \\sa SDL_DestroyTexture\n * \\sa SDL_QueryTexture\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_CreateTextureFromSurface",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "SDL_Surface *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "surface"
        ],
        "retval": "SDL_Texture*"
    },
    {
        "comment": "/**\n * Query the attributes of a texture.\n *\n * \\param texture the texture to query\n * \\param format a pointer filled in with the raw format of the texture; the\n *               actual format may differ, but pixel transfers will use this\n *               format (one of the SDL_PixelFormatEnum values). This argument\n *               can be NULL if you don't need this information.\n * \\param access a pointer filled in with the actual access to the texture\n *               (one of the SDL_TextureAccess values). This argument can be\n *               NULL if you don't need this information.\n * \\param w a pointer filled in with the width of the texture in pixels. This\n *          argument can be NULL if you don't need this information.\n * \\param h a pointer filled in with the height of the texture in pixels. This\n *          argument can be NULL if you don't need this information.\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateTexture\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_QueryTexture",
        "parameter": [
            "SDL_Texture *REWRITE_NAME",
            "Uint32 *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "texture",
            "format",
            "access",
            "w",
            "h"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set an additional color value multiplied into render copy operations.\n *\n * When this texture is rendered, during the copy operation each source color\n * channel is modulated by the appropriate color value according to the\n * following formula:\n *\n * `srcC = srcC * (color / 255)`\n *\n * Color modulation is not always supported by the renderer; it will return -1\n * if color modulation is not supported.\n *\n * \\param texture the texture to update\n * \\param r the red color value multiplied into copy operations\n * \\param g the green color value multiplied into copy operations\n * \\param b the blue color value multiplied into copy operations\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetTextureColorMod\n * \\sa SDL_SetTextureAlphaMod\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_SetTextureColorMod",
        "parameter": [
            "SDL_Texture *REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "Uint8 REWRITE_NAME"
        ],
        "parameter_name": [
            "texture",
            "r",
            "g",
            "b"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the additional color value multiplied into render copy operations.\n *\n * \\param texture the texture to query\n * \\param r a pointer filled in with the current red color value\n * \\param g a pointer filled in with the current green color value\n * \\param b a pointer filled in with the current blue color value\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetTextureAlphaMod\n * \\sa SDL_SetTextureColorMod\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetTextureColorMod",
        "parameter": [
            "SDL_Texture *REWRITE_NAME",
            "Uint8 *REWRITE_NAME",
            "Uint8 *REWRITE_NAME",
            "Uint8 *REWRITE_NAME"
        ],
        "parameter_name": [
            "texture",
            "r",
            "g",
            "b"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set an additional alpha value multiplied into render copy operations.\n *\n * When this texture is rendered, during the copy operation the source alpha\n * value is modulated by this alpha value according to the following formula:\n *\n * `srcA = srcA * (alpha / 255)`\n *\n * Alpha modulation is not always supported by the renderer; it will return -1\n * if alpha modulation is not supported.\n *\n * \\param texture the texture to update\n * \\param alpha the source alpha value multiplied into copy operations\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetTextureAlphaMod\n * \\sa SDL_SetTextureColorMod\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_SetTextureAlphaMod",
        "parameter": [
            "SDL_Texture *REWRITE_NAME",
            "Uint8 REWRITE_NAME"
        ],
        "parameter_name": [
            "texture",
            "alpha"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the additional alpha value multiplied into render copy operations.\n *\n * \\param texture the texture to query\n * \\param alpha a pointer filled in with the current alpha value\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetTextureColorMod\n * \\sa SDL_SetTextureAlphaMod\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetTextureAlphaMod",
        "parameter": [
            "SDL_Texture *REWRITE_NAME",
            "Uint8 *REWRITE_NAME"
        ],
        "parameter_name": [
            "texture",
            "alpha"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set the blend mode for a texture, used by SDL_RenderTexture().\n *\n * If the blend mode is not supported, the closest supported mode is chosen\n * and this function returns -1.\n *\n * \\param texture the texture to update\n * \\param blendMode the SDL_BlendMode to use for texture blending\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetTextureBlendMode\n * \\sa SDL_RenderTexture\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_SetTextureBlendMode",
        "parameter": [
            "SDL_Texture *REWRITE_NAME",
            "SDL_BlendMode REWRITE_NAME"
        ],
        "parameter_name": [
            "texture",
            "blendMode"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the blend mode used for texture copy operations.\n *\n * \\param texture the texture to query\n * \\param blendMode a pointer filled in with the current SDL_BlendMode\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetTextureBlendMode\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetTextureBlendMode",
        "parameter": [
            "SDL_Texture *REWRITE_NAME",
            "SDL_BlendMode *REWRITE_NAME"
        ],
        "parameter_name": [
            "texture",
            "blendMode"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set the scale mode used for texture scale operations.\n *\n * If the scale mode is not supported, the closest supported mode is chosen.\n *\n * \\param texture The texture to update.\n * \\param scaleMode the SDL_ScaleMode to use for texture scaling.\n * \\returns 0 on success, or -1 if the texture is not valid.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetTextureScaleMode\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_SetTextureScaleMode",
        "parameter": [
            "SDL_Texture *REWRITE_NAME",
            "SDL_ScaleMode REWRITE_NAME"
        ],
        "parameter_name": [
            "texture",
            "scaleMode"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the scale mode used for texture scale operations.\n *\n * \\param texture the texture to query.\n * \\param scaleMode a pointer filled in with the current scale mode.\n * \\return 0 on success, or -1 if the texture is not valid.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetTextureScaleMode\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetTextureScaleMode",
        "parameter": [
            "SDL_Texture *REWRITE_NAME",
            "SDL_ScaleMode *REWRITE_NAME"
        ],
        "parameter_name": [
            "texture",
            "scaleMode"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Associate a user-specified pointer with a texture.\n *\n * \\param texture the texture to update.\n * \\param userdata the pointer to associate with the texture.\n * \\returns 0 on success, or -1 if the texture is not valid.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetTextureUserData\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_SetTextureUserData",
        "parameter": [
            "SDL_Texture *REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "texture",
            "userdata"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the user-specified pointer associated with a texture\n *\n * \\param texture the texture to query.\n * \\return the pointer associated with the texture, or NULL if the texture is\n *         not valid.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetTextureUserData\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetTextureUserData",
        "parameter": [
            "SDL_Texture *REWRITE_NAME"
        ],
        "parameter_name": [
            "texture"
        ],
        "retval": "void*"
    },
    {
        "comment": "/**\n * Update the given texture rectangle with new pixel data.\n *\n * The pixel data must be in the pixel format of the texture. Use\n * SDL_QueryTexture() to query the pixel format of the texture.\n *\n * This is a fairly slow function, intended for use with static textures that\n * do not change often.\n *\n * If the texture is intended to be updated often, it is preferred to create\n * the texture as streaming and use the locking functions referenced below.\n * While this function will work with streaming textures, for optimization\n * reasons you may not get the pixels back if you lock the texture afterward.\n *\n * \\param texture the texture to update\n * \\param rect an SDL_Rect structure representing the area to update, or NULL\n *             to update the entire texture\n * \\param pixels the raw pixel data in the format of the texture\n * \\param pitch the number of bytes in a row of pixel data, including padding\n *              between lines\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateTexture\n * \\sa SDL_LockTexture\n * \\sa SDL_UnlockTexture\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_UpdateTexture",
        "parameter": [
            "SDL_Texture *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "const void *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "texture",
            "rect",
            "pixels",
            "pitch"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Update a rectangle within a planar YV12 or IYUV texture with new pixel\n * data.\n *\n * You can use SDL_UpdateTexture() as long as your pixel data is a contiguous\n * block of Y and U/V planes in the proper order, but this function is\n * available if your pixel data is not contiguous.\n *\n * \\param texture the texture to update\n * \\param rect a pointer to the rectangle of pixels to update, or NULL to\n *             update the entire texture\n * \\param Yplane the raw pixel data for the Y plane\n * \\param Ypitch the number of bytes between rows of pixel data for the Y\n *               plane\n * \\param Uplane the raw pixel data for the U plane\n * \\param Upitch the number of bytes between rows of pixel data for the U\n *               plane\n * \\param Vplane the raw pixel data for the V plane\n * \\param Vpitch the number of bytes between rows of pixel data for the V\n *               plane\n * \\returns 0 on success or -1 if the texture is not valid; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_UpdateTexture\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_UpdateYUVTexture",
        "parameter": [
            "SDL_Texture *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "const Uint8 *REWRITE_NAME",
            "int REWRITE_NAME",
            "const Uint8 *REWRITE_NAME",
            "int REWRITE_NAME",
            "const Uint8 *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "texture",
            "rect",
            "Yplane",
            "Ypitch",
            "Uplane",
            "Upitch",
            "Vplane",
            "Vpitch"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Update a rectangle within a planar NV12 or NV21 texture with new pixels.\n *\n * You can use SDL_UpdateTexture() as long as your pixel data is a contiguous\n * block of NV12/21 planes in the proper order, but this function is available\n * if your pixel data is not contiguous.\n *\n * \\param texture the texture to update\n * \\param rect a pointer to the rectangle of pixels to update, or NULL to\n *             update the entire texture.\n * \\param Yplane the raw pixel data for the Y plane.\n * \\param Ypitch the number of bytes between rows of pixel data for the Y\n *               plane.\n * \\param UVplane the raw pixel data for the UV plane.\n * \\param UVpitch the number of bytes between rows of pixel data for the UV\n *                plane.\n * \\return 0 on success, or -1 if the texture is not valid.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_UpdateNVTexture",
        "parameter": [
            "SDL_Texture *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "const Uint8 *REWRITE_NAME",
            "int REWRITE_NAME",
            "const Uint8 *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "texture",
            "rect",
            "Yplane",
            "Ypitch",
            "UVplane",
            "UVpitch"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Lock a portion of the texture for **write-only** pixel access.\n *\n * As an optimization, the pixels made available for editing don't necessarily\n * contain the old texture data. This is a write-only operation, and if you\n * need to keep a copy of the texture data you should do that at the\n * application level.\n *\n * You must use SDL_UnlockTexture() to unlock the pixels and apply any\n * changes.\n *\n * \\param texture the texture to lock for access, which was created with\n *                `SDL_TEXTUREACCESS_STREAMING`\n * \\param rect an SDL_Rect structure representing the area to lock for access;\n *             NULL to lock the entire texture\n * \\param pixels this is filled in with a pointer to the locked pixels,\n *               appropriately offset by the locked area\n * \\param pitch this is filled in with the pitch of the locked pixels; the\n *              pitch is the length of one row in bytes\n * \\returns 0 on success or a negative error code if the texture is not valid\n *          or was not created with `SDL_TEXTUREACCESS_STREAMING`; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_UnlockTexture\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_LockTexture",
        "parameter": [
            "SDL_Texture *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "void **REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "texture",
            "rect",
            "pixels",
            "pitch"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Lock a portion of the texture for **write-only** pixel access, and expose\n * it as a SDL surface.\n *\n * Besides providing an SDL_Surface instead of raw pixel data, this function\n * operates like SDL_LockTexture.\n *\n * As an optimization, the pixels made available for editing don't necessarily\n * contain the old texture data. This is a write-only operation, and if you\n * need to keep a copy of the texture data you should do that at the\n * application level.\n *\n * You must use SDL_UnlockTexture() to unlock the pixels and apply any\n * changes.\n *\n * The returned surface is freed internally after calling SDL_UnlockTexture()\n * or SDL_DestroyTexture(). The caller should not free it.\n *\n * \\param texture the texture to lock for access, which was created with\n *                `SDL_TEXTUREACCESS_STREAMING`\n * \\param rect a pointer to the rectangle to lock for access. If the rect is\n *             NULL, the entire texture will be locked\n * \\param surface this is filled in with an SDL surface representing the\n *                locked area\n * \\returns 0 on success, or -1 if the texture is not valid or was not created\n *          with `SDL_TEXTUREACCESS_STREAMING`\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_LockTexture\n * \\sa SDL_UnlockTexture\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_LockTextureToSurface",
        "parameter": [
            "SDL_Texture *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "SDL_Surface **REWRITE_NAME"
        ],
        "parameter_name": [
            "texture",
            "rect",
            "surface"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Unlock a texture, uploading the changes to video memory, if needed.\n *\n * **Warning**: Please note that SDL_LockTexture() is intended to be\n * write-only; it will not guarantee the previous contents of the texture will\n * be provided. You must fully initialize any area of a texture that you lock\n * before unlocking it, as the pixels might otherwise be uninitialized memory.\n *\n * Which is to say: locking and immediately unlocking a texture can result in\n * corrupted textures, depending on the renderer in use.\n *\n * \\param texture a texture locked by SDL_LockTexture()\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_LockTexture\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_UnlockTexture",
        "parameter": [
            "SDL_Texture *REWRITE_NAME"
        ],
        "parameter_name": [
            "texture"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Determine whether a renderer supports the use of render targets.\n *\n * \\param renderer the renderer that will be checked\n * \\returns SDL_TRUE if supported or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetRenderTarget\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderTargetSupported",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Set a texture as the current rendering target.\n *\n * Before using this function, you should check the\n * `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if\n * render targets are supported.\n *\n * The default render target is the window for which the renderer was created.\n * To stop rendering to a texture and render to the window again, call this\n * function with a NULL `texture`.\n *\n * \\param renderer the rendering context\n * \\param texture the targeted texture, which must be created with the\n *                `SDL_TEXTUREACCESS_TARGET` flag, or NULL to render to the\n *                window instead of a texture.\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRenderTarget\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_SetRenderTarget",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "SDL_Texture *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "texture"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the current render target.\n *\n * The default render target is the window for which the renderer was created,\n * and is reported a NULL here.\n *\n * \\param renderer the rendering context\n * \\returns the current render target or NULL for the default render target.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetRenderTarget\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetRenderTarget",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer"
        ],
        "retval": "SDL_Texture*"
    },
    {
        "comment": "/**\n * Set a device independent resolution for rendering.\n *\n * This function uses the viewport and scaling functionality to allow a fixed\n * logical resolution for rendering, regardless of the actual output\n * resolution. If the actual output resolution doesn't have the same aspect\n * ratio the output rendering will be centered within the output display.\n *\n * If the output display is a window, mouse and touch events in the window\n * will be filtered and scaled so they seem to arrive within the logical\n * resolution. The SDL_HINT_MOUSE_RELATIVE_SCALING hint controls whether\n * relative motion events are also scaled.\n *\n * If this function results in scaling or subpixel drawing by the rendering\n * backend, it will be handled using the appropriate quality hints.\n *\n * \\param renderer the renderer for which resolution should be set\n * \\param w the width of the logical resolution\n * \\param h the height of the logical resolution\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRenderLogicalSize\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_SetRenderLogicalSize",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "w",
            "h"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get device independent resolution for rendering.\n *\n * When using the main rendering target (eg no target texture is set): this\n * may return 0 for `w` and `h` if the SDL_Renderer has never had its logical\n * size set by SDL_SetRenderLogicalSize(). Otherwise it returns the logical\n * width and height.\n *\n * When using a target texture: Never return 0 for `w` and `h` at first. Then\n * it returns the logical width and height that are set.\n *\n * \\param renderer a rendering context\n * \\param w an int to be filled with the width\n * \\param h an int to be filled with the height\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetRenderLogicalSize\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetRenderLogicalSize",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "w",
            "h"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set whether to force integer scales for resolution-independent rendering.\n *\n * This function restricts the logical viewport to integer values - that is,\n * when a resolution is between two multiples of a logical size, the viewport\n * size is rounded down to the lower multiple.\n *\n * \\param renderer the renderer for which integer scaling should be set\n * \\param enable enable or disable the integer scaling for rendering\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRenderIntegerScale\n * \\sa SDL_SetRenderLogicalSize\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_SetRenderIntegerScale",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "SDL_bool REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "enable"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get whether integer scales are forced for resolution-independent rendering.\n *\n * \\param renderer the renderer from which integer scaling should be queried\n * \\returns SDL_TRUE if integer scales are forced or SDL_FALSE if not and on\n *          failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetRenderIntegerScale\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetRenderIntegerScale",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Set the drawing area for rendering on the current target.\n *\n * When the window is resized, the viewport is reset to fill the entire new\n * window size.\n *\n * \\param renderer the rendering context\n * \\param rect the SDL_Rect structure representing the drawing area, or NULL\n *             to set the viewport to the entire target\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRenderViewport\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_SetRenderViewport",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "rect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the drawing area for the current target.\n *\n * \\param renderer the rendering context\n * \\param rect an SDL_Rect structure filled in with the current drawing area\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetRenderViewport\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetRenderViewport",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "rect"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set the clip rectangle for rendering on the specified target.\n *\n * \\param renderer the rendering context for which clip rectangle should be\n *                 set\n * \\param rect an SDL_Rect structure representing the clip area, relative to\n *             the viewport, or NULL to disable clipping\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRenderClipRect\n * \\sa SDL_RenderClipEnabled\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_SetRenderClipRect",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "rect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the clip rectangle for the current target.\n *\n * \\param renderer the rendering context from which clip rectangle should be\n *                 queried\n * \\param rect an SDL_Rect structure filled in with the current clipping area\n *             or an empty rectangle if clipping is disabled\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RenderClipEnabled\n * \\sa SDL_SetRenderClipRect\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetRenderClipRect",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "rect"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get whether clipping is enabled on the given renderer.\n *\n * \\param renderer the renderer from which clip state should be queried\n * \\returns SDL_TRUE if clipping is enabled or SDL_FALSE if not; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRenderClipRect\n * \\sa SDL_SetRenderClipRect\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderClipEnabled",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Set the drawing scale for rendering on the current target.\n *\n * The drawing coordinates are scaled by the x/y scaling factors before they\n * are used by the renderer. This allows resolution independent drawing with a\n * single coordinate system.\n *\n * If this results in scaling or subpixel drawing by the rendering backend, it\n * will be handled using the appropriate quality hints. For best results use\n * integer scaling factors.\n *\n * \\param renderer a rendering context\n * \\param scaleX the horizontal scaling factor\n * \\param scaleY the vertical scaling factor\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRenderScale\n * \\sa SDL_SetRenderLogicalSize\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_SetRenderScale",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "float REWRITE_NAME",
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "scaleX",
            "scaleY"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the drawing scale for the current target.\n *\n * \\param renderer the renderer from which drawing scale should be queried\n * \\param scaleX a pointer filled in with the horizontal scaling factor\n * \\param scaleY a pointer filled in with the vertical scaling factor\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetRenderScale\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetRenderScale",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "float *REWRITE_NAME",
            "float *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "scaleX",
            "scaleY"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get logical coordinates of point in renderer when given real coordinates of\n * point in window.\n *\n * Logical coordinates will differ from real coordinates when render is scaled\n * and logical renderer size set\n *\n * \\param renderer the renderer from which the logical coordinates should be\n *                 calculated\n * \\param windowX the real X coordinate in the window\n * \\param windowY the real Y coordinate in the window\n * \\param logicalX the pointer filled with the logical x coordinate\n * \\param logicalY the pointer filled with the logical y coordinate\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRenderScale\n * \\sa SDL_SetRenderScale\n * \\sa SDL_GetRenderLogicalSize\n * \\sa SDL_SetRenderLogicalSize\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderWindowToLogical",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "float REWRITE_NAME",
            "float REWRITE_NAME",
            "float *REWRITE_NAME",
            "float *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "windowX",
            "windowY",
            "logicalX",
            "logicalY"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get real coordinates of point in window when given logical coordinates of\n * point in renderer.\n *\n * Logical coordinates will differ from real coordinates when render is scaled\n * and logical renderer size set\n *\n * \\param renderer the renderer from which the window coordinates should be\n *                 calculated\n * \\param logicalX the logical x coordinate\n * \\param logicalY the logical y coordinate\n * \\param windowX the pointer filled with the real X coordinate in the window\n * \\param windowY the pointer filled with the real Y coordinate in the window\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRenderScale\n * \\sa SDL_SetRenderScale\n * \\sa SDL_GetRenderLogicalSize\n * \\sa SDL_SetRenderLogicalSize\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderLogicalToWindow",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "float REWRITE_NAME",
            "float REWRITE_NAME",
            "float *REWRITE_NAME",
            "float *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "logicalX",
            "logicalY",
            "windowX",
            "windowY"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set the color used for drawing operations (Rect, Line and Clear).\n *\n * Set the color for drawing or filling rectangles, lines, and points, and for\n * SDL_RenderClear().\n *\n * \\param renderer the rendering context\n * \\param r the red value used to draw on the rendering target\n * \\param g the green value used to draw on the rendering target\n * \\param b the blue value used to draw on the rendering target\n * \\param a the alpha value used to draw on the rendering target; usually\n *          `SDL_ALPHA_OPAQUE` (255). Use SDL_SetRenderDrawBlendMode to\n *          specify how the alpha channel is used\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRenderDrawColor\n * \\sa SDL_RenderClear\n * \\sa SDL_RenderLine\n * \\sa SDL_RenderLines\n * \\sa SDL_RenderPoint\n * \\sa SDL_RenderPoints\n * \\sa SDL_RenderRect\n * \\sa SDL_RenderRects\n * \\sa SDL_RenderFillRect\n * \\sa SDL_RenderFillRects\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_SetRenderDrawColor",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "Uint8 REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "r",
            "g",
            "b",
            "a"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the color used for drawing operations (Rect, Line and Clear).\n *\n * \\param renderer the rendering context\n * \\param r a pointer filled in with the red value used to draw on the\n *          rendering target\n * \\param g a pointer filled in with the green value used to draw on the\n *          rendering target\n * \\param b a pointer filled in with the blue value used to draw on the\n *          rendering target\n * \\param a a pointer filled in with the alpha value used to draw on the\n *          rendering target; usually `SDL_ALPHA_OPAQUE` (255)\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetRenderDrawColor\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetRenderDrawColor",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "Uint8 *REWRITE_NAME",
            "Uint8 *REWRITE_NAME",
            "Uint8 *REWRITE_NAME",
            "Uint8 *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "r",
            "g",
            "b",
            "a"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set the blend mode used for drawing operations (Fill and Line).\n *\n * If the blend mode is not supported, the closest supported mode is chosen.\n *\n * \\param renderer the rendering context\n * \\param blendMode the SDL_BlendMode to use for blending\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRenderDrawBlendMode\n * \\sa SDL_RenderLine\n * \\sa SDL_RenderLines\n * \\sa SDL_RenderPoint\n * \\sa SDL_RenderPoints\n * \\sa SDL_RenderRect\n * \\sa SDL_RenderRects\n * \\sa SDL_RenderFillRect\n * \\sa SDL_RenderFillRects\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_SetRenderDrawBlendMode",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "SDL_BlendMode REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "blendMode"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the blend mode used for drawing operations.\n *\n * \\param renderer the rendering context\n * \\param blendMode a pointer filled in with the current SDL_BlendMode\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetRenderDrawBlendMode\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetRenderDrawBlendMode",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "SDL_BlendMode *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "blendMode"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Clear the current rendering target with the drawing color.\n *\n * This function clears the entire rendering target, ignoring the viewport and\n * the clip rectangle.\n *\n * \\param renderer the rendering context\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetRenderDrawColor\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderClear",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Draw a point on the current rendering target at subpixel precision.\n *\n * \\param renderer The renderer which should draw a point.\n * \\param x The x coordinate of the point.\n * \\param y The y coordinate of the point.\n * \\return 0 on success, or -1 on error\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderPoint",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "float REWRITE_NAME",
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "x",
            "y"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Draw multiple points on the current rendering target at subpixel precision.\n *\n * \\param renderer The renderer which should draw multiple points.\n * \\param points The points to draw\n * \\param count The number of points to draw\n * \\return 0 on success, or -1 on error\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderPoints",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "const SDL_FPoint *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "points",
            "count"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Draw a line on the current rendering target at subpixel precision.\n *\n * \\param renderer The renderer which should draw a line.\n * \\param x1 The x coordinate of the start point.\n * \\param y1 The y coordinate of the start point.\n * \\param x2 The x coordinate of the end point.\n * \\param y2 The y coordinate of the end point.\n * \\return 0 on success, or -1 on error\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderLine",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "float REWRITE_NAME",
            "float REWRITE_NAME",
            "float REWRITE_NAME",
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "x1",
            "y1",
            "x2",
            "y2"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Draw a series of connected lines on the current rendering target at\n * subpixel precision.\n *\n * \\param renderer The renderer which should draw multiple lines.\n * \\param points The points along the lines\n * \\param count The number of points, drawing count-1 lines\n * \\return 0 on success, or -1 on error\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderLines",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "const SDL_FPoint *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "points",
            "count"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Draw a rectangle on the current rendering target at subpixel precision.\n *\n * \\param renderer The renderer which should draw a rectangle.\n * \\param rect A pointer to the destination rectangle, or NULL to outline the\n *             entire rendering target.\n * \\return 0 on success, or -1 on error\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderRect",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "const SDL_FRect *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "rect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Draw some number of rectangles on the current rendering target at subpixel\n * precision.\n *\n * \\param renderer The renderer which should draw multiple rectangles.\n * \\param rects A pointer to an array of destination rectangles.\n * \\param count The number of rectangles.\n * \\return 0 on success, or -1 on error\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderRects",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "const SDL_FRect *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "rects",
            "count"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Fill a rectangle on the current rendering target with the drawing color at\n * subpixel precision.\n *\n * \\param renderer The renderer which should fill a rectangle.\n * \\param rect A pointer to the destination rectangle, or NULL for the entire\n *             rendering target.\n * \\return 0 on success, or -1 on error\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderFillRect",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "const SDL_FRect *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "rect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Fill some number of rectangles on the current rendering target with the\n * drawing color at subpixel precision.\n *\n * \\param renderer The renderer which should fill multiple rectangles.\n * \\param rects A pointer to an array of destination rectangles.\n * \\param count The number of rectangles.\n * \\return 0 on success, or -1 on error\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderFillRects",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "const SDL_FRect *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "rects",
            "count"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Copy a portion of the texture to the current rendering target at subpixel\n * precision.\n *\n * \\param renderer The renderer which should copy parts of a texture.\n * \\param texture The source texture.\n * \\param srcrect A pointer to the source rectangle, or NULL for the entire\n *                texture.\n * \\param dstrect A pointer to the destination rectangle, or NULL for the\n *                entire rendering target.\n * \\return 0 on success, or -1 on error\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderTexture",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "SDL_Texture *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "const SDL_FRect *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "texture",
            "srcrect",
            "dstrect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Copy a portion of the source texture to the current rendering target, with\n * rotation and flipping, at subpixel precision.\n *\n * \\param renderer The renderer which should copy parts of a texture.\n * \\param texture The source texture.\n * \\param srcrect A pointer to the source rectangle, or NULL for the entire\n *                texture.\n * \\param dstrect A pointer to the destination rectangle, or NULL for the\n *                entire rendering target.\n * \\param angle An angle in degrees that indicates the rotation that will be\n *              applied to dstrect, rotating it in a clockwise direction\n * \\param center A pointer to a point indicating the point around which\n *               dstrect will be rotated (if NULL, rotation will be done\n *               around dstrect.w/2, dstrect.h/2).\n * \\param flip An SDL_RendererFlip value stating which flipping actions should\n *             be performed on the texture\n * \\return 0 on success, or -1 on error\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderTextureRotated",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "SDL_Texture *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "const SDL_FRect *REWRITE_NAME",
            "const double REWRITE_NAME",
            "const SDL_FPoint *REWRITE_NAME",
            "const SDL_RendererFlip REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "texture",
            "srcrect",
            "dstrect",
            "angle",
            "center",
            "flip"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Render a list of triangles, optionally using a texture and indices into the\n * vertex array Color and alpha modulation is done per vertex\n * (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).\n *\n * \\param renderer The rendering context.\n * \\param texture (optional) The SDL texture to use.\n * \\param vertices Vertices.\n * \\param num_vertices Number of vertices.\n * \\param indices (optional) An array of integer indices into the 'vertices'\n *                array, if NULL all vertices will be rendered in sequential\n *                order.\n * \\param num_indices Number of indices.\n * \\return 0 on success, or -1 if the operation is not supported\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RenderGeometryRaw\n * \\sa SDL_Vertex\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderGeometry",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "SDL_Texture *REWRITE_NAME",
            "const SDL_Vertex *REWRITE_NAME",
            "int REWRITE_NAME",
            "const int *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "texture",
            "vertices",
            "num_vertices",
            "indices",
            "num_indices"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Render a list of triangles, optionally using a texture and indices into the\n * vertex arrays Color and alpha modulation is done per vertex\n * (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).\n *\n * \\param renderer The rendering context.\n * \\param texture (optional) The SDL texture to use.\n * \\param xy Vertex positions\n * \\param xy_stride Byte size to move from one element to the next element\n * \\param color Vertex colors (as SDL_Color)\n * \\param color_stride Byte size to move from one element to the next element\n * \\param uv Vertex normalized texture coordinates\n * \\param uv_stride Byte size to move from one element to the next element\n * \\param num_vertices Number of vertices.\n * \\param indices (optional) An array of indices into the 'vertices' arrays,\n *                if NULL all vertices will be rendered in sequential order.\n * \\param num_indices Number of indices.\n * \\param size_indices Index size: 1 (byte), 2 (short), 4 (int)\n * \\return 0 on success, or -1 if the operation is not supported\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RenderGeometry\n * \\sa SDL_Vertex\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderGeometryRaw",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "SDL_Texture *REWRITE_NAME",
            "const float *REWRITE_NAME",
            "int REWRITE_NAME",
            "const SDL_Color *REWRITE_NAME",
            "int REWRITE_NAME",
            "const float *REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "const void *REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "texture",
            "xy",
            "xy_stride",
            "color",
            "color_stride",
            "uv",
            "uv_stride",
            "num_vertices",
            "indices",
            "num_indices",
            "size_indices"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Read pixels from the current rendering target to an array of pixels.\n *\n * **WARNING**: This is a very slow operation, and should not be used\n * frequently. If you're using this on the main rendering target, it should be\n * called after rendering and before SDL_RenderPresent().\n *\n * `pitch` specifies the number of bytes between rows in the destination\n * `pixels` data. This allows you to write to a subrectangle or have padded\n * rows in the destination. Generally, `pitch` should equal the number of\n * pixels per row in the `pixels` data times the number of bytes per pixel,\n * but it might contain additional padding (for example, 24bit RGB Windows\n * Bitmap data pads all rows to multiples of 4 bytes).\n *\n * \\param renderer the rendering context\n * \\param rect an SDL_Rect structure representing the area to read, or NULL\n *             for the entire render target\n * \\param format an SDL_PixelFormatEnum value of the desired format of the\n *               pixel data, or 0 to use the format of the rendering target\n * \\param pixels a pointer to the pixel data to copy into\n * \\param pitch the pitch of the `pixels` parameter\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderReadPixels",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "Uint32 REWRITE_NAME",
            "void *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "rect",
            "format",
            "pixels",
            "pitch"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Update the screen with any rendering performed since the previous call.\n *\n * SDL's rendering functions operate on a backbuffer; that is, calling a\n * rendering function such as SDL_RenderLine() does not directly put a\n * line on the screen, but rather updates the backbuffer. As such, you compose\n * your entire scene and *present* the composed backbuffer to the screen as a\n * complete picture.\n *\n * Therefore, when using SDL's rendering API, one does all drawing intended\n * for the frame, and then calls this function once per frame to present the\n * final drawing to the user.\n *\n * The backbuffer should be considered invalidated after each present; do not\n * assume that previous contents will exist between frames. You are strongly\n * encouraged to call SDL_RenderClear() to initialize the backbuffer before\n * starting each new frame's drawing, even if you plan to overwrite every\n * pixel.\n *\n * \\param renderer the rendering context\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RenderClear\n * \\sa SDL_RenderLine\n * \\sa SDL_RenderLines\n * \\sa SDL_RenderPoint\n * \\sa SDL_RenderPoints\n * \\sa SDL_RenderRect\n * \\sa SDL_RenderRects\n * \\sa SDL_RenderFillRect\n * \\sa SDL_RenderFillRects\n * \\sa SDL_SetRenderDrawBlendMode\n * \\sa SDL_SetRenderDrawColor\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderPresent",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Destroy the specified texture.\n *\n * Passing NULL or an otherwise invalid texture will set the SDL error message\n * to \"Invalid texture\".\n *\n * \\param texture the texture to destroy\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateTexture\n * \\sa SDL_CreateTextureFromSurface\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_DestroyTexture",
        "parameter": [
            "SDL_Texture *REWRITE_NAME"
        ],
        "parameter_name": [
            "texture"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Destroy the rendering context for a window and free associated textures.\n *\n * If `renderer` is NULL, this function will return immediately after setting\n * the SDL error message to \"Invalid renderer\". See SDL_GetError().\n *\n * \\param renderer the rendering context\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateRenderer\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_DestroyRenderer",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Force the rendering context to flush any pending commands to the underlying\n * rendering API.\n *\n * You do not need to (and in fact, shouldn't) call this function unless you\n * are planning to call into OpenGL/Direct3D/Metal/whatever directly in\n * addition to using an SDL_Renderer.\n *\n * This is for a very-specific case: if you are using SDL's render API, you\n * asked for a specific renderer backend (OpenGL, Direct3D, etc), you set\n * SDL_HINT_RENDER_BATCHING to \"1\", and you plan to make OpenGL/D3D/whatever\n * calls in addition to SDL render API calls. If all of this applies, you\n * should call SDL_RenderFlush() between calls to SDL's render API and the\n * low-level API you're using in cooperation.\n *\n * In all other cases, you can ignore this function. This is only here to get\n * maximum performance out of a specific situation. In all other cases, SDL\n * will do the right thing, perhaps at a performance loss.\n *\n * This function is first available in SDL 2.0.10, and is not needed in 2.0.9\n * and earlier, as earlier versions did not queue rendering commands at all,\n * instead flushing them to the OS immediately.\n *\n * \\param renderer the rendering context\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_RenderFlush",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Bind an OpenGL/ES/ES2 texture to the current context.\n *\n * This is for use with OpenGL instructions when rendering OpenGL primitives\n * directly.\n *\n * If not NULL, `texw` and `texh` will be filled with the width and height\n * values suitable for the provided texture. In most cases, both will be 1.0,\n * however, on systems that support the GL_ARB_texture_rectangle extension,\n * these values will actually be the pixel width and height used to create the\n * texture, so this factor needs to be taken into account when providing\n * texture coordinates to OpenGL.\n *\n * You need a renderer to create an SDL_Texture, therefore you can only use\n * this function with an implicit OpenGL context from SDL_CreateRenderer(),\n * not with your own OpenGL context. If you need control over your OpenGL\n * context, you need to write your own texture-loading methods.\n *\n * Also note that SDL may upload RGB textures as BGR (or vice-versa), and\n * re-order the color channels in the shaders phase, so the uploaded texture\n * may have swapped color channels.\n *\n * \\param texture the texture to bind to the current OpenGL/ES/ES2 context\n * \\param texw a pointer to a float value which will be filled with the\n *             texture width or NULL if you don't need that value\n * \\param texh a pointer to a float value which will be filled with the\n *             texture height or NULL if you don't need that value\n * \\returns 0 on success, or -1 if the operation is not supported; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GL_MakeCurrent\n * \\sa SDL_GL_UnbindTexture\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GL_BindTexture",
        "parameter": [
            "SDL_Texture *REWRITE_NAME",
            "float *REWRITE_NAME",
            "float *REWRITE_NAME"
        ],
        "parameter_name": [
            "texture",
            "texw",
            "texh"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Unbind an OpenGL/ES/ES2 texture from the current context.\n *\n * See SDL_GL_BindTexture() for examples on how to use these functions\n *\n * \\param texture the texture to unbind from the current OpenGL/ES/ES2 context\n * \\returns 0 on success, or -1 if the operation is not supported\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GL_BindTexture\n * \\sa SDL_GL_MakeCurrent\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GL_UnbindTexture",
        "parameter": [
            "SDL_Texture *REWRITE_NAME"
        ],
        "parameter_name": [
            "texture"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the CAMetalLayer associated with the given Metal renderer.\n *\n * This function returns `void *`, so SDL doesn't have to include Metal's\n * headers, but it can be safely cast to a `CAMetalLayer *`.\n *\n * \\param renderer The renderer to query\n * \\returns a `CAMetalLayer *` on success, or NULL if the renderer isn't a\n *          Metal renderer\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRenderMetalCommandEncoder\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetRenderMetalLayer",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer"
        ],
        "retval": "void*"
    },
    {
        "comment": "/**\n * Get the Metal command encoder for the current frame\n *\n * This function returns `void *`, so SDL doesn't have to include Metal's\n * headers, but it can be safely cast to an `id<MTLRenderCommandEncoder>`.\n *\n * Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give\n * SDL a drawable to render to, which might happen if the window is\n * hidden/minimized/offscreen. This doesn't apply to command encoders for\n * render targets, just the window's backbacker. Check your return values!\n *\n * \\param renderer The renderer to query\n * \\returns an `id<MTLRenderCommandEncoder>` on success, or NULL if the\n *          renderer isn't a Metal renderer or there was an error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRenderMetalLayer\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetRenderMetalCommandEncoder",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer"
        ],
        "retval": "void*"
    },
    {
        "comment": "/**\n * Toggle VSync of the given renderer.\n *\n * \\param renderer The renderer to toggle\n * \\param vsync 1 for on, 0 for off. All other values are reserved\n * \\returns a 0 int on success, or non-zero on failure\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_SetRenderVSync",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "vsync"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get VSync of the given renderer.\n *\n * \\param renderer The renderer to toggle\n * \\param vsync an int filled with 1 for on, 0 for off. All other values are reserved\n * \\returns a 0 int on success, or non-zero on failure\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_render.h",
        "name": "SDL_GetRenderVSync",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer",
            "vsync"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the number of milliseconds since SDL library initialization.\n *\n * \\returns an unsigned 64-bit value representing the number of milliseconds\n *          since the SDL library initialized.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_timer.h",
        "name": "SDL_GetTicks",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "Uint64"
    },
    {
        "comment": "/**\n * Get the number of nanoseconds since SDL library initialization.\n *\n * \\returns an unsigned 64-bit value representing the number of nanoseconds\n *          since the SDL library initialized.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_timer.h",
        "name": "SDL_GetTicksNS",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "Uint64"
    },
    {
        "comment": "/**\n * Get the current value of the high resolution counter.\n *\n * This function is typically used for profiling.\n *\n * The counter values are only meaningful relative to each other. Differences\n * between values can be converted to times by using\n * SDL_GetPerformanceFrequency().\n *\n * \\returns the current counter value.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetPerformanceFrequency\n */\n",
        "header": "SDL_timer.h",
        "name": "SDL_GetPerformanceCounter",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "Uint64"
    },
    {
        "comment": "/**\n * Get the count per second of the high resolution counter.\n *\n * \\returns a platform-specific count per second.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetPerformanceCounter\n */\n",
        "header": "SDL_timer.h",
        "name": "SDL_GetPerformanceFrequency",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "Uint64"
    },
    {
        "comment": "/**\n * Wait a specified number of milliseconds before returning.\n *\n * This function waits a specified number of milliseconds before returning. It\n * waits at least the specified time, but possibly longer due to OS\n * scheduling.\n *\n * \\param ms the number of milliseconds to delay\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_timer.h",
        "name": "SDL_Delay",
        "parameter": [
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "ms"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Wait a specified number of nanoseconds before returning.\n *\n * This function waits a specified number of nanoseconds before returning. It\n * waits at least the specified time, but possibly longer due to OS\n * scheduling.\n *\n * \\param ns the number of nanoseconds to delay\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_timer.h",
        "name": "SDL_DelayNS",
        "parameter": [
            "Uint64 REWRITE_NAME"
        ],
        "parameter_name": [
            "ns"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Call a callback function at a future time.\n *\n * If you use this function, you must pass `SDL_INIT_TIMER` to SDL_Init().\n *\n * The callback function is passed the current timer interval and the user\n * supplied parameter from the SDL_AddTimer() call and should return the next\n * timer interval. If the value returned from the callback is 0, the timer is\n * canceled.\n *\n * The callback is run on a separate thread.\n *\n * Timers take into account the amount of time it took to execute the\n * callback. For example, if the callback took 250 ms to execute and returned\n * 1000 (ms), the timer would only wait another 750 ms before its next\n * iteration.\n *\n * Timing may be inexact due to OS scheduling. Be sure to note the current\n * time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your\n * callback needs to adjust for variances.\n *\n * \\param interval the timer delay, in milliseconds, passed to `callback`\n * \\param callback the SDL_TimerCallback function to call when the specified\n *                 `interval` elapses\n * \\param param a pointer that is passed to `callback`\n * \\returns a timer ID or 0 if an error occurs; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RemoveTimer\n */\n",
        "header": "SDL_timer.h",
        "name": "SDL_AddTimer",
        "parameter": [
            "Uint32 REWRITE_NAME",
            "SDL_TimerCallback REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "interval",
            "callback",
            "param"
        ],
        "retval": "SDL_TimerID"
    },
    {
        "comment": "/**\n * Remove a timer created with SDL_AddTimer().\n *\n * \\param id the ID of the timer to remove\n * \\returns SDL_TRUE if the timer is removed or SDL_FALSE if the timer wasn't\n *          found.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AddTimer\n */\n",
        "header": "SDL_timer.h",
        "name": "SDL_RemoveTimer",
        "parameter": [
            "SDL_TimerID REWRITE_NAME"
        ],
        "parameter_name": [
            "id"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n *  \\file SDL_thread.h\n *\n *  We compile SDL into a DLL. This means, that it's the DLL which\n *  creates a new thread for the calling process with the SDL_CreateThread()\n *  API. There is a problem with this, that only the RTL of the SDL3.DLL will\n *  be initialized for those threads, and not the RTL of the calling\n *  application!\n *\n *  To solve this, we make a little hack here.\n *\n *  We'll always use the caller's _beginthread() and _endthread() APIs to\n *  start a new thread. This way, if it's the SDL3.DLL which uses this API,\n *  then the RTL of SDL3.DLL will be used to create the new thread, and if it's\n *  the application, then the RTL of the application will be used.\n *\n *  So, in short:\n *  Always use the _beginthread() and _endthread() of the calling runtime\n *  library!\n */\n",
        "header": "SDL_thread.h",
        "name": "SDL_CreateThread",
        "parameter": [
            "SDL_ThreadFunction REWRITE_NAME",
            "const char *REWRITE_NAME",
            "void *REWRITE_NAME",
            "pfnSDL_CurrentBeginThread REWRITE_NAME",
            "pfnSDL_CurrentEndThread REWRITE_NAME"
        ],
        "parameter_name": [
            "fn",
            "name",
            "data",
            "pfnBeginThread",
            "pfnEndThread"
        ],
        "retval": "SDL_Thread*"
    },
    {
        "comment": "",
        "header": "SDL_thread.h",
        "name": "SDL_CreateThreadWithStackSize",
        "parameter": [
            "SDL_ThreadFunction REWRITE_NAME",
            "const char *REWRITE_NAME",
            "const size_t REWRITE_NAME",
            "void *REWRITE_NAME",
            "pfnSDL_CurrentBeginThread REWRITE_NAME",
            "pfnSDL_CurrentEndThread REWRITE_NAME"
        ],
        "parameter_name": [
            "fn",
            "name",
            "stacksize",
            "data",
            "pfnBeginThread",
            "pfnEndThread"
        ],
        "retval": "SDL_Thread*"
    },
    {
        "comment": "/**\n * Create a new thread with a default stack size.\n *\n * This is equivalent to calling:\n *\n * ```c\n * SDL_CreateThreadWithStackSize(fn, name, 0, data);\n * ```\n *\n * \\param fn the SDL_ThreadFunction function to call in the new thread\n * \\param name the name of the thread\n * \\param data a pointer that is passed to `fn`\n * \\returns an opaque pointer to the new thread object on success, NULL if the\n *          new thread could not be created; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateThreadWithStackSize\n * \\sa SDL_WaitThread\n */\n",
        "header": "SDL_thread.h",
        "name": "SDL_CreateThread",
        "parameter": [
            "SDL_ThreadFunction REWRITE_NAME",
            "const char *REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "fn",
            "name",
            "data"
        ],
        "retval": "SDL_Thread*"
    },
    {
        "comment": "/**\n * Create a new thread with a specific stack size.\n *\n * SDL makes an attempt to report `name` to the system, so that debuggers can\n * display it. Not all platforms support this.\n *\n * Thread naming is a little complicated: Most systems have very small limits\n * for the string length (Haiku has 32 bytes, Linux currently has 16, Visual\n * C++ 6.0 has _nine_!), and possibly other arbitrary rules. You'll have to\n * see what happens with your system's debugger. The name should be UTF-8 (but\n * using the naming limits of C identifiers is a better bet). There are no\n * requirements for thread naming conventions, so long as the string is\n * null-terminated UTF-8, but these guidelines are helpful in choosing a name:\n *\n * https://stackoverflow.com/questions/149932/naming-conventions-for-threads\n *\n * If a system imposes requirements, SDL will try to munge the string for it\n * (truncate, etc), but the original string contents will be available from\n * SDL_GetThreadName().\n *\n * The size (in bytes) of the new stack can be specified. Zero means \"use the\n * system default\" which might be wildly different between platforms. x86\n * Linux generally defaults to eight megabytes, an embedded device might be a\n * few kilobytes instead. You generally need to specify a stack that is a\n * multiple of the system's page size (in many cases, this is 4 kilobytes, but\n * check your system documentation).\n *\n * In SDL 2.1, stack size will be folded into the original SDL_CreateThread\n * function, but for backwards compatibility, this is currently a separate\n * function.\n *\n * \\param fn the SDL_ThreadFunction function to call in the new thread\n * \\param name the name of the thread\n * \\param stacksize the size, in bytes, to allocate for the new thread stack.\n * \\param data a pointer that is passed to `fn`\n * \\returns an opaque pointer to the new thread object on success, NULL if the\n *          new thread could not be created; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_WaitThread\n */\n",
        "header": "SDL_thread.h",
        "name": "SDL_CreateThreadWithStackSize",
        "parameter": [
            "SDL_ThreadFunction REWRITE_NAME",
            "const char *REWRITE_NAME",
            "const size_t REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "fn",
            "name",
            "stacksize",
            "data"
        ],
        "retval": "SDL_Thread*"
    },
    {
        "comment": "/**\n * Get the thread name as it was specified in SDL_CreateThread().\n *\n * This is internal memory, not to be freed by the caller, and remains valid\n * until the specified thread is cleaned up by SDL_WaitThread().\n *\n * \\param thread the thread to query\n * \\returns a pointer to a UTF-8 string that names the specified thread, or\n *          NULL if it doesn't have a name.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateThread\n */\n",
        "header": "SDL_thread.h",
        "name": "SDL_GetThreadName",
        "parameter": [
            "SDL_Thread *REWRITE_NAME"
        ],
        "parameter_name": [
            "thread"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the thread identifier for the current thread.\n *\n * This thread identifier is as reported by the underlying operating system.\n * If SDL is running on a platform that does not support threads the return\n * value will always be zero.\n *\n * This function also returns a valid thread ID when called from the main\n * thread.\n *\n * \\returns the ID of the current thread.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetThreadID\n */\n",
        "header": "SDL_thread.h",
        "name": "SDL_ThreadID",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_threadID"
    },
    {
        "comment": "/**\n * Get the thread identifier for the specified thread.\n *\n * This thread identifier is as reported by the underlying operating system.\n * If SDL is running on a platform that does not support threads the return\n * value will always be zero.\n *\n * \\param thread the thread to query\n * \\returns the ID of the specified thread, or the ID of the current thread if\n *          `thread` is NULL.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ThreadID\n */\n",
        "header": "SDL_thread.h",
        "name": "SDL_GetThreadID",
        "parameter": [
            "SDL_Thread *REWRITE_NAME"
        ],
        "parameter_name": [
            "thread"
        ],
        "retval": "SDL_threadID"
    },
    {
        "comment": "/**\n * Set the priority for the current thread.\n *\n * Note that some platforms will not let you alter the priority (or at least,\n * promote the thread to a higher priority) at all, and some require you to be\n * an administrator account. Be prepared for this to fail.\n *\n * \\param priority the SDL_ThreadPriority to set\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_thread.h",
        "name": "SDL_SetThreadPriority",
        "parameter": [
            "SDL_ThreadPriority REWRITE_NAME"
        ],
        "parameter_name": [
            "priority"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Wait for a thread to finish.\n *\n * Threads that haven't been detached will remain (as a \"zombie\") until this\n * function cleans them up. Not doing so is a resource leak.\n *\n * Once a thread has been cleaned up through this function, the SDL_Thread\n * that references it becomes invalid and should not be referenced again. As\n * such, only one thread may call SDL_WaitThread() on another.\n *\n * The return code for the thread function is placed in the area pointed to by\n * `status`, if `status` is not NULL.\n *\n * You may not wait on a thread that has been used in a call to\n * SDL_DetachThread(). Use either that function or this one, but not both, or\n * behavior is undefined.\n *\n * It is safe to pass a NULL thread to this function; it is a no-op.\n *\n * Note that the thread pointer is freed by this function and is not valid\n * afterward.\n *\n * \\param thread the SDL_Thread pointer that was returned from the\n *               SDL_CreateThread() call that started this thread\n * \\param status pointer to an integer that will receive the value returned\n *               from the thread function by its 'return', or NULL to not\n *               receive such value back.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateThread\n * \\sa SDL_DetachThread\n */\n",
        "header": "SDL_thread.h",
        "name": "SDL_WaitThread",
        "parameter": [
            "SDL_Thread *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "thread",
            "status"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Let a thread clean up on exit without intervention.\n *\n * A thread may be \"detached\" to signify that it should not remain until\n * another thread has called SDL_WaitThread() on it. Detaching a thread is\n * useful for long-running threads that nothing needs to synchronize with or\n * further manage. When a detached thread is done, it simply goes away.\n *\n * There is no way to recover the return code of a detached thread. If you\n * need this, don't detach the thread and instead use SDL_WaitThread().\n *\n * Once a thread is detached, you should usually assume the SDL_Thread isn't\n * safe to reference again, as it will become invalid immediately upon the\n * detached thread's exit, instead of remaining until someone has called\n * SDL_WaitThread() to finally clean it up. As such, don't detach the same\n * thread more than once.\n *\n * If a thread has already exited when passed to SDL_DetachThread(), it will\n * stop waiting for a call to SDL_WaitThread() and clean up immediately. It is\n * not safe to detach a thread that might be used with SDL_WaitThread().\n *\n * You may not call SDL_WaitThread() on a thread that has been detached. Use\n * either that function or this one, but not both, or behavior is undefined.\n *\n * It is safe to pass NULL to this function; it is a no-op.\n *\n * \\param thread the SDL_Thread pointer that was returned from the\n *               SDL_CreateThread() call that started this thread\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateThread\n * \\sa SDL_WaitThread\n */\n",
        "header": "SDL_thread.h",
        "name": "SDL_DetachThread",
        "parameter": [
            "SDL_Thread *REWRITE_NAME"
        ],
        "parameter_name": [
            "thread"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Create a piece of thread-local storage.\n *\n * This creates an identifier that is globally visible to all threads but\n * refers to data that is thread-specific.\n *\n * \\returns the newly created thread local storage identifier or 0 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_TLSGet\n * \\sa SDL_TLSSet\n */\n",
        "header": "SDL_thread.h",
        "name": "SDL_TLSCreate",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_TLSID"
    },
    {
        "comment": "/**\n * Get the current thread's value associated with a thread local storage ID.\n *\n * \\param id the thread local storage ID\n * \\returns the value associated with the ID for the current thread or NULL if\n *          no value has been set; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_TLSCreate\n * \\sa SDL_TLSSet\n */\n",
        "header": "SDL_thread.h",
        "name": "SDL_TLSGet",
        "parameter": [
            "SDL_TLSID REWRITE_NAME"
        ],
        "parameter_name": [
            "id"
        ],
        "retval": "void*"
    },
    {
        "comment": "/**\n * Set the current thread's value associated with a thread local storage ID.\n *\n * The function prototype for `destructor` is:\n *\n * ```c\n * void destructor(void *value)\n * ```\n *\n * where its parameter `value` is what was passed as `value` to SDL_TLSSet().\n *\n * \\param id the thread local storage ID\n * \\param value the value to associate with the ID for the current thread\n * \\param destructor a function called when the thread exits, to free the\n *                   value\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_TLSCreate\n * \\sa SDL_TLSGet\n */\n",
        "header": "SDL_thread.h",
        "name": "SDL_TLSSet",
        "parameter": [
            "SDL_TLSID REWRITE_NAME",
            "const void *REWRITE_NAME",
            "void (SDLCALL *REWRITE_NAME)(void*)"
        ],
        "parameter_name": [
            "id",
            "value",
            "destructor"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Cleanup all TLS data for this thread.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_thread.h",
        "name": "SDL_TLSCleanup",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set a callback for every Windows message, run before TranslateMessage().\n *\n * \\param callback The SDL_WindowsMessageHook function to call.\n * \\param userdata a pointer to pass to every iteration of `callback`\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_SetWindowsMessageHook",
        "parameter": [
            "SDL_WindowsMessageHook REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "callback",
            "userdata"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the D3D9 adapter index that matches the specified display index.\n *\n * The returned adapter index can be passed to `IDirect3D9::CreateDevice` and\n * controls on which monitor a full screen application will appear.\n *\n * \\param displayIndex the display index for which to get the D3D9 adapter\n *                     index\n * \\returns the D3D9 adapter index on success or a negative error code on\n *          failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_Direct3D9GetAdapterIndex",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "displayIndex"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the D3D9 device associated with a renderer.\n *\n * Once you are done using the device, you should release it to avoid a\n * resource leak.\n *\n * \\param renderer the renderer from which to get the associated D3D device\n * \\returns the D3D9 device associated with given renderer or NULL if it is\n *          not a D3D9 renderer; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_GetRenderD3D9Device",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer"
        ],
        "retval": "IDirect3DDevice9*"
    },
    {
        "comment": "/**\n * Get the D3D11 device associated with a renderer.\n *\n * Once you are done using the device, you should release it to avoid a\n * resource leak.\n *\n * \\param renderer the renderer from which to get the associated D3D11 device\n * \\returns the D3D11 device associated with given renderer or NULL if it is\n *          not a D3D11 renderer; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_GetRenderD3D11Device",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer"
        ],
        "retval": "ID3D11Device*"
    },
    {
        "comment": "/**\n * Get the D3D12 device associated with a renderer.\n *\n * Once you are done using the device, you should release it to avoid a\n * resource leak.\n *\n * \\param renderer the renderer from which to get the associated D3D12 device\n * \\returns the D3D12 device associated with given renderer or NULL if it is\n *          not a D3D12 renderer; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_RenderGetD3D12Device",
        "parameter": [
            "SDL_Renderer *REWRITE_NAME"
        ],
        "parameter_name": [
            "renderer"
        ],
        "retval": "ID3D12Device*"
    },
    {
        "comment": "/**\n * Get the DXGI Adapter and Output indices for the specified display index.\n *\n * The DXGI Adapter and Output indices can be passed to `EnumAdapters` and\n * `EnumOutputs` respectively to get the objects required to create a DX10 or\n * DX11 device and swap chain.\n *\n * Before SDL 2.0.4 this function did not return a value. Since SDL 2.0.4 it\n * returns an SDL_bool.\n *\n * \\param displayIndex the display index for which to get both indices\n * \\param adapterIndex a pointer to be filled in with the adapter index\n * \\param outputIndex a pointer to be filled in with the output index\n * \\returns SDL_TRUE on success or SDL_FALSE on failure; call SDL_GetError()\n *          for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_DXGIGetOutputInfo",
        "parameter": [
            "int REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "displayIndex",
            "adapterIndex",
            "outputIndex"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Sets the UNIX nice value for a thread.\n *\n * This uses setpriority() if possible, and RealtimeKit if available.\n *\n * \\param threadID the Unix thread ID to change priority of.\n * \\param priority The new, Unix-specific, priority value.\n * \\returns 0 on success, or -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_LinuxSetThreadPriority",
        "parameter": [
            "Sint64 REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "threadID",
            "priority"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Sets the priority (not nice level) and scheduling policy for a thread.\n *\n * This uses setpriority() if possible, and RealtimeKit if available.\n *\n * \\param threadID The Unix thread ID to change priority of.\n * \\param sdlPriority The new SDL_ThreadPriority value.\n * \\param schedPolicy The new scheduling policy (SCHED_FIFO, SCHED_RR,\n *                    SCHED_OTHER, etc...)\n * \\returns 0 on success, or -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_LinuxSetThreadPriorityAndPolicy",
        "parameter": [
            "Sint64 REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "threadID",
            "sdlPriority",
            "schedPolicy"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Use this function to set the animation callback on Apple iOS.\n *\n * The function prototype for `callback` is:\n *\n * ```c\n * void callback(void* callbackParam);\n * ```\n *\n * Where its parameter, `callbackParam`, is what was passed as `callbackParam`\n * to SDL_iPhoneSetAnimationCallback().\n *\n * This function is only available on Apple iOS.\n *\n * For more information see:\n * https://github.com/libsdl-org/SDL/blob/main/docs/README-ios.md\n *\n * This functions is also accessible using the macro\n * SDL_iOSSetAnimationCallback() since SDL 2.0.4.\n *\n * \\param window the window for which the animation callback should be set\n * \\param interval the number of frames after which **callback** will be\n *                 called\n * \\param callback the function to call for every frame.\n * \\param callbackParam a pointer that is passed to `callback`.\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_iPhoneSetEventPump\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_iPhoneSetAnimationCallback",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "int REWRITE_NAME",
            "void (SDLCALL *REWRITE_NAME)(void*)",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "interval",
            "callback",
            "callbackParam"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Use this function to enable or disable the SDL event pump on Apple iOS.\n *\n * This function is only available on Apple iOS.\n *\n * This functions is also accessible using the macro SDL_iOSSetEventPump()\n * since SDL 2.0.4.\n *\n * \\param enabled SDL_TRUE to enable the event pump, SDL_FALSE to disable it\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_iPhoneSetAnimationCallback\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_iPhoneSetEventPump",
        "parameter": [
            "SDL_bool REWRITE_NAME"
        ],
        "parameter_name": [
            "enabled"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the Android Java Native Interface Environment of the current thread.\n *\n * This is the JNIEnv one needs to access the Java virtual machine from native\n * code, and is needed for many Android APIs to be usable from C.\n *\n * The prototype of the function in SDL's code actually declare a void* return\n * type, even if the implementation returns a pointer to a JNIEnv. The\n * rationale being that the SDL headers can avoid including jni.h.\n *\n * \\returns a pointer to Java native interface object (JNIEnv) to which the\n *          current thread is attached, or 0 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AndroidGetActivity\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_AndroidGetJNIEnv",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void*"
    },
    {
        "comment": "/**\n * Retrieve the Java instance of the Android activity class.\n *\n * The prototype of the function in SDL's code actually declares a void*\n * return type, even if the implementation returns a jobject. The rationale\n * being that the SDL headers can avoid including jni.h.\n *\n * The jobject returned by the function is a local reference and must be\n * released by the caller. See the PushLocalFrame() and PopLocalFrame() or\n * DeleteLocalRef() functions of the Java native interface:\n *\n * https://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html\n *\n * \\returns the jobject representing the instance of the Activity class of the\n *          Android application, or NULL on error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AndroidGetJNIEnv\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_AndroidGetActivity",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void*"
    },
    {
        "comment": "/**\n * Query Android API level of the current device.\n *\n * - API level 31: Android 12\n * - API level 30: Android 11\n * - API level 29: Android 10\n * - API level 28: Android 9\n * - API level 27: Android 8.1\n * - API level 26: Android 8.0\n * - API level 25: Android 7.1\n * - API level 24: Android 7.0\n * - API level 23: Android 6.0\n * - API level 22: Android 5.1\n * - API level 21: Android 5.0\n * - API level 20: Android 4.4W\n * - API level 19: Android 4.4\n * - API level 18: Android 4.3\n * - API level 17: Android 4.2\n * - API level 16: Android 4.1\n * - API level 15: Android 4.0.3\n * - API level 14: Android 4.0\n * - API level 13: Android 3.2\n * - API level 12: Android 3.1\n * - API level 11: Android 3.0\n * - API level 10: Android 2.3.3\n *\n * \\returns the Android API level.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_GetAndroidSDKVersion",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Query if the application is running on Android TV.\n *\n * \\returns SDL_TRUE if this is Android TV, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_IsAndroidTV",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Query if the application is running on a Chromebook.\n *\n * \\returns SDL_TRUE if this is a Chromebook, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_IsChromebook",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Query if the application is running on a Samsung DeX docking station.\n *\n * \\returns SDL_TRUE if this is a DeX docking station, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_IsDeXMode",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Trigger the Android system back button behavior.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_AndroidBackButton",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the path used for internal storage for this application.\n *\n * This path is unique to your application and cannot be written to by other\n * applications.\n *\n * Your internal storage path is typically:\n * `/data/data/your.app.package/files`.\n *\n * \\returns the path used for internal storage or NULL on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AndroidGetExternalStorageState\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_AndroidGetInternalStoragePath",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the current state of external storage.\n *\n * The current state of external storage, a bitmask of these values:\n * `SDL_ANDROID_EXTERNAL_STORAGE_READ`, `SDL_ANDROID_EXTERNAL_STORAGE_WRITE`.\n *\n * If external storage is currently unavailable, this will return 0.\n *\n * \\returns the current state of external storage on success or 0 on failure;\n *          call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AndroidGetExternalStoragePath\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_AndroidGetExternalStorageState",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the path used for external storage for this application.\n *\n * This path is unique to your application, but is public and can be written\n * to by other applications.\n *\n * Your external storage path is typically:\n * `/storage/sdcard0/Android/data/your.app.package/files`.\n *\n * \\returns the path used for external storage for this application on success\n *          or NULL on failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_AndroidGetExternalStorageState\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_AndroidGetExternalStoragePath",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Request permissions at runtime.\n *\n * This blocks the calling thread until the permission is granted or denied.\n *\n * \\param permission The permission to request.\n * \\returns SDL_TRUE if the permission was granted, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_AndroidRequestPermission",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "permission"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Shows an Android toast notification.\n *\n * Toasts are a sort of lightweight notification that are unique to Android.\n *\n * https://developer.android.com/guide/topics/ui/notifiers/toasts\n *\n * Shows toast in UI thread.\n *\n * For the `gravity` parameter, choose a value from here, or -1 if you don't\n * have a preference:\n *\n * https://developer.android.com/reference/android/view/Gravity\n *\n * \\param message text message to be shown\n * \\param duration 0=short, 1=long\n * \\param gravity where the notification should appear on the screen.\n * \\param xoffset set this parameter only when gravity >=0\n * \\param yoffset set this parameter only when gravity >=0\n * \\returns 0 if success, -1 if any error occurs.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_AndroidShowToast",
        "parameter": [
            "const char *REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "message",
            "duration",
            "gravity",
            "xoffset",
            "yoffset"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Send a user command to SDLActivity.\n *\n * Override \"boolean onUnhandledMessage(Message msg)\" to handle the message.\n *\n * \\param command user command that must be greater or equal to 0x8000\n * \\param param user parameter\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_AndroidSendMessage",
        "parameter": [
            "Uint32 REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "command",
            "param"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Retrieve a WinRT defined path on the local file system.\n *\n * Not all paths are available on all versions of Windows. This is especially\n * true on Windows Phone. Check the documentation for the given SDL_WinRT_Path\n * for more information on which path types are supported where.\n *\n * Documentation on most app-specific path types on WinRT can be found on\n * MSDN, at the URL:\n *\n * https://msdn.microsoft.com/en-us/library/windows/apps/hh464917.aspx\n *\n * \\param pathType the type of path to retrieve, one of SDL_WinRT_Path\n * \\returns a UCS-2 string (16-bit, wide-char) containing the path, or NULL if\n *          the path is not available for any reason; call SDL_GetError() for\n *          more information.\n *\n * \\since This function is available since SDL 2.0.3.\n *\n * \\sa SDL_WinRTGetFSPathUTF8\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_WinRTGetFSPathUNICODE",
        "parameter": [
            "SDL_WinRT_Path REWRITE_NAME"
        ],
        "parameter_name": [
            "pathType"
        ],
        "retval": "const wchar_t*"
    },
    {
        "comment": "/**\n * Retrieve a WinRT defined path on the local file system.\n *\n * Not all paths are available on all versions of Windows. This is especially\n * true on Windows Phone. Check the documentation for the given SDL_WinRT_Path\n * for more information on which path types are supported where.\n *\n * Documentation on most app-specific path types on WinRT can be found on\n * MSDN, at the URL:\n *\n * https://msdn.microsoft.com/en-us/library/windows/apps/hh464917.aspx\n *\n * \\param pathType the type of path to retrieve, one of SDL_WinRT_Path\n * \\returns a UTF-8 string (8-bit, multi-byte) containing the path, or NULL if\n *          the path is not available for any reason; call SDL_GetError() for\n *          more information.\n *\n * \\since This function is available since SDL 2.0.3.\n *\n * \\sa SDL_WinRTGetFSPathUNICODE\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_WinRTGetFSPathUTF8",
        "parameter": [
            "SDL_WinRT_Path REWRITE_NAME"
        ],
        "parameter_name": [
            "pathType"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Detects the device family of WinRT platform at runtime.\n *\n * \\returns a value from the SDL_WinRT_DeviceFamily enum.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_WinRTGetDeviceFamily",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_WinRT_DeviceFamily"
    },
    {
        "comment": "/**\n * Query if the current device is a tablet.\n *\n * If SDL can't determine this, it will return SDL_FALSE.\n *\n * \\returns SDL_TRUE if the device is a tablet, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_IsTablet",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "",
        "header": "SDL_system.h",
        "name": "SDL_OnApplicationWillTerminate",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "",
        "header": "SDL_system.h",
        "name": "SDL_OnApplicationDidReceiveMemoryWarning",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "",
        "header": "SDL_system.h",
        "name": "SDL_OnApplicationWillResignActive",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "",
        "header": "SDL_system.h",
        "name": "SDL_OnApplicationDidEnterBackground",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "",
        "header": "SDL_system.h",
        "name": "SDL_OnApplicationWillEnterForeground",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "",
        "header": "SDL_system.h",
        "name": "SDL_OnApplicationDidBecomeActive",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "",
        "header": "SDL_system.h",
        "name": "SDL_OnApplicationDidChangeStatusBarOrientation",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Gets a reference to the global async task queue handle for GDK,\n * initializing if needed.\n *\n * Once you are done with the task queue, you should call\n * XTaskQueueCloseHandle to reduce the reference count to avoid a resource\n * leak.\n *\n * \\param outTaskQueue a pointer to be filled in with task queue handle.\n * \\returns 0 if success, -1 if any error occurs.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_system.h",
        "name": "SDL_GDKGetTaskQueue",
        "parameter": [
            "XTaskQueueHandle *REWRITE_NAME"
        ],
        "parameter_name": [
            "outTaskQueue"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Compose a custom blend mode for renderers.\n *\n * The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept\n * the SDL_BlendMode returned by this function if the renderer supports it.\n *\n * A blend mode controls how the pixels from a drawing operation (source) get\n * combined with the pixels from the render target (destination). First, the\n * components of the source and destination pixels get multiplied with their\n * blend factors. Then, the blend operation takes the two products and\n * calculates the result that will get stored in the render target.\n *\n * Expressed in pseudocode, it would look like this:\n *\n * ```c\n * dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);\n * dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);\n * ```\n *\n * Where the functions `colorOperation(src, dst)` and `alphaOperation(src,\n * dst)` can return one of the following:\n *\n * - `src + dst`\n * - `src - dst`\n * - `dst - src`\n * - `min(src, dst)`\n * - `max(src, dst)`\n *\n * The red, green, and blue components are always multiplied with the first,\n * second, and third components of the SDL_BlendFactor, respectively. The\n * fourth component is not used.\n *\n * The alpha component is always multiplied with the fourth component of the\n * SDL_BlendFactor. The other components are not used in the alpha\n * calculation.\n *\n * Support for these blend modes varies for each renderer. To check if a\n * specific SDL_BlendMode is supported, create a renderer and pass it to\n * either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will\n * return with an error if the blend mode is not supported.\n *\n * This list describes the support of custom blend modes for each renderer in\n * SDL 2.0.6. All renderers support the four blend modes listed in the\n * SDL_BlendMode enumeration.\n *\n * - **direct3d**: Supports all operations with all factors. However, some\n *   factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and\n *   `SDL_BLENDOPERATION_MAXIMUM`.\n * - **direct3d11**: Same as Direct3D 9.\n * - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all\n *   factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly with SDL\n *   2.0.6.\n * - **opengles**: Supports the `SDL_BLENDOPERATION_ADD` operation with all\n *   factors. Color and alpha factors need to be the same. OpenGL ES 1\n *   implementation specific: May also support `SDL_BLENDOPERATION_SUBTRACT`\n *   and `SDL_BLENDOPERATION_REV_SUBTRACT`. May support color and alpha\n *   operations being different from each other. May support color and alpha\n *   factors being different from each other.\n * - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,\n *   `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`\n *   operations with all factors.\n * - **psp**: No custom blend mode support.\n * - **software**: No custom blend mode support.\n *\n * Some renderers do not provide an alpha component for the default render\n * target. The `SDL_BLENDFACTOR_DST_ALPHA` and\n * `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this\n * case.\n *\n * \\param srcColorFactor the SDL_BlendFactor applied to the red, green, and\n *                       blue components of the source pixels\n * \\param dstColorFactor the SDL_BlendFactor applied to the red, green, and\n *                       blue components of the destination pixels\n * \\param colorOperation the SDL_BlendOperation used to combine the red,\n *                       green, and blue components of the source and\n *                       destination pixels\n * \\param srcAlphaFactor the SDL_BlendFactor applied to the alpha component of\n *                       the source pixels\n * \\param dstAlphaFactor the SDL_BlendFactor applied to the alpha component of\n *                       the destination pixels\n * \\param alphaOperation the SDL_BlendOperation used to combine the alpha\n *                       component of the source and destination pixels\n * \\returns an SDL_BlendMode that represents the chosen factors and\n *          operations.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetRenderDrawBlendMode\n * \\sa SDL_GetRenderDrawBlendMode\n * \\sa SDL_SetTextureBlendMode\n * \\sa SDL_GetTextureBlendMode\n */\n",
        "header": "SDL_blendmode.h",
        "name": "SDL_ComposeCustomBlendMode",
        "parameter": [
            "SDL_BlendFactor REWRITE_NAME",
            "SDL_BlendFactor REWRITE_NAME",
            "SDL_BlendOperation REWRITE_NAME",
            "SDL_BlendFactor REWRITE_NAME",
            "SDL_BlendFactor REWRITE_NAME",
            "SDL_BlendOperation REWRITE_NAME"
        ],
        "parameter_name": [
            "srcColorFactor",
            "dstColorFactor",
            "colorOperation",
            "srcAlphaFactor",
            "dstAlphaFactor",
            "alphaOperation"
        ],
        "retval": "SDL_BlendMode"
    },
    {
        "comment": "/**\n * Get the number of video drivers compiled into SDL.\n *\n * \\returns a number >= 1 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetVideoDriver\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetNumVideoDrivers",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the name of a built in video driver.\n *\n * The video drivers are presented in the order in which they are normally\n * checked during initialization.\n *\n * \\param index the index of a video driver\n * \\returns the name of the video driver with the given **index**.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetNumVideoDrivers\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetVideoDriver",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "index"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the name of the currently initialized video driver.\n *\n * \\returns the name of the current video driver or NULL if no driver has been\n *          initialized.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetNumVideoDrivers\n * \\sa SDL_GetVideoDriver\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetCurrentVideoDriver",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the number of available video displays.\n *\n * \\returns a number >= 1 or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetDisplayBounds\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetNumVideoDisplays",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the name of a display in UTF-8 encoding.\n *\n * \\param displayIndex the index of display from which the name should be\n *                     queried\n * \\returns the name of a display or NULL for an invalid display index or\n *          failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetNumVideoDisplays\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetDisplayName",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "displayIndex"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the desktop area represented by a display.\n *\n * The primary display (`displayIndex` zero) is always located at 0,0.\n *\n * \\param displayIndex the index of the display to query\n * \\param rect the SDL_Rect structure filled in with the display bounds\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetNumVideoDisplays\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetDisplayBounds",
        "parameter": [
            "int REWRITE_NAME",
            "SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "displayIndex",
            "rect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the usable desktop area represented by a display.\n *\n * The primary display (`displayIndex` zero) is always located at 0,0.\n *\n * This is the same area as SDL_GetDisplayBounds() reports, but with portions\n * reserved by the system removed. For example, on Apple's macOS, this\n * subtracts the area occupied by the menu bar and dock.\n *\n * Setting a window to be fullscreen generally bypasses these unusable areas,\n * so these are good guidelines for the maximum space available to a\n * non-fullscreen window.\n *\n * The parameter `rect` is ignored if it is NULL.\n *\n * This function also returns -1 if the parameter `displayIndex` is out of\n * range.\n *\n * \\param displayIndex the index of the display to query the usable bounds\n *                     from\n * \\param rect the SDL_Rect structure filled in with the display bounds\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetDisplayBounds\n * \\sa SDL_GetNumVideoDisplays\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetDisplayUsableBounds",
        "parameter": [
            "int REWRITE_NAME",
            "SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "displayIndex",
            "rect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the dots/pixels-per-inch for a display.\n *\n * Diagonal, horizontal and vertical DPI can all be optionally returned if the\n * appropriate parameter is non-NULL.\n *\n * A failure of this function usually means that either no DPI information is\n * available or the `displayIndex` is out of range.\n *\n * **WARNING**: This reports the DPI that the hardware reports, and it is not\n * always reliable! It is almost always better to use SDL_GetWindowSize() to\n * find the window size, which might be in logical points instead of pixels,\n * and then SDL_GetWindowSizeInPixels(), SDL_GL_GetDrawableSize(),\n * SDL_Vulkan_GetDrawableSize(), SDL_Metal_GetDrawableSize(), or\n * SDL_GetRendererOutputSize(), and compare the two values to get an actual\n * scaling value between the two. We will be rethinking how high-dpi details\n * should be managed in SDL3 to make things more consistent, reliable, and clear.\n *\n * \\param displayIndex the index of the display from which DPI information\n *                     should be queried\n * \\param ddpi a pointer filled in with the diagonal DPI of the display; may\n *             be NULL\n * \\param hdpi a pointer filled in with the horizontal DPI of the display; may\n *             be NULL\n * \\param vdpi a pointer filled in with the vertical DPI of the display; may\n *             be NULL\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetNumVideoDisplays\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetDisplayDPI",
        "parameter": [
            "int REWRITE_NAME",
            "float *REWRITE_NAME",
            "float *REWRITE_NAME",
            "float *REWRITE_NAME"
        ],
        "parameter_name": [
            "displayIndex",
            "ddpi",
            "hdpi",
            "vdpi"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the orientation of a display.\n *\n * \\param displayIndex the index of the display to query\n * \\returns The SDL_DisplayOrientation enum value of the display, or\n *          `SDL_ORIENTATION_UNKNOWN` if it isn't available.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetNumVideoDisplays\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetDisplayOrientation",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "displayIndex"
        ],
        "retval": "SDL_DisplayOrientation"
    },
    {
        "comment": "/**\n * Get the number of available display modes.\n *\n * The `displayIndex` needs to be in the range from 0 to\n * SDL_GetNumVideoDisplays() - 1.\n *\n * \\param displayIndex the index of the display to query\n * \\returns a number >= 1 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetDisplayMode\n * \\sa SDL_GetNumVideoDisplays\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetNumDisplayModes",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "displayIndex"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get information about a specific display mode.\n *\n * The display modes are sorted in this priority:\n *\n * - width -> largest to smallest\n * - height -> largest to smallest\n * - bits per pixel -> more colors to fewer colors\n * - packed pixel layout -> largest to smallest\n * - refresh rate -> highest to lowest\n *\n * \\param displayIndex the index of the display to query\n * \\param modeIndex the index of the display mode to query\n * \\param mode an SDL_DisplayMode structure filled in with the mode at\n *             `modeIndex`\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetNumDisplayModes\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetDisplayMode",
        "parameter": [
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "SDL_DisplayMode *REWRITE_NAME"
        ],
        "parameter_name": [
            "displayIndex",
            "modeIndex",
            "mode"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get information about the desktop's display mode.\n *\n * There's a difference between this function and SDL_GetCurrentDisplayMode()\n * when SDL runs fullscreen and has changed the resolution. In that case this\n * function will return the previous native display mode, and not the current\n * display mode.\n *\n * \\param displayIndex the index of the display to query\n * \\param mode an SDL_DisplayMode structure filled in with the current display\n *             mode\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetCurrentDisplayMode\n * \\sa SDL_GetDisplayMode\n * \\sa SDL_SetWindowDisplayMode\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetDesktopDisplayMode",
        "parameter": [
            "int REWRITE_NAME",
            "SDL_DisplayMode *REWRITE_NAME"
        ],
        "parameter_name": [
            "displayIndex",
            "mode"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get information about the current display mode.\n *\n * There's a difference between this function and SDL_GetDesktopDisplayMode()\n * when SDL runs fullscreen and has changed the resolution. In that case this\n * function will return the current display mode, and not the previous native\n * display mode.\n *\n * \\param displayIndex the index of the display to query\n * \\param mode an SDL_DisplayMode structure filled in with the current display\n *             mode\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetDesktopDisplayMode\n * \\sa SDL_GetDisplayMode\n * \\sa SDL_GetNumVideoDisplays\n * \\sa SDL_SetWindowDisplayMode\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetCurrentDisplayMode",
        "parameter": [
            "int REWRITE_NAME",
            "SDL_DisplayMode *REWRITE_NAME"
        ],
        "parameter_name": [
            "displayIndex",
            "mode"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the closest match to the requested display mode.\n *\n * The available display modes are scanned and `closest` is filled in with the\n * closest mode matching the requested mode and returned. The mode format and\n * refresh rate default to the desktop mode if they are set to 0. The modes\n * are scanned with size being first priority, format being second priority,\n * and finally checking the refresh rate. If all the available modes are too\n * small, then NULL is returned.\n *\n * \\param displayIndex the index of the display to query\n * \\param mode an SDL_DisplayMode structure containing the desired display\n *             mode\n * \\param closest an SDL_DisplayMode structure filled in with the closest\n *                match of the available display modes\n * \\returns the passed in value `closest` or NULL if no matching video mode\n *          was available; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetDisplayMode\n * \\sa SDL_GetNumDisplayModes\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetClosestDisplayMode",
        "parameter": [
            "int REWRITE_NAME",
            "const SDL_DisplayMode *REWRITE_NAME",
            "SDL_DisplayMode *REWRITE_NAME"
        ],
        "parameter_name": [
            "displayIndex",
            "mode",
            "closest"
        ],
        "retval": "SDL_DisplayMode*"
    },
    {
        "comment": "/**\n * Get the index of the display containing a point\n *\n * \\param point the point to query\n * \\returns the index of the display containing the point or a negative error\n *          code on failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetDisplayBounds\n * \\sa SDL_GetNumVideoDisplays\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetDisplayIndexForPoint",
        "parameter": [
            "const SDL_Point *REWRITE_NAME"
        ],
        "parameter_name": [
            "point"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the index of the display primarily containing a rect\n *\n * \\param rect the rect to query\n * \\returns the index of the display entirely containing the rect or closest\n *          to the center of the rect on success or a negative error code on\n *          failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetDisplayBounds\n * \\sa SDL_GetNumVideoDisplays\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetDisplayIndexForRect",
        "parameter": [
            "const SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "rect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the index of the display associated with a window.\n *\n * \\param window the window to query\n * \\returns the index of the display containing the center of the window on\n *          success or a negative error code on failure; call SDL_GetError()\n *          for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetDisplayBounds\n * \\sa SDL_GetNumVideoDisplays\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowDisplayIndex",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set the display mode to use when a window is visible at fullscreen.\n *\n * This only affects the display mode used when the window is fullscreen. To\n * change the window size when the window is not fullscreen, use\n * SDL_SetWindowSize().\n *\n * \\param window the window to affect\n * \\param mode the SDL_DisplayMode structure representing the mode to use, or\n *             NULL to use the window's dimensions and the desktop's format\n *             and refresh rate\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowDisplayMode\n * \\sa SDL_SetWindowFullscreen\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowDisplayMode",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "const SDL_DisplayMode *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "mode"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Query the display mode to use when a window is visible at fullscreen.\n *\n * \\param window the window to query\n * \\param mode an SDL_DisplayMode structure filled in with the fullscreen\n *             display mode\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetWindowDisplayMode\n * \\sa SDL_SetWindowFullscreen\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowDisplayMode",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "SDL_DisplayMode *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "mode"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the raw ICC profile data for the screen the window is currently on.\n *\n * Data returned should be freed with SDL_free.\n *\n * \\param window the window to query\n * \\param size the size of the ICC profile\n * \\returns the raw ICC profile data on success or NULL on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowICCProfile",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "size_t *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "size"
        ],
        "retval": "void*"
    },
    {
        "comment": "/**\n * Get the pixel format associated with the window.\n *\n * \\param window the window to query\n * \\returns the pixel format of the window on success or\n *          SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowPixelFormat",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "Uint32"
    },
    {
        "comment": "/**\n * Create a window with the specified position, dimensions, and flags.\n *\n * `flags` may be any of the following OR'd together:\n *\n * - `SDL_WINDOW_FULLSCREEN`: fullscreen window\n * - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution\n * - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context\n * - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance\n * - `SDL_WINDOW_METAL`: window usable with a Metal instance\n * - `SDL_WINDOW_HIDDEN`: window is not visible\n * - `SDL_WINDOW_BORDERLESS`: no window decoration\n * - `SDL_WINDOW_RESIZABLE`: window can be resized\n * - `SDL_WINDOW_MINIMIZED`: window is minimized\n * - `SDL_WINDOW_MAXIMIZED`: window is maximized\n * - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus\n * - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if\n *   supported (>= SDL 2.0.1)\n *\n * The SDL_Window is implicitly shown if SDL_WINDOW_HIDDEN is not set.\n *\n * On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist\n * property to YES, otherwise you will not receive a High-DPI OpenGL canvas.\n *\n * If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size\n * in pixels may differ from its size in screen coordinates on platforms with\n * high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the\n * client area's size in screen coordinates, and SDL_GetWindowSizeInPixels() or\n * SDL_GetRendererOutputSize() to query the drawable size in pixels. Note that\n * when this flag is set, the drawable size can vary after the window is\n * created and should be queried after major window events such as when the\n * window is resized or moved between displays.\n *\n * If the window is set fullscreen, the width and height parameters `w` and\n * `h` will not be used. However, invalid size parameters (e.g. too large) may\n * still fail. Window size is actually limited to 16384 x 16384 for all\n * platforms at window creation.\n *\n * If the window is created with any of the SDL_WINDOW_OPENGL or\n * SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function\n * (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the\n * corresponding UnloadLibrary function is called by SDL_DestroyWindow().\n *\n * If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,\n * SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.\n *\n * If SDL_WINDOW_METAL is specified on an OS that does not support Metal,\n * SDL_CreateWindow() will fail.\n *\n * On non-Apple devices, SDL requires you to either not link to the Vulkan\n * loader or link to a dynamic library version. This limitation may be removed\n * in a future version of SDL.\n *\n * \\param title the title of the window, in UTF-8 encoding\n * \\param x the x position of the window, `SDL_WINDOWPOS_CENTERED`, or\n *          `SDL_WINDOWPOS_UNDEFINED`\n * \\param y the y position of the window, `SDL_WINDOWPOS_CENTERED`, or\n *          `SDL_WINDOWPOS_UNDEFINED`\n * \\param w the width of the window, in screen coordinates\n * \\param h the height of the window, in screen coordinates\n * \\param flags 0, or one or more SDL_WindowFlags OR'd together\n * \\returns the window that was created or NULL on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateWindowFrom\n * \\sa SDL_DestroyWindow\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_CreateWindow",
        "parameter": [
            "const char *REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "title",
            "x",
            "y",
            "w",
            "h",
            "flags"
        ],
        "retval": "SDL_Window*"
    },
    {
        "comment": "/**\n * Create an SDL window from an existing native window.\n *\n * In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows)\n * the hint `SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT` needs to be configured\n * before using SDL_CreateWindowFrom().\n *\n * \\param data a pointer to driver-dependent window creation data, typically\n *             your native window cast to a void*\n * \\returns the window that was created or NULL on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateWindow\n * \\sa SDL_DestroyWindow\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_CreateWindowFrom",
        "parameter": [
            "const void *REWRITE_NAME"
        ],
        "parameter_name": [
            "data"
        ],
        "retval": "SDL_Window*"
    },
    {
        "comment": "/**\n * Get the numeric ID of a window.\n *\n * The numeric ID is what SDL_WindowEvent references, and is necessary to map\n * these events to specific SDL_Window objects.\n *\n * \\param window the window to query\n * \\returns the ID of the window on success or 0 on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowFromID\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowID",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "SDL_WindowID"
    },
    {
        "comment": "/**\n * Get a window from a stored ID.\n *\n * The numeric ID is what SDL_WindowEvent references, and is necessary to map\n * these events to specific SDL_Window objects.\n *\n * \\param id the ID of the window\n * \\returns the window associated with `id` or NULL if it doesn't exist; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowID\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowFromID",
        "parameter": [
            "SDL_WindowID REWRITE_NAME"
        ],
        "parameter_name": [
            "id"
        ],
        "retval": "SDL_Window*"
    },
    {
        "comment": "/**\n * Get the window flags.\n *\n * \\param window the window to query\n * \\returns a mask of the SDL_WindowFlags associated with `window`\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateWindow\n * \\sa SDL_HideWindow\n * \\sa SDL_MaximizeWindow\n * \\sa SDL_MinimizeWindow\n * \\sa SDL_SetWindowFullscreen\n * \\sa SDL_SetWindowGrab\n * \\sa SDL_ShowWindow\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowFlags",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "Uint32"
    },
    {
        "comment": "/**\n * Set the title of a window.\n *\n * This string is expected to be in UTF-8 encoding.\n *\n * \\param window the window to change\n * \\param title the desired window title in UTF-8 format\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowTitle\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowTitle",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "title"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the title of a window.\n *\n * \\param window the window to query\n * \\returns the title of the window in UTF-8 format or \"\" if there is no\n *          title.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetWindowTitle\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowTitle",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Set the icon for a window.\n *\n * \\param window the window to change\n * \\param icon an SDL_Surface structure containing the icon for the window\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowIcon",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "SDL_Surface *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "icon"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Associate an arbitrary named pointer with a window.\n *\n * `name` is case-sensitive.\n *\n * \\param window the window to associate with the pointer\n * \\param name the name of the pointer\n * \\param userdata the associated pointer\n * \\returns the previous value associated with `name`.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowData\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowData",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "const char *REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "name",
            "userdata"
        ],
        "retval": "void*"
    },
    {
        "comment": "/**\n * Retrieve the data pointer associated with a window.\n *\n * \\param window the window to query\n * \\param name the name of the pointer\n * \\returns the value associated with `name`.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetWindowData\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowData",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "name"
        ],
        "retval": "void*"
    },
    {
        "comment": "/**\n * Set the position of a window.\n *\n * The window coordinate origin is the upper left of the display.\n *\n * \\param window the window to reposition\n * \\param x the x coordinate of the window in screen coordinates, or\n *          `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`\n * \\param y the y coordinate of the window in screen coordinates, or\n *          `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowPosition\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowPosition",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "x",
            "y"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the position of a window.\n *\n * If you do not need the value for one of the positions a NULL may be passed\n * in the `x` or `y` parameter.\n *\n * \\param window the window to query\n * \\param x a pointer filled in with the x position of the window, in screen\n *          coordinates, may be NULL\n * \\param y a pointer filled in with the y position of the window, in screen\n *          coordinates, may be NULL\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetWindowPosition\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowPosition",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "x",
            "y"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set the size of a window's client area.\n *\n * The window size in screen coordinates may differ from the size in pixels,\n * if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform\n * with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or\n * SDL_GetRendererOutputSize() to get the real client area size in pixels.\n *\n * Fullscreen windows automatically match the size of the display mode, and\n * you should use SDL_SetWindowDisplayMode() to change their size.\n *\n * \\param window the window to change\n * \\param w the width of the window in pixels, in screen coordinates, must be\n *          > 0\n * \\param h the height of the window in pixels, in screen coordinates, must be\n *          > 0\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowSize\n * \\sa SDL_SetWindowDisplayMode\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowSize",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "w",
            "h"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the size of a window's client area.\n *\n * NULL can safely be passed as the `w` or `h` parameter if the width or\n * height value is not desired.\n *\n * The window size in screen coordinates may differ from the size in pixels,\n * if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform\n * with high-dpi support (e.g. iOS or macOS). Use SDL_GetWindowSizeInPixels(),\n * SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(), or\n * SDL_GetRendererOutputSize() to get the real client area size in pixels.\n *\n * \\param window the window to query the width and height from\n * \\param w a pointer filled in with the width of the window, in screen\n *          coordinates, may be NULL\n * \\param h a pointer filled in with the height of the window, in screen\n *          coordinates, may be NULL\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GL_GetDrawableSize\n * \\sa SDL_Vulkan_GetDrawableSize\n * \\sa SDL_GetWindowSizeInPixels\n * \\sa SDL_SetWindowSize\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowSize",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "w",
            "h"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the size of a window's borders (decorations) around the client area.\n *\n * Note: If this function fails (returns -1), the size values will be\n * initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the\n * window in question was borderless.\n *\n * Note: This function may fail on systems where the window has not yet been\n * decorated by the display server (for example, immediately after calling\n * SDL_CreateWindow). It is recommended that you wait at least until the\n * window has been presented and composited, so that the window system has a\n * chance to decorate the window and provide the border dimensions to SDL.\n *\n * This function also returns -1 if getting the information is not supported.\n *\n * \\param window the window to query the size values of the border\n *               (decorations) from\n * \\param top pointer to variable for storing the size of the top border; NULL\n *            is permitted\n * \\param left pointer to variable for storing the size of the left border;\n *             NULL is permitted\n * \\param bottom pointer to variable for storing the size of the bottom\n *               border; NULL is permitted\n * \\param right pointer to variable for storing the size of the right border;\n *              NULL is permitted\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowSize\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowBordersSize",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "top",
            "left",
            "bottom",
            "right"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the size of a window in pixels.\n *\n * This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI\n * drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a\n * platform with high-DPI support (Apple calls this \"Retina\"), and not\n * disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.\n *\n * \\param window the window from which the drawable size should be queried\n * \\param w a pointer to variable for storing the width in pixels, may be NULL\n * \\param h a pointer to variable for storing the height in pixels, may be\n *          NULL\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateWindow\n * \\sa SDL_GetWindowSize\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowSizeInPixels",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "w",
            "h"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set the minimum size of a window's client area.\n *\n * \\param window the window to change\n * \\param min_w the minimum width of the window in pixels\n * \\param min_h the minimum height of the window in pixels\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowMinimumSize\n * \\sa SDL_SetWindowMaximumSize\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowMinimumSize",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "min_w",
            "min_h"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the minimum size of a window's client area.\n *\n * \\param window the window to query\n * \\param w a pointer filled in with the minimum width of the window, may be\n *          NULL\n * \\param h a pointer filled in with the minimum height of the window, may be\n *          NULL\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowMaximumSize\n * \\sa SDL_SetWindowMinimumSize\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowMinimumSize",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "w",
            "h"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set the maximum size of a window's client area.\n *\n * \\param window the window to change\n * \\param max_w the maximum width of the window in pixels\n * \\param max_h the maximum height of the window in pixels\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowMaximumSize\n * \\sa SDL_SetWindowMinimumSize\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowMaximumSize",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "max_w",
            "max_h"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the maximum size of a window's client area.\n *\n * \\param window the window to query\n * \\param w a pointer filled in with the maximum width of the window, may be\n *          NULL\n * \\param h a pointer filled in with the maximum height of the window, may be\n *          NULL\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowMinimumSize\n * \\sa SDL_SetWindowMaximumSize\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowMaximumSize",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "w",
            "h"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set the border state of a window.\n *\n * This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add\n * or remove the border from the actual window. This is a no-op if the\n * window's border already matches the requested state.\n *\n * You can't change the border state of a fullscreen window.\n *\n * \\param window the window of which to change the border state\n * \\param bordered SDL_FALSE to remove border, SDL_TRUE to add border\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowFlags\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowBordered",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "SDL_bool REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "bordered"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set the user-resizable state of a window.\n *\n * This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and\n * allow/disallow user resizing of the window. This is a no-op if the window's\n * resizable state already matches the requested state.\n *\n * You can't change the resizable state of a fullscreen window.\n *\n * \\param window the window of which to change the resizable state\n * \\param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowFlags\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowResizable",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "SDL_bool REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "resizable"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set the window to always be above the others.\n *\n * This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This\n * will bring the window to the front and keep the window above the rest.\n *\n * \\param window The window of which to change the always on top state\n * \\param on_top SDL_TRUE to set the window always on top, SDL_FALSE to\n *               disable\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowFlags\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowAlwaysOnTop",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "SDL_bool REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "on_top"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Show a window.\n *\n * \\param window the window to show\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HideWindow\n * \\sa SDL_RaiseWindow\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_ShowWindow",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Hide a window.\n *\n * \\param window the window to hide\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ShowWindow\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_HideWindow",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Raise a window above other windows and set the input focus.\n *\n * \\param window the window to raise\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_RaiseWindow",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Make a window as large as possible.\n *\n * \\param window the window to maximize\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_MinimizeWindow\n * \\sa SDL_RestoreWindow\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_MaximizeWindow",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Minimize a window to an iconic representation.\n *\n * \\param window the window to minimize\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_MaximizeWindow\n * \\sa SDL_RestoreWindow\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_MinimizeWindow",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Restore the size and position of a minimized or maximized window.\n *\n * \\param window the window to restore\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_MaximizeWindow\n * \\sa SDL_MinimizeWindow\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_RestoreWindow",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set a window's fullscreen state.\n *\n * `flags` may be `SDL_WINDOW_FULLSCREEN`, for \"real\" fullscreen with a\n * videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for \"fake\" fullscreen\n * that takes the size of the desktop; and 0 for windowed mode.\n *\n * \\param window the window to change\n * \\param flags `SDL_WINDOW_FULLSCREEN`, `SDL_WINDOW_FULLSCREEN_DESKTOP` or 0\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowDisplayMode\n * \\sa SDL_SetWindowDisplayMode\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowFullscreen",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "flags"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the SDL surface associated with the window.\n *\n * A new surface will be created with the optimal format for the window, if\n * necessary. This surface will be freed when the window is destroyed. Do not\n * free this surface.\n *\n * This surface will be invalidated if the window is resized. After resizing a\n * window this function must be called again to return a valid surface.\n *\n * You may not combine this with 3D or the rendering API on this window.\n *\n * This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.\n *\n * \\param window the window to query\n * \\returns the surface associated with the window, or NULL on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_UpdateWindowSurface\n * \\sa SDL_UpdateWindowSurfaceRects\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowSurface",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "SDL_Surface*"
    },
    {
        "comment": "/**\n * Copy the window surface to the screen.\n *\n * This is the function you use to reflect any changes to the surface on the\n * screen.\n *\n * This function is equivalent to the SDL 1.2 API SDL_Flip().\n *\n * \\param window the window to update\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowSurface\n * \\sa SDL_UpdateWindowSurfaceRects\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_UpdateWindowSurface",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Copy areas of the window surface to the screen.\n *\n * This is the function you use to reflect changes to portions of the surface\n * on the screen.\n *\n * This function is equivalent to the SDL 1.2 API SDL_UpdateRects().\n *\n * \\param window the window to update\n * \\param rects an array of SDL_Rect structures representing areas of the\n *              surface to copy\n * \\param numrects the number of rectangles\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowSurface\n * \\sa SDL_UpdateWindowSurface\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_UpdateWindowSurfaceRects",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "rects",
            "numrects"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set a window's input grab mode.\n *\n * When input is grabbed, the mouse is confined to the window. This function\n * will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the\n * keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().\n *\n * If the caller enables a grab while another window is currently grabbed, the\n * other window loses its grab in favor of the caller's window.\n *\n * \\param window the window for which the input grab mode should be set\n * \\param grabbed SDL_TRUE to grab input or SDL_FALSE to release input\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetGrabbedWindow\n * \\sa SDL_GetWindowGrab\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowGrab",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "SDL_bool REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "grabbed"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set a window's keyboard grab mode.\n *\n * Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or\n * the Meta/Super key. Note that not all system keyboard shortcuts can be\n * captured by applications (one example is Ctrl+Alt+Del on Windows).\n *\n * This is primarily intended for specialized applications such as VNC clients\n * or VM frontends. Normal games should not use keyboard grab.\n *\n * When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the\n * window is full-screen to ensure the user is not trapped in your\n * application. If you have a custom keyboard shortcut to exit fullscreen\n * mode, you may suppress this behavior with\n * `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.\n *\n * If the caller enables a grab while another window is currently grabbed, the\n * other window loses its grab in favor of the caller's window.\n *\n * \\param window The window for which the keyboard grab mode should be set.\n * \\param grabbed This is SDL_TRUE to grab keyboard, and SDL_FALSE to release.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowKeyboardGrab\n * \\sa SDL_SetWindowMouseGrab\n * \\sa SDL_SetWindowGrab\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowKeyboardGrab",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "SDL_bool REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "grabbed"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set a window's mouse grab mode.\n *\n * Mouse grab confines the mouse cursor to the window.\n *\n * \\param window The window for which the mouse grab mode should be set.\n * \\param grabbed This is SDL_TRUE to grab mouse, and SDL_FALSE to release.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowMouseGrab\n * \\sa SDL_SetWindowKeyboardGrab\n * \\sa SDL_SetWindowGrab\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowMouseGrab",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "SDL_bool REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "grabbed"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get a window's input grab mode.\n *\n * \\param window the window to query\n * \\returns SDL_TRUE if input is grabbed, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetWindowGrab\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowGrab",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Get a window's keyboard grab mode.\n *\n * \\param window the window to query\n * \\returns SDL_TRUE if keyboard is grabbed, and SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetWindowKeyboardGrab\n * \\sa SDL_GetWindowGrab\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowKeyboardGrab",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Get a window's mouse grab mode.\n *\n * \\param window the window to query\n * \\returns SDL_TRUE if mouse is grabbed, and SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetWindowKeyboardGrab\n * \\sa SDL_GetWindowGrab\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowMouseGrab",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Get the window that currently has an input grab enabled.\n *\n * \\returns the window if input is grabbed or NULL otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowGrab\n * \\sa SDL_SetWindowGrab\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetGrabbedWindow",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_Window*"
    },
    {
        "comment": "/**\n * Confines the cursor to the specified area of a window.\n *\n * Note that this does NOT grab the cursor, it only defines the area a cursor\n * is restricted to when the window has mouse focus.\n *\n * \\param window The window that will be associated with the barrier.\n * \\param rect A rectangle area in window-relative coordinates. If NULL the\n *             barrier for the specified window will be destroyed.\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowMouseRect\n * \\sa SDL_SetWindowMouseGrab\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowMouseRect",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "rect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the mouse confinement rectangle of a window.\n *\n * \\param window The window to query\n * \\returns A pointer to the mouse confinement rectangle of a window, or NULL\n *          if there isn't one.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetWindowMouseRect\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowMouseRect",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "const SDL_Rect*"
    },
    {
        "comment": "/**\n * Set the opacity for a window.\n *\n * The parameter `opacity` will be clamped internally between 0.0f\n * (transparent) and 1.0f (opaque).\n *\n * This function also returns -1 if setting the opacity isn't supported.\n *\n * \\param window the window which will be made transparent or opaque\n * \\param opacity the opacity value (0.0f - transparent, 1.0f - opaque)\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowOpacity\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowOpacity",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "float REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "opacity"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the opacity of a window.\n *\n * If transparency isn't supported on this platform, opacity will be reported\n * as 1.0f without error.\n *\n * The parameter `opacity` is ignored if it is NULL.\n *\n * This function also returns -1 if an invalid window was provided.\n *\n * \\param window the window to get the current opacity value from\n * \\param out_opacity the float filled in (0.0f - transparent, 1.0f - opaque)\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetWindowOpacity\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GetWindowOpacity",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "float *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "out_opacity"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set the window as a modal for another window.\n *\n * \\param modal_window the window that should be set modal\n * \\param parent_window the parent window for the modal window\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowModalFor",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "modal_window",
            "parent_window"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Explicitly set input focus to the window.\n *\n * You almost certainly want SDL_RaiseWindow() instead of this function. Use\n * this with caution, as you might give focus to a window that is completely\n * obscured by other windows.\n *\n * \\param window the window that should get the input focus\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RaiseWindow\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowInputFocus",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Provide a callback that decides if a window region has special properties.\n *\n * Normally windows are dragged and resized by decorations provided by the\n * system window manager (a title bar, borders, etc), but for some apps, it\n * makes sense to drag them from somewhere else inside the window itself; for\n * example, one might have a borderless window that wants to be draggable from\n * any part, or simulate its own title bar, etc.\n *\n * This function lets the app provide a callback that designates pieces of a\n * given window as special. This callback is run during event processing if we\n * need to tell the OS to treat a region of the window specially; the use of\n * this callback is known as \"hit testing.\"\n *\n * Mouse input may not be delivered to your application if it is within a\n * special area; the OS will often apply that input to moving the window or\n * resizing the window and not deliver it to the application.\n *\n * Specifying NULL for a callback disables hit-testing. Hit-testing is\n * disabled by default.\n *\n * Platforms that don't support this functionality will return -1\n * unconditionally, even if you're attempting to disable hit-testing.\n *\n * Your callback may fire at any time, and its firing does not indicate any\n * specific behavior (for example, on Windows, this certainly might fire when\n * the OS is deciding whether to drag your window, but it fires for lots of\n * other reasons, too, some unrelated to anything you probably care about _and\n * when the mouse isn't actually at the location it is testing_). Since this\n * can fire at any time, you should try to keep your callback efficient,\n * devoid of allocations, etc.\n *\n * \\param window the window to set hit-testing on\n * \\param callback the function to call when doing a hit-test\n * \\param callback_data an app-defined void pointer passed to **callback**\n * \\returns 0 on success or -1 on error (including unsupported); call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_SetWindowHitTest",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "SDL_HitTest REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "callback",
            "callback_data"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Request a window to demand attention from the user.\n *\n * \\param window the window to be flashed\n * \\param operation the flash operation\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_FlashWindow",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "SDL_FlashOperation REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "operation"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Destroy a window.\n *\n * If `window` is NULL, this function will return immediately after setting\n * the SDL error message to \"Invalid window\". See SDL_GetError().\n *\n * \\param window the window to destroy\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateWindow\n * \\sa SDL_CreateWindowFrom\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_DestroyWindow",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Check whether the screensaver is currently enabled.\n *\n * The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2\n * the screensaver was enabled by default.\n *\n * The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.\n *\n * \\returns SDL_TRUE if the screensaver is enabled, SDL_FALSE if it is\n *          disabled.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_DisableScreenSaver\n * \\sa SDL_EnableScreenSaver\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_ScreenSaverEnabled",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Allow the screen to be blanked by a screen saver.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_DisableScreenSaver\n * \\sa SDL_ScreenSaverEnabled\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_EnableScreenSaver",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Prevent the screen from being blanked by a screen saver.\n *\n * If you disable the screensaver, it is automatically re-enabled when SDL\n * quits.\n *\n * The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2\n * the screensaver was enabled by default.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_EnableScreenSaver\n * \\sa SDL_ScreenSaverEnabled\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_DisableScreenSaver",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Dynamically load an OpenGL library.\n *\n * This should be done after initializing the video driver, but before\n * creating any OpenGL windows. If no OpenGL library is loaded, the default\n * library will be loaded upon creation of the first OpenGL window.\n *\n * If you do this, you need to retrieve all of the GL functions used in your\n * program from the dynamic library using SDL_GL_GetProcAddress().\n *\n * \\param path the platform dependent OpenGL library name, or NULL to open the\n *             default OpenGL library\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GL_GetProcAddress\n * \\sa SDL_GL_UnloadLibrary\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GL_LoadLibrary",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "path"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get an OpenGL function by name.\n *\n * If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all\n * GL functions must be retrieved this way. Usually this is used to retrieve\n * function pointers to OpenGL extensions.\n *\n * There are some quirks to looking up OpenGL functions that require some\n * extra care from the application. If you code carefully, you can handle\n * these quirks without any platform-specific code, though:\n *\n * - On Windows, function pointers are specific to the current GL context;\n *   this means you need to have created a GL context and made it current\n *   before calling SDL_GL_GetProcAddress(). If you recreate your context or\n *   create a second context, you should assume that any existing function\n *   pointers aren't valid to use with it. This is (currently) a\n *   Windows-specific limitation, and in practice lots of drivers don't suffer\n *   this limitation, but it is still the way the wgl API is documented to\n *   work and you should expect crashes if you don't respect it. Store a copy\n *   of the function pointers that comes and goes with context lifespan.\n * - On X11, function pointers returned by this function are valid for any\n *   context, and can even be looked up before a context is created at all.\n *   This means that, for at least some common OpenGL implementations, if you\n *   look up a function that doesn't exist, you'll get a non-NULL result that\n *   is _NOT_ safe to call. You must always make sure the function is actually\n *   available for a given GL context before calling it, by checking for the\n *   existence of the appropriate extension with SDL_GL_ExtensionSupported(),\n *   or verifying that the version of OpenGL you're using offers the function\n *   as core functionality.\n * - Some OpenGL drivers, on all platforms, *will* return NULL if a function\n *   isn't supported, but you can't count on this behavior. Check for\n *   extensions you use, and if you get a NULL anyway, act as if that\n *   extension wasn't available. This is probably a bug in the driver, but you\n *   can code defensively for this scenario anyhow.\n * - Just because you're on Linux/Unix, don't assume you'll be using X11.\n *   Next-gen display servers are waiting to replace it, and may or may not\n *   make the same promises about function pointers.\n * - OpenGL function pointers must be declared `APIENTRY` as in the example\n *   code. This will ensure the proper calling convention is followed on\n *   platforms where this matters (Win32) thereby avoiding stack corruption.\n *\n * \\param proc the name of an OpenGL function\n * \\returns a pointer to the named OpenGL function. The returned pointer\n *          should be cast to the appropriate function signature.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GL_ExtensionSupported\n * \\sa SDL_GL_LoadLibrary\n * \\sa SDL_GL_UnloadLibrary\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GL_GetProcAddress",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "proc"
        ],
        "retval": "SDL_FunctionPointer"
    },
    {
        "comment": "/**\n * Get an EGL library function by name.\n *\n * If an EGL library is loaded, this function allows applications to get entry\n * points for EGL functions. This is useful to provide to an EGL API and\n * extension loader.\n *\n * \\param proc the name of an EGL function\n * \\returns a pointer to the named EGL function. The returned pointer should\n *          be cast to the appropriate function signature.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GL_GetCurrentEGLDisplay\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_EGL_GetProcAddress",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "proc"
        ],
        "retval": "SDL_FunctionPointer"
    },
    {
        "comment": "/**\n * Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GL_LoadLibrary\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GL_UnloadLibrary",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Check if an OpenGL extension is supported for the current context.\n *\n * This function operates on the current GL context; you must have created a\n * context and it must be current before calling this function. Do not assume\n * that all contexts you create will have the same set of extensions\n * available, or that recreating an existing context will offer the same\n * extensions again.\n *\n * While it's probably not a massive overhead, this function is not an O(1)\n * operation. Check the extensions you care about after creating the GL\n * context and save that information somewhere instead of calling the function\n * every time you need to know.\n *\n * \\param extension the name of the extension to check\n * \\returns SDL_TRUE if the extension is supported, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GL_ExtensionSupported",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "extension"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Reset all previously set OpenGL context attributes to their default values.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GL_GetAttribute\n * \\sa SDL_GL_SetAttribute\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GL_ResetAttributes",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set an OpenGL window attribute before window creation.\n *\n * This function sets the OpenGL attribute `attr` to `value`. The requested\n * attributes should be set before creating an OpenGL window. You should use\n * SDL_GL_GetAttribute() to check the values after creating the OpenGL\n * context, since the values obtained can differ from the requested ones.\n *\n * \\param attr an SDL_GLattr enum value specifying the OpenGL attribute to set\n * \\param value the desired value for the attribute\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GL_GetAttribute\n * \\sa SDL_GL_ResetAttributes\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GL_SetAttribute",
        "parameter": [
            "SDL_GLattr REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "attr",
            "value"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the actual value for an attribute from the current context.\n *\n * \\param attr an SDL_GLattr enum value specifying the OpenGL attribute to get\n * \\param value a pointer filled in with the current value of `attr`\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GL_ResetAttributes\n * \\sa SDL_GL_SetAttribute\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GL_GetAttribute",
        "parameter": [
            "SDL_GLattr REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "attr",
            "value"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Create an OpenGL context for an OpenGL window, and make it current.\n *\n * Windows users new to OpenGL should note that, for historical reasons, GL\n * functions added after OpenGL version 1.1 are not available by default.\n * Those functions must be loaded at run-time, either with an OpenGL\n * extension-handling library or with SDL_GL_GetProcAddress() and its related\n * functions.\n *\n * SDL_GLContext is an alias for `void *`. It's opaque to the application.\n *\n * \\param window the window to associate with the context\n * \\returns the OpenGL context associated with `window` or NULL on error; call\n *          SDL_GetError() for more details.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GL_DeleteContext\n * \\sa SDL_GL_MakeCurrent\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GL_CreateContext",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "SDL_GLContext"
    },
    {
        "comment": "/**\n * Set up an OpenGL context for rendering into an OpenGL window.\n *\n * The context must have been created with a compatible window.\n *\n * \\param window the window to associate with the context\n * \\param context the OpenGL context to associate with the window\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GL_CreateContext\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GL_MakeCurrent",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "SDL_GLContext REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "context"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the currently active OpenGL window.\n *\n * \\returns the currently active OpenGL window on success or NULL on failure;\n *          call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GL_GetCurrentWindow",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_Window*"
    },
    {
        "comment": "/**\n * Get the currently active OpenGL context.\n *\n * \\returns the currently active OpenGL context or NULL on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GL_MakeCurrent\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GL_GetCurrentContext",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_GLContext"
    },
    {
        "comment": "/**\n * Get the currently active EGL display.\n *\n * \\returns the currently active EGL display or NULL on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_EGL_GetCurrentEGLDisplay",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_EGLDisplay"
    },
    {
        "comment": "/**\n * Get the currently active EGL config.\n *\n * \\returns the currently active EGL config or NULL on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_EGL_GetCurrentEGLConfig",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_EGLConfig"
    },
    {
        "comment": "/**\n * Get the EGL surface associated with the window.\n *\n * \\returns the EGLSurface pointer associated with the window, or NULL on\n *          failure.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_EGL_GetWindowEGLSurface",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "SDL_EGLSurface"
    },
    {
        "comment": "/**\n * Sets the callbacks for defining custom EGLAttrib arrays for EGL\n * initialization.\n *\n * Each callback should return a pointer to an EGL attribute array terminated\n * with EGL_NONE. Callbacks may return NULL pointers to signal an error, which\n * will cause the SDL_CreateWindow process to fail gracefully.\n *\n * The arrays returned by each callback will be appended to the existing\n * attribute arrays defined by SDL.\n *\n * NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.\n *\n * \\param platformAttribCallback Callback for attributes to pass to\n *                               eglGetPlatformDisplay.\n * \\param surfaceAttribCallback Callback for attributes to pass to\n *                              eglCreateSurface.\n * \\param contextAttribCallback Callback for attributes to pass to\n *                              eglCreateContext.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_EGL_SetEGLAttributeCallbacks",
        "parameter": [
            "SDL_EGLAttribArrayCallback REWRITE_NAME",
            "SDL_EGLIntArrayCallback REWRITE_NAME",
            "SDL_EGLIntArrayCallback REWRITE_NAME"
        ],
        "parameter_name": [
            "platformAttribCallback",
            "surfaceAttribCallback",
            "contextAttribCallback"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the size of a window's underlying drawable in pixels.\n *\n * This returns info useful for calling glViewport().\n *\n * This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI\n * drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a\n * platform with high-DPI support (Apple calls this \"Retina\"), and not\n * disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.\n *\n * \\param window the window from which the drawable size should be queried\n * \\param w a pointer to variable for storing the width in pixels, may be NULL\n * \\param h a pointer to variable for storing the height in pixels, may be\n *          NULL\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateWindow\n * \\sa SDL_GetWindowSize\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GL_GetDrawableSize",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "w",
            "h"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set the swap interval for the current OpenGL context.\n *\n * Some systems allow specifying -1 for the interval, to enable adaptive\n * vsync. Adaptive vsync works the same as vsync, but if you've already missed\n * the vertical retrace for a given frame, it swaps buffers immediately, which\n * might be less jarring for the user during occasional framerate drops. If an\n * application requests adaptive vsync and the system does not support it,\n * this function will fail and return -1. In such a case, you should probably\n * retry the call with 1 for the interval.\n *\n * Adaptive vsync is implemented for some glX drivers with\n * GLX_EXT_swap_control_tear, and for some Windows drivers with\n * WGL_EXT_swap_control_tear.\n *\n * Read more on the Khronos wiki:\n * https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync\n *\n * \\param interval 0 for immediate updates, 1 for updates synchronized with\n *                 the vertical retrace, -1 for adaptive vsync\n * \\returns 0 on success or -1 if setting the swap interval is not supported;\n *          call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GL_GetSwapInterval\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GL_SetSwapInterval",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "interval"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the swap interval for the current OpenGL context.\n *\n * If the system can't determine the swap interval, or there isn't a valid\n * current context, this function will set *interval to 0 as a safe default.\n *\n * \\param interval Output interval value. 0 if there is no vertical retrace synchronization, 1 if the buffer\n *          swap is synchronized with the vertical retrace, and -1 if late\n *          swaps happen immediately instead of waiting for the next retrace\n *\n * \\returns 0 on success or -1 error.\n *          call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GL_SetSwapInterval\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GL_GetSwapInterval",
        "parameter": [
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "interval"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Update a window with OpenGL rendering.\n *\n * This is used with double-buffered OpenGL contexts, which are the default.\n *\n * On macOS, make sure you bind 0 to the draw framebuffer before swapping the\n * window, otherwise nothing will happen. If you aren't using\n * glBindFramebuffer(), this is the default and you won't have to do anything\n * extra.\n *\n * \\param window the window to change\n *\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GL_SwapWindow",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Delete an OpenGL context.\n *\n * \\param context the OpenGL context to be deleted\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GL_CreateContext\n */\n",
        "header": "SDL_video.h",
        "name": "SDL_GL_DeleteContext",
        "parameter": [
            "SDL_GLContext REWRITE_NAME"
        ],
        "parameter_name": [
            "context"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the version of SDL that is linked against your program.\n *\n * If you are linking to SDL dynamically, then it is possible that the current\n * version will be different than the version you compiled against. This\n * function returns the current version, while SDL_VERSION() is a macro that\n * tells you what version you compiled with.\n *\n * This function may be called safely at any time, even before SDL_Init().\n *\n * \\param ver the SDL_version structure that contains the version information\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRevision\n */\n",
        "header": "SDL_version.h",
        "name": "SDL_GetVersion",
        "parameter": [
            "SDL_version *REWRITE_NAME"
        ],
        "parameter_name": [
            "ver"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the code revision of SDL that is linked against your program.\n *\n * This value is the revision of the code you are linked with and may be\n * different from the code you are compiling with, which is found in the\n * constant SDL_REVISION.\n *\n * The revision is arbitrary string (a hash value) uniquely identifying the\n * exact revision of the SDL library in use, and is only useful in comparing\n * against other revisions. It is NOT an incrementing number.\n *\n * If SDL wasn't built from a git repository with the appropriate tools, this\n * will return an empty string.\n *\n * Prior to SDL 2.0.16, before development moved to GitHub, this returned a\n * hash for a Mercurial repository.\n *\n * You shouldn't use this function for anything but logging it for debugging\n * purposes. The string is not intended to be reliable in any way.\n *\n * \\returns an arbitrary string, uniquely identifying the exact revision of\n *          the SDL library in use.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetVersion\n */\n",
        "header": "SDL_version.h",
        "name": "SDL_GetRevision",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Create a window that can be shaped with the specified position, dimensions,\n * and flags.\n *\n * \\param title The title of the window, in UTF-8 encoding.\n * \\param x The x position of the window, ::SDL_WINDOWPOS_CENTERED, or\n *          ::SDL_WINDOWPOS_UNDEFINED.\n * \\param y The y position of the window, ::SDL_WINDOWPOS_CENTERED, or\n *          ::SDL_WINDOWPOS_UNDEFINED.\n * \\param w The width of the window.\n * \\param h The height of the window.\n * \\param flags The flags for the window, a mask of SDL_WINDOW_BORDERLESS with\n *              any of the following: ::SDL_WINDOW_OPENGL,\n *              ::SDL_WINDOW_INPUT_GRABBED, ::SDL_WINDOW_HIDDEN,\n *              ::SDL_WINDOW_RESIZABLE, ::SDL_WINDOW_MAXIMIZED,\n *              ::SDL_WINDOW_MINIMIZED, ::SDL_WINDOW_BORDERLESS is always set,\n *              and ::SDL_WINDOW_FULLSCREEN is always unset.\n * \\return the window created, or NULL if window creation failed.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_DestroyWindow\n */\n",
        "header": "SDL_shape.h",
        "name": "SDL_CreateShapedWindow",
        "parameter": [
            "const char *REWRITE_NAME",
            "unsigned int REWRITE_NAME",
            "unsigned int REWRITE_NAME",
            "unsigned int REWRITE_NAME",
            "unsigned int REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "title",
            "x",
            "y",
            "w",
            "h",
            "flags"
        ],
        "retval": "SDL_Window*"
    },
    {
        "comment": "/**\n * Return whether the given window is a shaped window.\n *\n * \\param window The window to query for being shaped.\n * \\return SDL_TRUE if the window is a window that can be shaped, SDL_FALSE if\n *         the window is unshaped or NULL.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateShapedWindow\n */\n",
        "header": "SDL_shape.h",
        "name": "SDL_IsShapedWindow",
        "parameter": [
            "const SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Set the shape and parameters of a shaped window.\n *\n * \\param window The shaped window whose parameters should be set.\n * \\param shape A surface encoding the desired shape for the window.\n * \\param shape_mode The parameters to set for the shaped window.\n * \\return 0 on success, SDL_INVALID_SHAPE_ARGUMENT on an invalid shape\n *         argument, or SDL_NONSHAPEABLE_WINDOW if the SDL_Window given does\n *         not reference a valid shaped window.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_WindowShapeMode\n * \\sa SDL_GetShapedWindowMode\n */\n",
        "header": "SDL_shape.h",
        "name": "SDL_SetWindowShape",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "SDL_Surface *REWRITE_NAME",
            "SDL_WindowShapeMode *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "shape",
            "shape_mode"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the shape parameters of a shaped window.\n *\n * \\param window The shaped window whose parameters should be retrieved.\n * \\param shape_mode An empty shape-mode structure to fill, or NULL to check\n *                   whether the window has a shape.\n * \\return 0 if the window has a shape and, provided shape_mode was not NULL,\n *         shape_mode has been filled with the mode data,\n *         SDL_NONSHAPEABLE_WINDOW if the SDL_Window given is not a shaped\n *         window, or SDL_WINDOW_LACKS_SHAPE if the SDL_Window given is a\n *         shapeable window currently lacking a shape.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_WindowShapeMode\n * \\sa SDL_SetWindowShape\n */\n",
        "header": "SDL_shape.h",
        "name": "SDL_GetShapedWindowMode",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "SDL_WindowShapeMode *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "shape_mode"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the name of the platform.\n *\n * Here are the names returned for some (but not all) supported platforms:\n *\n * - \"Windows\"\n * - \"macOS\"\n * - \"Linux\"\n * - \"iOS\"\n * - \"Android\"\n *\n * \\returns the name of the platform. If the correct platform name is not\n *          available, returns a string beginning with the text \"Unknown\".\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_platform.h",
        "name": "SDL_GetPlatform",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Set the SDL error message for the current thread.\n *\n * Calling this function will replace any previous error message that was set.\n *\n * This function always returns -1, since SDL frequently uses -1 to signify an\n * failing result, leading to this idiom:\n *\n * ```c\n * if (error_code) {\n *     return SDL_SetError(\"This operation has failed: %d\", error_code);\n * }\n * ```\n *\n * \\param fmt a printf()-style message format string\n * \\param ... additional parameters matching % tokens in the `fmt` string, if\n *            any\n * \\returns always -1.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ClearError\n * \\sa SDL_GetError\n */\n",
        "header": "SDL_error.h",
        "name": "SDL_SetError",
        "parameter": [
            "SDL_PRINTF_FORMAT_STRING const char *REWRITE_NAME",
            "..."
        ],
        "parameter_name": [
            "fmt",
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Retrieve a message about the last error that occurred on the current\n * thread.\n *\n * It is possible for multiple errors to occur before calling SDL_GetError().\n * Only the last error is returned.\n *\n * The message is only applicable when an SDL function has signaled an error.\n * You must check the return values of SDL function calls to determine when to\n * appropriately call SDL_GetError(). You should *not* use the results of\n * SDL_GetError() to decide if an error has occurred! Sometimes SDL will set\n * an error string even when reporting success.\n *\n * SDL will *not* clear the error string for successful API calls. You *must*\n * check return values for failure cases before you can assume the error\n * string applies.\n *\n * Error strings are set per-thread, so an error set in a different thread\n * will not interfere with the current thread's operation.\n *\n * The returned string is internally allocated and must not be freed by the\n * application.\n *\n * \\returns a message with information about the specific error that occurred,\n *          or an empty string if there hasn't been an error message set since\n *          the last call to SDL_ClearError(). The message is only applicable\n *          when an SDL function has signaled an error. You must check the\n *          return values of SDL function calls to determine when to\n *          appropriately call SDL_GetError().\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ClearError\n * \\sa SDL_SetError\n */\n",
        "header": "SDL_error.h",
        "name": "SDL_GetError",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the last error message that was set for the current thread.\n *\n * This allows the caller to copy the error string into a provided buffer, but\n * otherwise operates exactly the same as SDL_GetError().\n *\n * \\param errstr A buffer to fill with the last error message that was set for\n *               the current thread\n * \\param maxlen The size of the buffer pointed to by the errstr parameter\n * \\returns the pointer passed in as the `errstr` parameter.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetError\n */\n",
        "header": "SDL_error.h",
        "name": "SDL_GetErrorMsg",
        "parameter": [
            "char *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "errstr",
            "maxlen"
        ],
        "retval": "char*"
    },
    {
        "comment": "/**\n * Clear any previous error message for this thread.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetError\n * \\sa SDL_SetError\n */\n",
        "header": "SDL_error.h",
        "name": "SDL_ClearError",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n *  \\name Internal error functions\n *\n *  \\internal\n *  Private error reporting function - used internally.\n */\n",
        "header": "SDL_error.h",
        "name": "SDL_Error",
        "parameter": [
            "SDL_errorcode REWRITE_NAME"
        ],
        "parameter_name": [
            "code"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Allocate a new RGB surface with a specific pixel format.\n *\n * \\param width the width of the surface\n * \\param height the height of the surface\n * \\param format the SDL_PixelFormatEnum for the new surface's pixel format.\n * \\returns the new SDL_Surface structure that is created or NULL if it fails;\n *          call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateSurfaceFrom\n * \\sa SDL_DestroySurface\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_CreateSurface",
        "parameter": [
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "width",
            "height",
            "format"
        ],
        "retval": "SDL_Surface*"
    },
    {
        "comment": "/**\n * Allocate a new RGB surface with with a specific pixel format and existing\n * pixel data.\n *\n * No copy is made of the pixel data. Pixel data is not managed automatically;\n * you must free the surface before you free the pixel data.\n *\n * \\param pixels a pointer to existing pixel data\n * \\param width the width of the surface\n * \\param height the height of the surface\n * \\param pitch the pitch of the surface in bytes\n * \\param format the SDL_PixelFormatEnum for the new surface's pixel format.\n * \\returns the new SDL_Surface structure that is created or NULL if it fails;\n *          call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateSurface\n * \\sa SDL_DestroySurface\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_CreateSurfaceFrom",
        "parameter": [
            "void *REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "pixels",
            "width",
            "height",
            "pitch",
            "format"
        ],
        "retval": "SDL_Surface*"
    },
    {
        "comment": "/**\n * Free an RGB surface.\n *\n * It is safe to pass NULL to this function.\n *\n * \\param surface the SDL_Surface to free.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateSurface\n * \\sa SDL_CreateSurfaceFrom\n * \\sa SDL_LoadBMP\n * \\sa SDL_LoadBMP_RW\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_DestroySurface",
        "parameter": [
            "SDL_Surface *REWRITE_NAME"
        ],
        "parameter_name": [
            "surface"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Set the palette used by a surface.\n *\n * A single palette can be shared with many surfaces.\n *\n * \\param surface the SDL_Surface structure to update\n * \\param palette the SDL_Palette structure to use\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_SetSurfacePalette",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "SDL_Palette *REWRITE_NAME"
        ],
        "parameter_name": [
            "surface",
            "palette"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set up a surface for directly accessing the pixels.\n *\n * Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to\n * and read from `surface->pixels`, using the pixel format stored in\n * `surface->format`. Once you are done accessing the surface, you should use\n * SDL_UnlockSurface() to release it.\n *\n * Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to\n * 0, then you can read and write to the surface at any time, and the pixel\n * format of the surface will not change.\n *\n * \\param surface the SDL_Surface structure to be locked\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_MUSTLOCK\n * \\sa SDL_UnlockSurface\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_LockSurface",
        "parameter": [
            "SDL_Surface *REWRITE_NAME"
        ],
        "parameter_name": [
            "surface"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Release a surface after directly accessing the pixels.\n *\n * \\param surface the SDL_Surface structure to be unlocked\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_LockSurface\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_UnlockSurface",
        "parameter": [
            "SDL_Surface *REWRITE_NAME"
        ],
        "parameter_name": [
            "surface"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Load a BMP image from a seekable SDL data stream.\n *\n * The new surface should be freed with SDL_DestroySurface(). Not doing so will\n * result in a memory leak.\n *\n * src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile.\n * Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap\n * from a file, convert it to an SDL_Surface and then close the file.\n *\n * \\param src the data stream for the surface\n * \\param freesrc non-zero to close the stream after being read\n * \\returns a pointer to a new SDL_Surface structure or NULL if there was an\n *          error; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_DestroySurface\n * \\sa SDL_RWFromFile\n * \\sa SDL_LoadBMP\n * \\sa SDL_SaveBMP_RW\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_LoadBMP_RW",
        "parameter": [
            "SDL_RWops *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "src",
            "freesrc"
        ],
        "retval": "SDL_Surface*"
    },
    {
        "comment": "/**\n * Save a surface to a seekable SDL data stream in BMP format.\n *\n * Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the\n * BMP directly. Other RGB formats with 8-bit or higher get converted to a\n * 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit\n * surface before they are saved. YUV and paletted 1-bit and 4-bit formats are\n * not supported.\n *\n * \\param surface the SDL_Surface structure containing the image to be saved\n * \\param dst a data stream to save to\n * \\param freedst non-zero to close the stream after being written\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_LoadBMP_RW\n * \\sa SDL_SaveBMP\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_SaveBMP_RW",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "SDL_RWops *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "surface",
            "dst",
            "freedst"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set the RLE acceleration hint for a surface.\n *\n * If RLE is enabled, color key and alpha blending blits are much faster, but\n * the surface must be locked before directly accessing the pixels.\n *\n * \\param surface the SDL_Surface structure to optimize\n * \\param flag 0 to disable, non-zero to enable RLE acceleration\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_BlitSurface\n * \\sa SDL_LockSurface\n * \\sa SDL_UnlockSurface\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_SetSurfaceRLE",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "surface",
            "flag"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Returns whether the surface is RLE enabled\n *\n * It is safe to pass a NULL `surface` here; it will return SDL_FALSE.\n *\n * \\param surface the SDL_Surface structure to query\n * \\returns SDL_TRUE if the surface is RLE enabled, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetSurfaceRLE\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_SurfaceHasRLE",
        "parameter": [
            "SDL_Surface *REWRITE_NAME"
        ],
        "parameter_name": [
            "surface"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Set the color key (transparent pixel) in a surface.\n *\n * The color key defines a pixel value that will be treated as transparent in\n * a blit. For example, one can use this to specify that cyan pixels should be\n * considered transparent, and therefore not rendered.\n *\n * It is a pixel of the format used by the surface, as generated by\n * SDL_MapRGB().\n *\n * RLE acceleration can substantially speed up blitting of images with large\n * horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.\n *\n * \\param surface the SDL_Surface structure to update\n * \\param flag SDL_TRUE to enable color key, SDL_FALSE to disable color key\n * \\param key the transparent pixel\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_BlitSurface\n * \\sa SDL_GetSurfaceColorKey\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_SetSurfaceColorKey",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "int REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "surface",
            "flag",
            "key"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Returns whether the surface has a color key\n *\n * It is safe to pass a NULL `surface` here; it will return SDL_FALSE.\n *\n * \\param surface the SDL_Surface structure to query\n * \\return SDL_TRUE if the surface has a color key, SDL_FALSE otherwise.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetSurfaceColorKey\n * \\sa SDL_GetSurfaceColorKey\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_SurfaceHasColorKey",
        "parameter": [
            "SDL_Surface *REWRITE_NAME"
        ],
        "parameter_name": [
            "surface"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Get the color key (transparent pixel) for a surface.\n *\n * The color key is a pixel of the format used by the surface, as generated by\n * SDL_MapRGB().\n *\n * If the surface doesn't have color key enabled this function returns -1.\n *\n * \\param surface the SDL_Surface structure to query\n * \\param key a pointer filled in with the transparent pixel\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_BlitSurface\n * \\sa SDL_SetSurfaceColorKey\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_GetSurfaceColorKey",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "Uint32 *REWRITE_NAME"
        ],
        "parameter_name": [
            "surface",
            "key"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set an additional color value multiplied into blit operations.\n *\n * When this surface is blitted, during the blit operation each source color\n * channel is modulated by the appropriate color value according to the\n * following formula:\n *\n * `srcC = srcC * (color / 255)`\n *\n * \\param surface the SDL_Surface structure to update\n * \\param r the red color value multiplied into blit operations\n * \\param g the green color value multiplied into blit operations\n * \\param b the blue color value multiplied into blit operations\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetSurfaceColorMod\n * \\sa SDL_SetSurfaceAlphaMod\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_SetSurfaceColorMod",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "Uint8 REWRITE_NAME"
        ],
        "parameter_name": [
            "surface",
            "r",
            "g",
            "b"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the additional color value multiplied into blit operations.\n *\n * \\param surface the SDL_Surface structure to query\n * \\param r a pointer filled in with the current red color value\n * \\param g a pointer filled in with the current green color value\n * \\param b a pointer filled in with the current blue color value\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetSurfaceAlphaMod\n * \\sa SDL_SetSurfaceColorMod\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_GetSurfaceColorMod",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "Uint8 *REWRITE_NAME",
            "Uint8 *REWRITE_NAME",
            "Uint8 *REWRITE_NAME"
        ],
        "parameter_name": [
            "surface",
            "r",
            "g",
            "b"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set an additional alpha value used in blit operations.\n *\n * When this surface is blitted, during the blit operation the source alpha\n * value is modulated by this alpha value according to the following formula:\n *\n * `srcA = srcA * (alpha / 255)`\n *\n * \\param surface the SDL_Surface structure to update\n * \\param alpha the alpha value multiplied into blit operations\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetSurfaceAlphaMod\n * \\sa SDL_SetSurfaceColorMod\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_SetSurfaceAlphaMod",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "Uint8 REWRITE_NAME"
        ],
        "parameter_name": [
            "surface",
            "alpha"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the additional alpha value used in blit operations.\n *\n * \\param surface the SDL_Surface structure to query\n * \\param alpha a pointer filled in with the current alpha value\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetSurfaceColorMod\n * \\sa SDL_SetSurfaceAlphaMod\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_GetSurfaceAlphaMod",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "Uint8 *REWRITE_NAME"
        ],
        "parameter_name": [
            "surface",
            "alpha"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set the blend mode used for blit operations.\n *\n * To copy a surface to another surface (or texture) without blending with the\n * existing data, the blendmode of the SOURCE surface should be set to\n * `SDL_BLENDMODE_NONE`.\n *\n * \\param surface the SDL_Surface structure to update\n * \\param blendMode the SDL_BlendMode to use for blit blending\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetSurfaceBlendMode\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_SetSurfaceBlendMode",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "SDL_BlendMode REWRITE_NAME"
        ],
        "parameter_name": [
            "surface",
            "blendMode"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the blend mode used for blit operations.\n *\n * \\param surface the SDL_Surface structure to query\n * \\param blendMode a pointer filled in with the current SDL_BlendMode\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetSurfaceBlendMode\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_GetSurfaceBlendMode",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "SDL_BlendMode *REWRITE_NAME"
        ],
        "parameter_name": [
            "surface",
            "blendMode"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set the clipping rectangle for a surface.\n *\n * When `surface` is the destination of a blit, only the area within the clip\n * rectangle is drawn into.\n *\n * Note that blits are automatically clipped to the edges of the source and\n * destination surfaces.\n *\n * \\param surface the SDL_Surface structure to be clipped\n * \\param rect the SDL_Rect structure representing the clipping rectangle, or\n *             NULL to disable clipping\n * \\returns SDL_TRUE if the rectangle intersects the surface, otherwise\n *          SDL_FALSE and blits will be completely clipped.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_BlitSurface\n * \\sa SDL_GetSurfaceClipRect\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_SetSurfaceClipRect",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "surface",
            "rect"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Get the clipping rectangle for a surface.\n *\n * When `surface` is the destination of a blit, only the area within the clip\n * rectangle is drawn into.\n *\n * \\param surface the SDL_Surface structure representing the surface to be\n *                clipped\n * \\param rect an SDL_Rect structure filled in with the clipping rectangle for\n *             the surface\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_BlitSurface\n * \\sa SDL_SetSurfaceClipRect\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_GetSurfaceClipRect",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "surface",
            "rect"
        ],
        "retval": "void"
    },
    {
        "comment": "/*\n * Creates a new surface identical to the existing surface.\n *\n * The returned surface should be freed with SDL_DestroySurface().\n *\n * \\param surface the surface to duplicate.\n * \\returns a copy of the surface, or NULL on failure; call SDL_GetError() for\n *          more information.\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_DuplicateSurface",
        "parameter": [
            "SDL_Surface *REWRITE_NAME"
        ],
        "parameter_name": [
            "surface"
        ],
        "retval": "SDL_Surface*"
    },
    {
        "comment": "/**\n * Copy an existing surface to a new surface of the specified format.\n *\n * This function is used to optimize images for faster *repeat* blitting. This\n * is accomplished by converting the original and storing the result as a new\n * surface. The new, optimized surface can then be used as the source for\n * future blits, making them faster.\n *\n * \\param surface the existing SDL_Surface structure to convert\n * \\param format the SDL_PixelFormat structure that the new surface is\n *               optimized for\n * \\returns the new SDL_Surface structure that is created or NULL if it fails;\n *          call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreatePixelFormat\n * \\sa SDL_ConvertSurfaceFormat\n * \\sa SDL_CreateSurface\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_ConvertSurface",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "const SDL_PixelFormat *REWRITE_NAME"
        ],
        "parameter_name": [
            "surface",
            "format"
        ],
        "retval": "SDL_Surface*"
    },
    {
        "comment": "/**\n * Copy an existing surface to a new surface of the specified format enum.\n *\n * This function operates just like SDL_ConvertSurface(), but accepts an\n * SDL_PixelFormatEnum value instead of an SDL_PixelFormat structure. As such,\n * it might be easier to call but it doesn't have access to palette\n * information for the destination surface, in case that would be important.\n *\n * \\param surface the existing SDL_Surface structure to convert\n * \\param pixel_format the SDL_PixelFormatEnum that the new surface is\n *                     optimized for\n * \\returns the new SDL_Surface structure that is created or NULL if it fails;\n *          call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreatePixelFormat\n * \\sa SDL_ConvertSurface\n * \\sa SDL_CreateSurface\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_ConvertSurfaceFormat",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "surface",
            "pixel_format"
        ],
        "retval": "SDL_Surface*"
    },
    {
        "comment": "/**\n * Copy a block of pixels of one format to another format.\n *\n * \\param width the width of the block to copy, in pixels\n * \\param height the height of the block to copy, in pixels\n * \\param src_format an SDL_PixelFormatEnum value of the `src` pixels format\n * \\param src a pointer to the source pixels\n * \\param src_pitch the pitch of the source pixels, in bytes\n * \\param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format\n * \\param dst a pointer to be filled in with new pixel data\n * \\param dst_pitch the pitch of the destination pixels, in bytes\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_ConvertPixels",
        "parameter": [
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "Uint32 REWRITE_NAME",
            "const void *REWRITE_NAME",
            "int REWRITE_NAME",
            "Uint32 REWRITE_NAME",
            "void *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "width",
            "height",
            "src_format",
            "src",
            "src_pitch",
            "dst_format",
            "dst",
            "dst_pitch"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Premultiply the alpha on a block of pixels.\n *\n * This is safe to use with src == dst, but not for other overlapping areas.\n *\n * This function is currently only implemented for SDL_PIXELFORMAT_ARGB8888.\n *\n * \\param width the width of the block to convert, in pixels\n * \\param height the height of the block to convert, in pixels\n * \\param src_format an SDL_PixelFormatEnum value of the `src` pixels format\n * \\param src a pointer to the source pixels\n * \\param src_pitch the pitch of the source pixels, in bytes\n * \\param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format\n * \\param dst a pointer to be filled in with premultiplied pixel data\n * \\param dst_pitch the pitch of the destination pixels, in bytes\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_PremultiplyAlpha",
        "parameter": [
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "Uint32 REWRITE_NAME",
            "const void *REWRITE_NAME",
            "int REWRITE_NAME",
            "Uint32 REWRITE_NAME",
            "void *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "width",
            "height",
            "src_format",
            "src",
            "src_pitch",
            "dst_format",
            "dst",
            "dst_pitch"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Perform a fast fill of a rectangle with a specific color.\n *\n * `color` should be a pixel of the format used by the surface, and can be\n * generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an\n * alpha component then the destination is simply filled with that alpha\n * information, no blending takes place.\n *\n * If there is a clip rectangle set on the destination (set via\n * SDL_SetSurfaceClipRect()), then this function will fill based on the intersection\n * of the clip rectangle and `rect`.\n *\n * \\param dst the SDL_Surface structure that is the drawing target\n * \\param rect the SDL_Rect structure representing the rectangle to fill, or\n *             NULL to fill the entire surface\n * \\param color the color to fill with\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_FillSurfaceRects\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_FillSurfaceRect",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "dst",
            "rect",
            "color"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Perform a fast fill of a set of rectangles with a specific color.\n *\n * `color` should be a pixel of the format used by the surface, and can be\n * generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an\n * alpha component then the destination is simply filled with that alpha\n * information, no blending takes place.\n *\n * If there is a clip rectangle set on the destination (set via\n * SDL_SetSurfaceClipRect()), then this function will fill based on the intersection\n * of the clip rectangle and `rect`.\n *\n * \\param dst the SDL_Surface structure that is the drawing target\n * \\param rects an array of SDL_Rects representing the rectangles to fill.\n * \\param count the number of rectangles in the array\n * \\param color the color to fill with\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_FillSurfaceRect\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_FillSurfaceRects",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "int REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "dst",
            "rects",
            "count",
            "color"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n *  Performs a fast blit from the source surface to the destination surface.\n *\n *  This assumes that the source and destination rectangles are\n *  the same size.  If either \\c srcrect or \\c dstrect are NULL, the entire\n *  surface (\\c src or \\c dst) is copied.  The final blit rectangles are saved\n *  in \\c srcrect and \\c dstrect after all clipping is performed.\n *\n *  The blit function should not be called on a locked surface.\n *\n *  The blit semantics for surfaces with and without blending and colorkey\n *  are defined as follows:\n *  \\verbatim\n    RGBA->RGB:\n      Source surface blend mode set to SDL_BLENDMODE_BLEND:\n        alpha-blend (using the source alpha-channel and per-surface alpha)\n        SDL_SRCCOLORKEY ignored.\n      Source surface blend mode set to SDL_BLENDMODE_NONE:\n        copy RGB.\n        if SDL_SRCCOLORKEY set, only copy the pixels matching the\n        RGB values of the source color key, ignoring alpha in the\n        comparison.\n\n    RGB->RGBA:\n      Source surface blend mode set to SDL_BLENDMODE_BLEND:\n        alpha-blend (using the source per-surface alpha)\n      Source surface blend mode set to SDL_BLENDMODE_NONE:\n        copy RGB, set destination alpha to source per-surface alpha value.\n      both:\n        if SDL_SRCCOLORKEY set, only copy the pixels matching the\n        source color key.\n\n    RGBA->RGBA:\n      Source surface blend mode set to SDL_BLENDMODE_BLEND:\n        alpha-blend (using the source alpha-channel and per-surface alpha)\n        SDL_SRCCOLORKEY ignored.\n      Source surface blend mode set to SDL_BLENDMODE_NONE:\n        copy all of RGBA to the destination.\n        if SDL_SRCCOLORKEY set, only copy the pixels matching the\n        RGB values of the source color key, ignoring alpha in the\n        comparison.\n\n    RGB->RGB:\n      Source surface blend mode set to SDL_BLENDMODE_BLEND:\n        alpha-blend (using the source per-surface alpha)\n      Source surface blend mode set to SDL_BLENDMODE_NONE:\n        copy RGB.\n      both:\n        if SDL_SRCCOLORKEY set, only copy the pixels matching the\n        source color key.\n    \\endverbatim\n *\n * \\param src the SDL_Surface structure to be copied from\n * \\param srcrect the SDL_Rect structure representing the rectangle to be\n *                copied, or NULL to copy the entire surface\n * \\param dst the SDL_Surface structure that is the blit target\n * \\param dstrect the SDL_Rect structure representing the rectangle that is\n *                copied into\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_BlitSurface\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_BlitSurface",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "SDL_Surface *REWRITE_NAME",
            "SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "src",
            "srcrect",
            "dst",
            "dstrect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Perform low-level surface blitting only.\n *\n * This is a semi-private blit function and it performs low-level surface\n * blitting, assuming the input rectangles have already been clipped.\n *\n * \\param src the SDL_Surface structure to be copied from\n * \\param srcrect the SDL_Rect structure representing the rectangle to be\n *                copied, or NULL to copy the entire surface\n * \\param dst the SDL_Surface structure that is the blit target\n * \\param dstrect the SDL_Rect structure representing the rectangle that is\n *                copied into\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_BlitSurface\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_BlitSurfaceUnchecked",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "SDL_Rect *REWRITE_NAME",
            "SDL_Surface *REWRITE_NAME",
            "SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "src",
            "srcrect",
            "dst",
            "dstrect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Perform a fast, low quality, stretch blit between two surfaces of the same\n * format.\n *\n * Please use SDL_BlitScaled() instead.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_SoftStretch",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "SDL_Surface *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "src",
            "srcrect",
            "dst",
            "dstrect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Perform bilinear scaling between two surfaces of the same format, 32BPP.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_SoftStretchLinear",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "SDL_Surface *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "src",
            "srcrect",
            "dst",
            "dstrect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Perform a scaled surface copy to a destination surface.\n *\n * \\param src the SDL_Surface structure to be copied from\n * \\param srcrect the SDL_Rect structure representing the rectangle to be\n *                copied\n * \\param dst the SDL_Surface structure that is the blit target\n * \\param dstrect the SDL_Rect structure representing the rectangle that is\n *                copied into\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_BlitScaled\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_BlitSurfaceScaled",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "const SDL_Rect *REWRITE_NAME",
            "SDL_Surface *REWRITE_NAME",
            "SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "src",
            "srcrect",
            "dst",
            "dstrect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Perform low-level surface scaled blitting only.\n *\n * This is a semi-private function and it performs low-level surface blitting,\n * assuming the input rectangles have already been clipped.\n *\n * \\param src the SDL_Surface structure to be copied from\n * \\param srcrect the SDL_Rect structure representing the rectangle to be\n *                copied\n * \\param dst the SDL_Surface structure that is the blit target\n * \\param dstrect the SDL_Rect structure representing the rectangle that is\n *                copied into\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_BlitScaled\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_BlitSurfaceUncheckedScaled",
        "parameter": [
            "SDL_Surface *REWRITE_NAME",
            "SDL_Rect *REWRITE_NAME",
            "SDL_Surface *REWRITE_NAME",
            "SDL_Rect *REWRITE_NAME"
        ],
        "parameter_name": [
            "src",
            "srcrect",
            "dst",
            "dstrect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set the YUV conversion mode\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_SetYUVConversionMode",
        "parameter": [
            "SDL_YUV_CONVERSION_MODE REWRITE_NAME"
        ],
        "parameter_name": [
            "mode"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the YUV conversion mode\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_GetYUVConversionMode",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_YUV_CONVERSION_MODE"
    },
    {
        "comment": "/**\n * Get the YUV conversion mode, returning the correct mode for the resolution\n * when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_surface.h",
        "name": "SDL_GetYUVConversionModeForResolution",
        "parameter": [
            "int REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "width",
            "height"
        ],
        "retval": "SDL_YUV_CONVERSION_MODE"
    },
    {
        "comment": "/**\n * Initialize the HIDAPI library.\n *\n * This function initializes the HIDAPI library. Calling it is not strictly\n * necessary, as it will be called automatically by SDL_hid_enumerate() and\n * any of the SDL_hid_open_*() functions if it is needed. This function should\n * be called at the beginning of execution however, if there is a chance of\n * HIDAPI handles being opened by different threads simultaneously.\n *\n * Each call to this function should have a matching call to SDL_hid_exit()\n *\n * \\returns 0 on success and -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_hid_exit\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_init",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Finalize the HIDAPI library.\n *\n * This function frees all of the static data associated with HIDAPI. It\n * should be called at the end of execution to avoid memory leaks.\n *\n * \\returns 0 on success and -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_hid_init\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_exit",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Check to see if devices may have been added or removed.\n *\n * Enumerating the HID devices is an expensive operation, so you can call this\n * to see if there have been any system device changes since the last call to\n * this function. A change in the counter returned doesn't necessarily mean\n * that anything has changed, but you can call SDL_hid_enumerate() to get an\n * updated device list.\n *\n * Calling this function for the first time may cause a thread or other system\n * resource to be allocated to track device change notifications.\n *\n * \\returns a change counter that is incremented with each potential device\n *          change, or 0 if device change detection isn't available.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_hid_enumerate\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_device_change_count",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "Uint32"
    },
    {
        "comment": "/**\n * Enumerate the HID Devices.\n *\n * This function returns a linked list of all the HID devices attached to the\n * system which match vendor_id and product_id. If `vendor_id` is set to 0\n * then any vendor matches. If `product_id` is set to 0 then any product\n * matches. If `vendor_id` and `product_id` are both set to 0, then all HID\n * devices will be returned.\n *\n * \\param vendor_id The Vendor ID (VID) of the types of device to open.\n * \\param product_id The Product ID (PID) of the types of device to open.\n * \\returns a pointer to a linked list of type SDL_hid_device_info, containing\n *          information about the HID devices attached to the system, or NULL\n *          in the case of failure. Free this linked list by calling\n *          SDL_hid_free_enumeration().\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_hid_device_change_count\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_enumerate",
        "parameter": [
            "unsigned short REWRITE_NAME",
            "unsigned short REWRITE_NAME"
        ],
        "parameter_name": [
            "vendor_id",
            "product_id"
        ],
        "retval": "SDL_hid_device_info*"
    },
    {
        "comment": "/**\n * Free an enumeration Linked List\n *\n * This function frees a linked list created by SDL_hid_enumerate().\n *\n * \\param devs Pointer to a list of struct_device returned from\n *             SDL_hid_enumerate().\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_free_enumeration",
        "parameter": [
            "SDL_hid_device_info *REWRITE_NAME"
        ],
        "parameter_name": [
            "devs"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally\n * a serial number.\n *\n * If `serial_number` is NULL, the first device with the specified VID and PID\n * is opened.\n *\n * \\param vendor_id The Vendor ID (VID) of the device to open.\n * \\param product_id The Product ID (PID) of the device to open.\n * \\param serial_number The Serial Number of the device to open (Optionally\n *                      NULL).\n * \\returns a pointer to a SDL_hid_device object on success or NULL on\n *          failure.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_open",
        "parameter": [
            "unsigned short REWRITE_NAME",
            "unsigned short REWRITE_NAME",
            "const wchar_t *REWRITE_NAME"
        ],
        "parameter_name": [
            "vendor_id",
            "product_id",
            "serial_number"
        ],
        "retval": "SDL_hid_device*"
    },
    {
        "comment": "/**\n * Open a HID device by its path name.\n *\n * The path name be determined by calling SDL_hid_enumerate(), or a\n * platform-specific path name can be used (eg: /dev/hidraw0 on Linux).\n *\n * \\param path The path name of the device to open\n * \\returns a pointer to a SDL_hid_device object on success or NULL on\n *          failure.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_open_path",
        "parameter": [
            "const char *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "path",
            "bExclusive"
        ],
        "retval": "SDL_hid_device*"
    },
    {
        "comment": "/**\n * Write an Output report to a HID device.\n *\n * The first byte of `data` must contain the Report ID. For devices which only\n * support a single report, this must be set to 0x0. The remaining bytes\n * contain the report data. Since the Report ID is mandatory, calls to\n * SDL_hid_write() will always contain one more byte than the report contains.\n * For example, if a hid report is 16 bytes long, 17 bytes must be passed to\n * SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),\n * followed by the report data (16 bytes). In this example, the length passed\n * in would be 17.\n *\n * SDL_hid_write() will send the data on the first OUT endpoint, if one\n * exists. If it does not, it will send the data through the Control Endpoint\n * (Endpoint 0).\n *\n * \\param dev A device handle returned from SDL_hid_open().\n * \\param data The data to send, including the report number as the first\n *             byte.\n * \\param length The length in bytes of the data to send.\n * \\returns the actual number of bytes written and -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_write",
        "parameter": [
            "SDL_hid_device *REWRITE_NAME",
            "const unsigned char *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "dev",
            "data",
            "length"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Read an Input report from a HID device with timeout.\n *\n * Input reports are returned to the host through the INTERRUPT IN endpoint.\n * The first byte will contain the Report number if the device uses numbered\n * reports.\n *\n * \\param dev A device handle returned from SDL_hid_open().\n * \\param data A buffer to put the read data into.\n * \\param length The number of bytes to read. For devices with multiple\n *               reports, make sure to read an extra byte for the report\n *               number.\n * \\param milliseconds timeout in milliseconds or -1 for blocking wait.\n * \\returns the actual number of bytes read and -1 on error. If no packet was\n *          available to be read within the timeout period, this function\n *          returns 0.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_read_timeout",
        "parameter": [
            "SDL_hid_device *REWRITE_NAME",
            "unsigned char *REWRITE_NAME",
            "size_t REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "dev",
            "data",
            "length",
            "milliseconds"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Read an Input report from a HID device.\n *\n * Input reports are returned to the host through the INTERRUPT IN endpoint.\n * The first byte will contain the Report number if the device uses numbered\n * reports.\n *\n * \\param dev A device handle returned from SDL_hid_open().\n * \\param data A buffer to put the read data into.\n * \\param length The number of bytes to read. For devices with multiple\n *               reports, make sure to read an extra byte for the report\n *               number.\n * \\returns the actual number of bytes read and -1 on error. If no packet was\n *          available to be read and the handle is in non-blocking mode, this\n *          function returns 0.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_read",
        "parameter": [
            "SDL_hid_device *REWRITE_NAME",
            "unsigned char *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "dev",
            "data",
            "length"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set the device handle to be non-blocking.\n *\n * In non-blocking mode calls to SDL_hid_read() will return immediately with a\n * value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()\n * will wait (block) until there is data to read before returning.\n *\n * Nonblocking can be turned on and off at any time.\n *\n * \\param dev A device handle returned from SDL_hid_open().\n * \\param nonblock enable or not the nonblocking reads - 1 to enable\n *                 nonblocking - 0 to disable nonblocking.\n * \\returns 0 on success and -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_set_nonblocking",
        "parameter": [
            "SDL_hid_device *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "dev",
            "nonblock"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Send a Feature report to the device.\n *\n * Feature reports are sent over the Control endpoint as a Set_Report\n * transfer. The first byte of `data` must contain the Report ID. For devices\n * which only support a single report, this must be set to 0x0. The remaining\n * bytes contain the report data. Since the Report ID is mandatory, calls to\n * SDL_hid_send_feature_report() will always contain one more byte than the\n * report contains. For example, if a hid report is 16 bytes long, 17 bytes\n * must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for\n * devices which do not use numbered reports), followed by the report data (16\n * bytes). In this example, the length passed in would be 17.\n *\n * \\param dev A device handle returned from SDL_hid_open().\n * \\param data The data to send, including the report number as the first\n *             byte.\n * \\param length The length in bytes of the data to send, including the report\n *               number.\n * \\returns the actual number of bytes written and -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_send_feature_report",
        "parameter": [
            "SDL_hid_device *REWRITE_NAME",
            "const unsigned char *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "dev",
            "data",
            "length"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get a feature report from a HID device.\n *\n * Set the first byte of `data` to the Report ID of the report to be read.\n * Make sure to allow space for this extra byte in `data`. Upon return, the\n * first byte will still contain the Report ID, and the report data will start\n * in data[1].\n *\n * \\param dev A device handle returned from SDL_hid_open().\n * \\param data A buffer to put the read data into, including the Report ID.\n *             Set the first byte of `data` to the Report ID of the report to\n *             be read, or set it to zero if your device does not use numbered\n *             reports.\n * \\param length The number of bytes to read, including an extra byte for the\n *               report ID. The buffer can be longer than the actual report.\n * \\returns the number of bytes read plus one for the report ID (which is\n *          still in the first byte), or -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_get_feature_report",
        "parameter": [
            "SDL_hid_device *REWRITE_NAME",
            "unsigned char *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "dev",
            "data",
            "length"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Close a HID device.\n *\n * \\param dev A device handle returned from SDL_hid_open().\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_close",
        "parameter": [
            "SDL_hid_device *REWRITE_NAME"
        ],
        "parameter_name": [
            "dev"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get The Manufacturer String from a HID device.\n *\n * \\param dev A device handle returned from SDL_hid_open().\n * \\param string A wide string buffer to put the data into.\n * \\param maxlen The length of the buffer in multiples of wchar_t.\n * \\returns 0 on success and -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_get_manufacturer_string",
        "parameter": [
            "SDL_hid_device *REWRITE_NAME",
            "wchar_t *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "dev",
            "string",
            "maxlen"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get The Product String from a HID device.\n *\n * \\param dev A device handle returned from SDL_hid_open().\n * \\param string A wide string buffer to put the data into.\n * \\param maxlen The length of the buffer in multiples of wchar_t.\n * \\returns 0 on success and -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_get_product_string",
        "parameter": [
            "SDL_hid_device *REWRITE_NAME",
            "wchar_t *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "dev",
            "string",
            "maxlen"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get The Serial Number String from a HID device.\n *\n * \\param dev A device handle returned from SDL_hid_open().\n * \\param string A wide string buffer to put the data into.\n * \\param maxlen The length of the buffer in multiples of wchar_t.\n * \\returns 0 on success and -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_get_serial_number_string",
        "parameter": [
            "SDL_hid_device *REWRITE_NAME",
            "wchar_t *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "dev",
            "string",
            "maxlen"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get a string from a HID device, based on its string index.\n *\n * \\param dev A device handle returned from SDL_hid_open().\n * \\param string_index The index of the string to get.\n * \\param string A wide string buffer to put the data into.\n * \\param maxlen The length of the buffer in multiples of wchar_t.\n * \\returns 0 on success and -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_get_indexed_string",
        "parameter": [
            "SDL_hid_device *REWRITE_NAME",
            "int REWRITE_NAME",
            "wchar_t *REWRITE_NAME",
            "size_t REWRITE_NAME"
        ],
        "parameter_name": [
            "dev",
            "string_index",
            "string",
            "maxlen"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Start or stop a BLE scan on iOS and tvOS to pair Steam Controllers\n *\n * \\param active SDL_TRUE to start the scan, SDL_FALSE to stop the scan\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_hidapi.h",
        "name": "SDL_hid_ble_scan",
        "parameter": [
            "SDL_bool REWRITE_NAME"
        ],
        "parameter_name": [
            "active"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the human readable name of a pixel format.\n *\n * \\param format the pixel format to query\n * \\returns the human readable name of the specified pixel format or\n *          `SDL_PIXELFORMAT_UNKNOWN` if the format isn't recognized.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_pixels.h",
        "name": "SDL_GetPixelFormatName",
        "parameter": [
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "format"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Convert one of the enumerated pixel formats to a bpp value and RGBA masks.\n *\n * \\param format one of the SDL_PixelFormatEnum values\n * \\param bpp a bits per pixel value; usually 15, 16, or 32\n * \\param Rmask a pointer filled in with the red mask for the format\n * \\param Gmask a pointer filled in with the green mask for the format\n * \\param Bmask a pointer filled in with the blue mask for the format\n * \\param Amask a pointer filled in with the alpha mask for the format\n * \\returns SDL_TRUE on success or SDL_FALSE if the conversion wasn't\n *          possible; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetPixelFormatEnumForMasks\n */\n",
        "header": "SDL_pixels.h",
        "name": "SDL_GetMasksForPixelFormatEnum",
        "parameter": [
            "Uint32 REWRITE_NAME",
            "int *REWRITE_NAME",
            "Uint32 *REWRITE_NAME",
            "Uint32 *REWRITE_NAME",
            "Uint32 *REWRITE_NAME",
            "Uint32 *REWRITE_NAME"
        ],
        "parameter_name": [
            "format",
            "bpp",
            "Rmask",
            "Gmask",
            "Bmask",
            "Amask"
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Convert a bpp value and RGBA masks to an enumerated pixel format.\n *\n * This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't\n * possible.\n *\n * \\param bpp a bits per pixel value; usually 15, 16, or 32\n * \\param Rmask the red mask for the format\n * \\param Gmask the green mask for the format\n * \\param Bmask the blue mask for the format\n * \\param Amask the alpha mask for the format\n * \\returns one of the SDL_PixelFormatEnum values\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetMasksForPixelFormatEnum\n */\n",
        "header": "SDL_pixels.h",
        "name": "SDL_GetPixelFormatEnumForMasks",
        "parameter": [
            "int REWRITE_NAME",
            "Uint32 REWRITE_NAME",
            "Uint32 REWRITE_NAME",
            "Uint32 REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "bpp",
            "Rmask",
            "Gmask",
            "Bmask",
            "Amask"
        ],
        "retval": "Uint32"
    },
    {
        "comment": "/**\n * Create an SDL_PixelFormat structure corresponding to a pixel format.\n *\n * Returned structure may come from a shared global cache (i.e. not newly\n * allocated), and hence should not be modified, especially the palette. Weird\n * errors such as `Blit combination not supported` may occur.\n *\n * \\param pixel_format one of the SDL_PixelFormatEnum values\n * \\returns the new SDL_PixelFormat structure or NULL on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_DestroyPixelFormat\n */\n",
        "header": "SDL_pixels.h",
        "name": "SDL_CreatePixelFormat",
        "parameter": [
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "pixel_format"
        ],
        "retval": "SDL_PixelFormat*"
    },
    {
        "comment": "/**\n * Free an SDL_PixelFormat structure allocated by SDL_CreatePixelFormat().\n *\n * \\param format the SDL_PixelFormat structure to free\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreatePixelFormat\n */\n",
        "header": "SDL_pixels.h",
        "name": "SDL_DestroyPixelFormat",
        "parameter": [
            "SDL_PixelFormat *REWRITE_NAME"
        ],
        "parameter_name": [
            "format"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Create a palette structure with the specified number of color entries.\n *\n * The palette entries are initialized to white.\n *\n * \\param ncolors represents the number of color entries in the color palette\n * \\returns a new SDL_Palette structure on success or NULL on failure (e.g. if\n *          there wasn't enough memory); call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_DestroyPalette\n */\n",
        "header": "SDL_pixels.h",
        "name": "SDL_CreatePalette",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "ncolors"
        ],
        "retval": "SDL_Palette*"
    },
    {
        "comment": "/**\n * Set the palette for a pixel format structure.\n *\n * \\param format the SDL_PixelFormat structure that will use the palette\n * \\param palette the SDL_Palette structure that will be used\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreatePalette\n * \\sa SDL_DestroyPalette\n */\n",
        "header": "SDL_pixels.h",
        "name": "SDL_SetPixelFormatPalette",
        "parameter": [
            "SDL_PixelFormat *REWRITE_NAME",
            "SDL_Palette *REWRITE_NAME"
        ],
        "parameter_name": [
            "format",
            "palette"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set a range of colors in a palette.\n *\n * \\param palette the SDL_Palette structure to modify\n * \\param colors an array of SDL_Color structures to copy into the palette\n * \\param firstcolor the index of the first palette entry to modify\n * \\param ncolors the number of entries to modify\n * \\returns 0 on success or a negative error code if not all of the colors\n *          could be set; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreatePalette\n * \\sa SDL_CreateSurface\n */\n",
        "header": "SDL_pixels.h",
        "name": "SDL_SetPaletteColors",
        "parameter": [
            "SDL_Palette *REWRITE_NAME",
            "const SDL_Color *REWRITE_NAME",
            "int REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "palette",
            "colors",
            "firstcolor",
            "ncolors"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Free a palette created with SDL_CreatePalette().\n *\n * \\param palette the SDL_Palette structure to be freed\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreatePalette\n */\n",
        "header": "SDL_pixels.h",
        "name": "SDL_DestroyPalette",
        "parameter": [
            "SDL_Palette *REWRITE_NAME"
        ],
        "parameter_name": [
            "palette"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Map an RGB triple to an opaque pixel value for a given pixel format.\n *\n * This function maps the RGB color value to the specified pixel format and\n * returns the pixel value best approximating the given RGB color value for\n * the given pixel format.\n *\n * If the format has a palette (8-bit) the index of the closest matching color\n * in the palette will be returned.\n *\n * If the specified pixel format has an alpha component it will be returned as\n * all 1 bits (fully opaque).\n *\n * If the pixel format bpp (color depth) is less than 32-bpp then the unused\n * upper bits of the return value can safely be ignored (e.g., with a 16-bpp\n * format the return value can be assigned to a Uint16, and similarly a Uint8\n * for an 8-bpp format).\n *\n * \\param format an SDL_PixelFormat structure describing the pixel format\n * \\param r the red component of the pixel in the range 0-255\n * \\param g the green component of the pixel in the range 0-255\n * \\param b the blue component of the pixel in the range 0-255\n * \\returns a pixel value\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRGB\n * \\sa SDL_GetRGBA\n * \\sa SDL_MapRGBA\n */\n",
        "header": "SDL_pixels.h",
        "name": "SDL_MapRGB",
        "parameter": [
            "const SDL_PixelFormat *REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "Uint8 REWRITE_NAME"
        ],
        "parameter_name": [
            "format",
            "r",
            "g",
            "b"
        ],
        "retval": "Uint32"
    },
    {
        "comment": "/**\n * Map an RGBA quadruple to a pixel value for a given pixel format.\n *\n * This function maps the RGBA color value to the specified pixel format and\n * returns the pixel value best approximating the given RGBA color value for\n * the given pixel format.\n *\n * If the specified pixel format has no alpha component the alpha value will\n * be ignored (as it will be in formats with a palette).\n *\n * If the format has a palette (8-bit) the index of the closest matching color\n * in the palette will be returned.\n *\n * If the pixel format bpp (color depth) is less than 32-bpp then the unused\n * upper bits of the return value can safely be ignored (e.g., with a 16-bpp\n * format the return value can be assigned to a Uint16, and similarly a Uint8\n * for an 8-bpp format).\n *\n * \\param format an SDL_PixelFormat structure describing the format of the\n *               pixel\n * \\param r the red component of the pixel in the range 0-255\n * \\param g the green component of the pixel in the range 0-255\n * \\param b the blue component of the pixel in the range 0-255\n * \\param a the alpha component of the pixel in the range 0-255\n * \\returns a pixel value\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRGB\n * \\sa SDL_GetRGBA\n * \\sa SDL_MapRGB\n */\n",
        "header": "SDL_pixels.h",
        "name": "SDL_MapRGBA",
        "parameter": [
            "const SDL_PixelFormat *REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "Uint8 REWRITE_NAME"
        ],
        "parameter_name": [
            "format",
            "r",
            "g",
            "b",
            "a"
        ],
        "retval": "Uint32"
    },
    {
        "comment": "/**\n * Get RGB values from a pixel in the specified format.\n *\n * This function uses the entire 8-bit [0..255] range when converting color\n * components from pixel formats with less than 8-bits per RGB component\n * (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,\n * 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).\n *\n * \\param pixel a pixel value\n * \\param format an SDL_PixelFormat structure describing the format of the\n *               pixel\n * \\param r a pointer filled in with the red component\n * \\param g a pointer filled in with the green component\n * \\param b a pointer filled in with the blue component\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRGBA\n * \\sa SDL_MapRGB\n * \\sa SDL_MapRGBA\n */\n",
        "header": "SDL_pixels.h",
        "name": "SDL_GetRGB",
        "parameter": [
            "Uint32 REWRITE_NAME",
            "const SDL_PixelFormat *REWRITE_NAME",
            "Uint8 *REWRITE_NAME",
            "Uint8 *REWRITE_NAME",
            "Uint8 *REWRITE_NAME"
        ],
        "parameter_name": [
            "pixel",
            "format",
            "r",
            "g",
            "b"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get RGBA values from a pixel in the specified format.\n *\n * This function uses the entire 8-bit [0..255] range when converting color\n * components from pixel formats with less than 8-bits per RGB component\n * (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,\n * 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).\n *\n * If the surface has no alpha component, the alpha will be returned as 0xff\n * (100% opaque).\n *\n * \\param pixel a pixel value\n * \\param format an SDL_PixelFormat structure describing the format of the\n *               pixel\n * \\param r a pointer filled in with the red component\n * \\param g a pointer filled in with the green component\n * \\param b a pointer filled in with the blue component\n * \\param a a pointer filled in with the alpha component\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetRGB\n * \\sa SDL_MapRGB\n * \\sa SDL_MapRGBA\n */\n",
        "header": "SDL_pixels.h",
        "name": "SDL_GetRGBA",
        "parameter": [
            "Uint32 REWRITE_NAME",
            "const SDL_PixelFormat *REWRITE_NAME",
            "Uint8 *REWRITE_NAME",
            "Uint8 *REWRITE_NAME",
            "Uint8 *REWRITE_NAME",
            "Uint8 *REWRITE_NAME"
        ],
        "parameter_name": [
            "pixel",
            "format",
            "r",
            "g",
            "b",
            "a"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Open a URL/URI in the browser or other appropriate external application.\n *\n * Open a URL in a separate, system-provided application. How this works will\n * vary wildly depending on the platform. This will likely launch what makes\n * sense to handle a specific URL's protocol (a web browser for `http://`,\n * etc), but it might also be able to launch file managers for directories and\n * other things.\n *\n * What happens when you open a URL varies wildly as well: your game window\n * may lose focus (and may or may not lose focus if your game was fullscreen\n * or grabbing input at the time). On mobile devices, your app will likely\n * move to the background or your process might be paused. Any given platform\n * may or may not handle a given URL.\n *\n * If this is unimplemented (or simply unavailable) for a platform, this will\n * fail with an error. A successful result does not mean the URL loaded, just\n * that we launched _something_ to handle it (or at least believe we did).\n *\n * All this to say: this function can be useful, but you should definitely\n * test it on every platform you target.\n *\n * \\param url A valid URL/URI to open. Use `file:///full/path/to/file` for\n *            local files, if supported.\n * \\returns 0 on success, or -1 on error; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_misc.h",
        "name": "SDL_OpenURL",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "url"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get driver-specific information about a window.\n *\n * You must include SDL_syswm.h for the declaration of SDL_SysWMinfo.\n *\n * \\param window the window about which information is being requested\n * \\param info an SDL_SysWMinfo structure filled in with window information\n * \\param version the version of info being requested, should be\n *                SDL_SYSWM_CURRENT_VERSION\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_syswm.h",
        "name": "SDL_GetWindowWMInfo",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "SDL_SysWMinfo *REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "info",
            "version"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Create a CAMetalLayer-backed NSView/UIView and attach it to the specified\n * window.\n *\n * On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on\n * its own. It is up to user code to do that.\n *\n * The returned handle can be casted directly to a NSView or UIView. To access\n * the backing CAMetalLayer, call SDL_Metal_GetLayer().\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Metal_DestroyView\n * \\sa SDL_Metal_GetLayer\n */\n",
        "header": "SDL_metal.h",
        "name": "SDL_Metal_CreateView",
        "parameter": [
            "SDL_Window *REWRITE_NAME"
        ],
        "parameter_name": [
            "window"
        ],
        "retval": "SDL_MetalView"
    },
    {
        "comment": "/**\n * Destroy an existing SDL_MetalView object.\n *\n * This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was\n * called after SDL_CreateWindow.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Metal_CreateView\n */\n",
        "header": "SDL_metal.h",
        "name": "SDL_Metal_DestroyView",
        "parameter": [
            "SDL_MetalView REWRITE_NAME"
        ],
        "parameter_name": [
            "view"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get a pointer to the backing CAMetalLayer for the given view.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_Metal_CreateView\n */\n",
        "header": "SDL_metal.h",
        "name": "SDL_Metal_GetLayer",
        "parameter": [
            "SDL_MetalView REWRITE_NAME"
        ],
        "parameter_name": [
            "view"
        ],
        "retval": "void*"
    },
    {
        "comment": "/**\n * Get the size of a window's underlying drawable in pixels (for use with\n * setting viewport, scissor & etc).\n *\n * \\param window SDL_Window from which the drawable size should be queried\n * \\param w Pointer to variable for storing the width in pixels, may be NULL\n * \\param h Pointer to variable for storing the height in pixels, may be NULL\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetWindowSize\n * \\sa SDL_CreateWindow\n */\n",
        "header": "SDL_metal.h",
        "name": "SDL_Metal_GetDrawableSize",
        "parameter": [
            "SDL_Window *REWRITE_NAME",
            "int *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "window",
            "w",
            "h"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Count the number of haptic devices attached to the system.\n *\n * \\returns the number of haptic devices detected on the system or a negative\n *          error code on failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticName\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_NumHaptics",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the implementation dependent name of a haptic device.\n *\n * This can be called before any joysticks are opened. If no name can be\n * found, this function returns NULL.\n *\n * \\param device_index index of the device to query.\n * \\returns the name of the device or NULL on failure; call SDL_GetError() for\n *          more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_NumHaptics\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticName",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "device_index"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Open a haptic device for use.\n *\n * The index passed as an argument refers to the N'th haptic device on this\n * system.\n *\n * When opening a haptic device, its gain will be set to maximum and\n * autocenter will be disabled. To modify these values use SDL_HapticSetGain()\n * and SDL_HapticSetAutocenter().\n *\n * \\param device_index index of the device to open\n * \\returns the device identifier or NULL on failure; call SDL_GetError() for\n *          more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticClose\n * \\sa SDL_HapticIndex\n * \\sa SDL_HapticOpenFromJoystick\n * \\sa SDL_HapticOpenFromMouse\n * \\sa SDL_HapticPause\n * \\sa SDL_HapticSetAutocenter\n * \\sa SDL_HapticSetGain\n * \\sa SDL_HapticStopAll\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticOpen",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "device_index"
        ],
        "retval": "SDL_Haptic*"
    },
    {
        "comment": "/**\n * Check if the haptic device at the designated index has been opened.\n *\n * \\param device_index the index of the device to query\n * \\returns 1 if it has been opened, 0 if it hasn't or on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticIndex\n * \\sa SDL_HapticOpen\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticOpened",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "device_index"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the index of a haptic device.\n *\n * \\param haptic the SDL_Haptic device to query\n * \\returns the index of the specified haptic device or a negative error code\n *          on failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticOpen\n * \\sa SDL_HapticOpened\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticIndex",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Query whether or not the current mouse has haptic capabilities.\n *\n * \\returns SDL_TRUE if the mouse is haptic or SDL_FALSE if it isn't.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticOpenFromMouse\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_MouseIsHaptic",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Try to open a haptic device from the current mouse.\n *\n * \\returns the haptic device identifier or NULL on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticOpen\n * \\sa SDL_MouseIsHaptic\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticOpenFromMouse",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_Haptic*"
    },
    {
        "comment": "/**\n * Query if a joystick has haptic features.\n *\n * \\param joystick the SDL_Joystick to test for haptic capabilities\n * \\returns SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't, or a\n *          negative error code on failure; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticOpenFromJoystick\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_JoystickIsHaptic",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Open a haptic device for use from a joystick device.\n *\n * You must still close the haptic device separately. It will not be closed\n * with the joystick.\n *\n * When opened from a joystick you should first close the haptic device before\n * closing the joystick device. If not, on some implementations the haptic\n * device will also get unallocated and you'll be unable to use force feedback\n * on that device.\n *\n * \\param joystick the SDL_Joystick to create a haptic device from\n * \\returns a valid haptic device identifier on success or NULL on failure;\n *          call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticClose\n * \\sa SDL_HapticOpen\n * \\sa SDL_JoystickIsHaptic\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticOpenFromJoystick",
        "parameter": [
            "SDL_Joystick *REWRITE_NAME"
        ],
        "parameter_name": [
            "joystick"
        ],
        "retval": "SDL_Haptic*"
    },
    {
        "comment": "/**\n * Close a haptic device previously opened with SDL_HapticOpen().\n *\n * \\param haptic the SDL_Haptic device to close\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticOpen\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticClose",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the number of effects a haptic device can store.\n *\n * On some platforms this isn't fully supported, and therefore is an\n * approximation. Always check to see if your created effect was actually\n * created and do not rely solely on SDL_HapticNumEffects().\n *\n * \\param haptic the SDL_Haptic device to query\n * \\returns the number of effects the haptic device can store or a negative\n *          error code on failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticNumEffectsPlaying\n * \\sa SDL_HapticQuery\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticNumEffects",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the number of effects a haptic device can play at the same time.\n *\n * This is not supported on all platforms, but will always return a value.\n *\n * \\param haptic the SDL_Haptic device to query maximum playing effects\n * \\returns the number of effects the haptic device can play at the same time\n *          or a negative error code on failure; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticNumEffects\n * \\sa SDL_HapticQuery\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticNumEffectsPlaying",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the haptic device's supported features in bitwise manner.\n *\n * \\param haptic the SDL_Haptic device to query\n * \\returns a list of supported haptic features in bitwise manner (OR'd), or 0\n *          on failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticEffectSupported\n * \\sa SDL_HapticNumEffects\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticQuery",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic"
        ],
        "retval": "unsigned int"
    },
    {
        "comment": "/**\n * Get the number of haptic axes the device has.\n *\n * The number of haptic axes might be useful if working with the\n * SDL_HapticDirection effect.\n *\n * \\param haptic the SDL_Haptic device to query\n * \\returns the number of axes on success or a negative error code on failure;\n *          call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticNumAxes",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Check to see if an effect is supported by a haptic device.\n *\n * \\param haptic the SDL_Haptic device to query\n * \\param effect the desired effect to query\n * \\returns SDL_TRUE if effect is supported, SDL_FALSE if it isn't, or a\n *          negative error code on failure; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticNewEffect\n * \\sa SDL_HapticQuery\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticEffectSupported",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME",
            "SDL_HapticEffect *REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic",
            "effect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Create a new haptic effect on a specified device.\n *\n * \\param haptic an SDL_Haptic device to create the effect on\n * \\param effect an SDL_HapticEffect structure containing the properties of\n *               the effect to create\n * \\returns the ID of the effect on success or a negative error code on\n *          failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticDestroyEffect\n * \\sa SDL_HapticRunEffect\n * \\sa SDL_HapticUpdateEffect\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticNewEffect",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME",
            "SDL_HapticEffect *REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic",
            "effect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Update the properties of an effect.\n *\n * Can be used dynamically, although behavior when dynamically changing\n * direction may be strange. Specifically the effect may re-upload itself and\n * start playing from the start. You also cannot change the type either when\n * running SDL_HapticUpdateEffect().\n *\n * \\param haptic the SDL_Haptic device that has the effect\n * \\param effect the identifier of the effect to update\n * \\param data an SDL_HapticEffect structure containing the new effect\n *             properties to use\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticDestroyEffect\n * \\sa SDL_HapticNewEffect\n * \\sa SDL_HapticRunEffect\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticUpdateEffect",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME",
            "int REWRITE_NAME",
            "SDL_HapticEffect *REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic",
            "effect",
            "data"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Run the haptic effect on its associated haptic device.\n *\n * To repeat the effect over and over indefinitely, set `iterations` to\n * `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make\n * one instance of the effect last indefinitely (so the effect does not fade),\n * set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`\n * instead.\n *\n * \\param haptic the SDL_Haptic device to run the effect on\n * \\param effect the ID of the haptic effect to run\n * \\param iterations the number of iterations to run the effect; use\n *                   `SDL_HAPTIC_INFINITY` to repeat forever\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticDestroyEffect\n * \\sa SDL_HapticGetEffectStatus\n * \\sa SDL_HapticStopEffect\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticRunEffect",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME",
            "int REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic",
            "effect",
            "iterations"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Stop the haptic effect on its associated haptic device.\n *\n * *\n *\n * \\param haptic the SDL_Haptic device to stop the effect on\n * \\param effect the ID of the haptic effect to stop\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticDestroyEffect\n * \\sa SDL_HapticRunEffect\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticStopEffect",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic",
            "effect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Destroy a haptic effect on the device.\n *\n * This will stop the effect if it's running. Effects are automatically\n * destroyed when the device is closed.\n *\n * \\param haptic the SDL_Haptic device to destroy the effect on\n * \\param effect the ID of the haptic effect to destroy\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticNewEffect\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticDestroyEffect",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic",
            "effect"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the status of the current effect on the specified haptic device.\n *\n * Device must support the SDL_HAPTIC_STATUS feature.\n *\n * \\param haptic the SDL_Haptic device to query for the effect status on\n * \\param effect the ID of the haptic effect to query its status\n * \\returns 0 if it isn't playing, 1 if it is playing, or a negative error\n *          code on failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticRunEffect\n * \\sa SDL_HapticStopEffect\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticGetEffectStatus",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic",
            "effect"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set the global gain of the specified haptic device.\n *\n * Device must support the SDL_HAPTIC_GAIN feature.\n *\n * The user may specify the maximum gain by setting the environment variable\n * `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to\n * SDL_HapticSetGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the\n * maximum.\n *\n * \\param haptic the SDL_Haptic device to set the gain on\n * \\param gain value to set the gain to, should be between 0 and 100 (0 - 100)\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticQuery\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticSetGain",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic",
            "gain"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Set the global autocenter of the device.\n *\n * Autocenter should be between 0 and 100. Setting it to 0 will disable\n * autocentering.\n *\n * Device must support the SDL_HAPTIC_AUTOCENTER feature.\n *\n * \\param haptic the SDL_Haptic device to set autocentering on\n * \\param autocenter value to set autocenter to (0-100)\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticQuery\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticSetAutocenter",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic",
            "autocenter"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Pause a haptic device.\n *\n * Device must support the `SDL_HAPTIC_PAUSE` feature. Call\n * SDL_HapticUnpause() to resume playback.\n *\n * Do not modify the effects nor add new ones while the device is paused. That\n * can cause all sorts of weird errors.\n *\n * \\param haptic the SDL_Haptic device to pause\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticUnpause\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticPause",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Unpause a haptic device.\n *\n * Call to unpause after SDL_HapticPause().\n *\n * \\param haptic the SDL_Haptic device to unpause\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticPause\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticUnpause",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Stop all the currently playing effects on a haptic device.\n *\n * \\param haptic the SDL_Haptic device to stop\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticStopAll",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Check whether rumble is supported on a haptic device.\n *\n * \\param haptic haptic device to check for rumble support\n * \\returns SDL_TRUE if effect is supported, SDL_FALSE if it isn't, or a\n *          negative error code on failure; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticRumbleInit\n * \\sa SDL_HapticRumblePlay\n * \\sa SDL_HapticRumbleStop\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticRumbleSupported",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Initialize a haptic device for simple rumble playback.\n *\n * \\param haptic the haptic device to initialize for simple rumble playback\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticOpen\n * \\sa SDL_HapticRumblePlay\n * \\sa SDL_HapticRumbleStop\n * \\sa SDL_HapticRumbleSupported\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticRumbleInit",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Run a simple rumble effect on a haptic device.\n *\n * \\param haptic the haptic device to play the rumble effect on\n * \\param strength strength of the rumble to play as a 0-1 float value\n * \\param length length of the rumble to play in milliseconds\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticRumbleInit\n * \\sa SDL_HapticRumbleStop\n * \\sa SDL_HapticRumbleSupported\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticRumblePlay",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME",
            "float REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic",
            "strength",
            "length"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Stop the simple rumble on a haptic device.\n *\n * \\param haptic the haptic device to stop the rumble effect on\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HapticRumbleInit\n * \\sa SDL_HapticRumblePlay\n * \\sa SDL_HapticRumbleSupported\n */\n",
        "header": "SDL_haptic.h",
        "name": "SDL_HapticRumbleStop",
        "parameter": [
            "SDL_Haptic *REWRITE_NAME"
        ],
        "parameter_name": [
            "haptic"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Use this function to create a new SDL_RWops structure for reading from\n * and/or writing to a named file.\n *\n * The `mode` string is treated roughly the same as in a call to the C\n * library's fopen(), even if SDL doesn't happen to use fopen() behind the\n * scenes.\n *\n * Available `mode` strings:\n *\n * - \"r\": Open a file for reading. The file must exist.\n * - \"w\": Create an empty file for writing. If a file with the same name\n *   already exists its content is erased and the file is treated as a new\n *   empty file.\n * - \"a\": Append to a file. Writing operations append data at the end of the\n *   file. The file is created if it does not exist.\n * - \"r+\": Open a file for update both reading and writing. The file must\n *   exist.\n * - \"w+\": Create an empty file for both reading and writing. If a file with\n *   the same name already exists its content is erased and the file is\n *   treated as a new empty file.\n * - \"a+\": Open a file for reading and appending. All writing operations are\n *   performed at the end of the file, protecting the previous content to be\n *   overwritten. You can reposition (fseek, rewind) the internal pointer to\n *   anywhere in the file for reading, but writing operations will move it\n *   back to the end of file. The file is created if it does not exist.\n *\n * **NOTE**: In order to open a file as a binary file, a \"b\" character has to\n * be included in the `mode` string. This additional \"b\" character can either\n * be appended at the end of the string (thus making the following compound\n * modes: \"rb\", \"wb\", \"ab\", \"r+b\", \"w+b\", \"a+b\") or be inserted between the\n * letter and the \"+\" sign for the mixed modes (\"rb+\", \"wb+\", \"ab+\").\n * Additional characters may follow the sequence, although they should have no\n * effect. For example, \"t\" is sometimes appended to make explicit the file is\n * a text file.\n *\n * This function supports Unicode filenames, but they must be encoded in UTF-8\n * format, regardless of the underlying operating system.\n *\n * As a fallback, SDL_RWFromFile() will transparently open a matching filename\n * in an Android app's `assets`.\n *\n * Closing the SDL_RWops will close the file handle SDL is holding internally.\n *\n * \\param file a UTF-8 string representing the filename to open\n * \\param mode an ASCII string representing the mode to be used for opening\n *             the file.\n * \\returns a pointer to the SDL_RWops structure that is created, or NULL on\n *          failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RWclose\n * \\sa SDL_RWFromConstMem\n * \\sa SDL_RWFromMem\n * \\sa SDL_RWread\n * \\sa SDL_RWseek\n * \\sa SDL_RWtell\n * \\sa SDL_RWwrite\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_RWFromFile",
        "parameter": [
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "file",
            "mode"
        ],
        "retval": "SDL_RWops*"
    },
    {
        "comment": "/**\n * Use this function to prepare a read-write memory buffer for use with\n * SDL_RWops.\n *\n * This function sets up an SDL_RWops struct based on a memory area of a\n * certain size, for both read and write access.\n *\n * This memory buffer is not copied by the RWops; the pointer you provide must\n * remain valid until you close the stream. Closing the stream will not free\n * the original buffer.\n *\n * If you need to make sure the RWops never writes to the memory buffer, you\n * should use SDL_RWFromConstMem() with a read-only buffer of memory instead.\n *\n * \\param mem a pointer to a buffer to feed an SDL_RWops stream\n * \\param size the buffer size, in bytes\n * \\returns a pointer to a new SDL_RWops structure, or NULL if it fails; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RWclose\n * \\sa SDL_RWFromConstMem\n * \\sa SDL_RWFromFile\n * \\sa SDL_RWFromMem\n * \\sa SDL_RWread\n * \\sa SDL_RWseek\n * \\sa SDL_RWtell\n * \\sa SDL_RWwrite\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_RWFromMem",
        "parameter": [
            "void *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "mem",
            "size"
        ],
        "retval": "SDL_RWops*"
    },
    {
        "comment": "/**\n * Use this function to prepare a read-only memory buffer for use with RWops.\n *\n * This function sets up an SDL_RWops struct based on a memory area of a\n * certain size. It assumes the memory area is not writable.\n *\n * Attempting to write to this RWops stream will report an error without\n * writing to the memory buffer.\n *\n * This memory buffer is not copied by the RWops; the pointer you provide must\n * remain valid until you close the stream. Closing the stream will not free\n * the original buffer.\n *\n * If you need to write to a memory buffer, you should use SDL_RWFromMem()\n * with a writable buffer of memory instead.\n *\n * \\param mem a pointer to a read-only buffer to feed an SDL_RWops stream\n * \\param size the buffer size, in bytes\n * \\returns a pointer to a new SDL_RWops structure, or NULL if it fails; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RWclose\n * \\sa SDL_RWFromConstMem\n * \\sa SDL_RWFromFile\n * \\sa SDL_RWFromMem\n * \\sa SDL_RWread\n * \\sa SDL_RWseek\n * \\sa SDL_RWtell\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_RWFromConstMem",
        "parameter": [
            "const void *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "mem",
            "size"
        ],
        "retval": "SDL_RWops*"
    },
    {
        "comment": "/**\n * Use this function to allocate an empty, unpopulated SDL_RWops structure.\n *\n * Applications do not need to use this function unless they are providing\n * their own SDL_RWops implementation. If you just need a SDL_RWops to\n * read/write a common data source, you should use the built-in\n * implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.\n *\n * You must free the returned pointer with SDL_DestroyRW(). Depending on your\n * operating system and compiler, there may be a difference between the\n * malloc() and free() your program uses and the versions SDL calls\n * internally. Trying to mix the two can cause crashing such as segmentation\n * faults. Since all SDL_RWops must free themselves when their **close**\n * method is called, all SDL_RWops must be allocated through this function, so\n * they can all be freed correctly with SDL_DestroyRW().\n *\n * \\returns a pointer to the allocated memory on success, or NULL on failure;\n *          call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_DestroyRW\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_CreateRW",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_RWops*"
    },
    {
        "comment": "/**\n * Use this function to free an SDL_RWops structure allocated by\n * SDL_CreateRW().\n *\n * Applications do not need to use this function unless they are providing\n * their own SDL_RWops implementation. If you just need a SDL_RWops to\n * read/write a common data source, you should use the built-in\n * implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and\n * call the **close** method on those SDL_RWops pointers when you are done\n * with them.\n *\n * Only use SDL_DestroyRW() on pointers returned by SDL_CreateRW(). The pointer is\n * invalid as soon as this function returns. Any extra memory allocated during\n * creation of the SDL_RWops is not freed by SDL_DestroyRW(); the programmer must\n * be responsible for managing that memory in their **close** method.\n *\n * \\param area the SDL_RWops structure to be freed\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateRW\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_DestroyRW",
        "parameter": [
            "SDL_RWops *REWRITE_NAME"
        ],
        "parameter_name": [
            "area"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Use this function to get the size of the data stream in an SDL_RWops.\n *\n * Prior to SDL 2.0.10, this function was a macro.\n *\n * \\param context the SDL_RWops to get the size of the data stream from\n * \\returns the size of the data stream in the SDL_RWops on success, -1 if\n *          unknown or a negative error code on failure; call SDL_GetError()\n *          for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_RWsize",
        "parameter": [
            "SDL_RWops *REWRITE_NAME"
        ],
        "parameter_name": [
            "context"
        ],
        "retval": "Sint64"
    },
    {
        "comment": "/**\n * Seek within an SDL_RWops data stream.\n *\n * This function seeks to byte `offset`, relative to `whence`.\n *\n * `whence` may be any of the following values:\n *\n * - `SDL_RW_SEEK_SET`: seek from the beginning of data\n * - `SDL_RW_SEEK_CUR`: seek relative to current read point\n * - `SDL_RW_SEEK_END`: seek relative to the end of data\n *\n * If this stream can not seek, it will return -1.\n *\n * SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's\n * `seek` method appropriately, to simplify application development.\n *\n * Prior to SDL 2.0.10, this function was a macro.\n *\n * \\param context a pointer to an SDL_RWops structure\n * \\param offset an offset in bytes, relative to **whence** location; can be\n *               negative\n * \\param whence any of `SDL_RW_SEEK_SET`, `SDL_RW_SEEK_CUR`, `SDL_RW_SEEK_END`\n * \\returns the final offset in the data stream after the seek or -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RWclose\n * \\sa SDL_RWFromConstMem\n * \\sa SDL_RWFromFile\n * \\sa SDL_RWFromMem\n * \\sa SDL_RWread\n * \\sa SDL_RWtell\n * \\sa SDL_RWwrite\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_RWseek",
        "parameter": [
            "SDL_RWops *REWRITE_NAME",
            "Sint64 REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "context",
            "offset",
            "whence"
        ],
        "retval": "Sint64"
    },
    {
        "comment": "/**\n * Determine the current read/write offset in an SDL_RWops data stream.\n *\n * SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`\n * method, with an offset of 0 bytes from `SDL_RW_SEEK_CUR`, to simplify\n * application development.\n *\n * Prior to SDL 2.0.10, this function was a macro.\n *\n * \\param context a SDL_RWops data stream object from which to get the current\n *                offset\n * \\returns the current offset in the stream, or -1 if the information can not\n *          be determined.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RWclose\n * \\sa SDL_RWFromConstMem\n * \\sa SDL_RWFromFile\n * \\sa SDL_RWFromMem\n * \\sa SDL_RWread\n * \\sa SDL_RWseek\n * \\sa SDL_RWwrite\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_RWtell",
        "parameter": [
            "SDL_RWops *REWRITE_NAME"
        ],
        "parameter_name": [
            "context"
        ],
        "retval": "Sint64"
    },
    {
        "comment": "/**\n * Read from a data source.\n *\n * This function reads up `size` bytes from the data source to the area\n * pointed at by `ptr`. This function may read less bytes than requested.\n * It will return zero when the data stream is completely read, or\n * -1 on error. For streams that support non-blocking\n * operation, if nothing was read because it would require blocking,\n * this function returns -2 to distinguish that this is not an error or\n * end-of-file, and the caller can try again later.\n *\n * SDL_RWread() is actually a function wrapper that calls the SDL_RWops's\n * `read` method appropriately, to simplify application development.\n *\n * It is an error to specify a negative `size`, but this parameter is\n * signed so you definitely cannot overflow the return value on a\n * successful run with enormous amounts of data.\n *\n * \\param context a pointer to an SDL_RWops structure\n * \\param ptr a pointer to a buffer to read data into\n * \\param size the number of bytes to read from the data source.\n * \\returns the number of bytes read, 0 at end of file, -1 on error, and -2 for data not ready with a non-blocking context.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RWclose\n * \\sa SDL_RWFromConstMem\n * \\sa SDL_RWFromFile\n * \\sa SDL_RWFromMem\n * \\sa SDL_RWseek\n * \\sa SDL_RWwrite\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_RWread",
        "parameter": [
            "SDL_RWops *REWRITE_NAME",
            "void *REWRITE_NAME",
            "Sint64 REWRITE_NAME"
        ],
        "parameter_name": [
            "context",
            "ptr",
            "size"
        ],
        "retval": "Sint64"
    },
    {
        "comment": "/**\n * Write to an SDL_RWops data stream.\n *\n * This function writes exactly `size` bytes from the area pointed at by\n * `ptr` to the stream. If this fails for any reason, it'll return less\n * than `size` to demonstrate how far the write progressed. On success,\n * it returns `num`.\n *\n * On error, this function still attempts to write as much as possible,\n * so it might return a positive value less than the requested write\n * size. If the function failed to write anything and there was an\n * actual error, it will return -1. For streams that support non-blocking\n * operation, if nothing was written because it would require blocking,\n * this function returns -2 to distinguish that this is not an error and\n * the caller can try again later.\n *\n * SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's\n * `write` method appropriately, to simplify application development.\n *\n * It is an error to specify a negative `size`, but this parameter is\n * signed so you definitely cannot overflow the return value on a\n * successful run with enormous amounts of data.\n *\n * \\param context a pointer to an SDL_RWops structure\n * \\param ptr a pointer to a buffer containing data to write\n * \\param size the number of bytes to write\n * \\returns the number of bytes written, which will be less than `num` on\n *          error; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RWclose\n * \\sa SDL_RWFromConstMem\n * \\sa SDL_RWFromFile\n * \\sa SDL_RWFromMem\n * \\sa SDL_RWread\n * \\sa SDL_RWseek\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_RWwrite",
        "parameter": [
            "SDL_RWops *REWRITE_NAME",
            "const void *REWRITE_NAME",
            "Sint64 REWRITE_NAME"
        ],
        "parameter_name": [
            "context",
            "ptr",
            "size"
        ],
        "retval": "Sint64"
    },
    {
        "comment": "/**\n * Close and free an allocated SDL_RWops structure.\n *\n * SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any\n * resources used by the stream and frees the SDL_RWops itself with\n * SDL_DestroyRW(). This returns 0 on success, or -1 if the stream failed to\n * flush to its output (e.g. to disk).\n *\n * Note that if this fails to flush the stream to disk, this function reports\n * an error, but the SDL_RWops is still invalid once this function returns.\n *\n * Prior to SDL 2.0.10, this function was a macro.\n *\n * \\param context SDL_RWops structure to close\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_RWFromConstMem\n * \\sa SDL_RWFromFile\n * \\sa SDL_RWFromMem\n * \\sa SDL_RWread\n * \\sa SDL_RWseek\n * \\sa SDL_RWwrite\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_RWclose",
        "parameter": [
            "SDL_RWops *REWRITE_NAME"
        ],
        "parameter_name": [
            "context"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Load all the data from an SDL data stream.\n *\n * The data is allocated with a zero byte at the end (null terminated) for\n * convenience. This extra byte is not included in the value reported via\n * `datasize`.\n *\n * The data should be freed with SDL_free().\n *\n * \\param src the SDL_RWops to read all available data from\n * \\param datasize if not NULL, will store the number of bytes read\n * \\param freesrc if non-zero, calls SDL_RWclose() on `src` before returning\n * \\returns the data, or NULL if there was an error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_LoadFile_RW",
        "parameter": [
            "SDL_RWops *REWRITE_NAME",
            "size_t *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "src",
            "datasize",
            "freesrc"
        ],
        "retval": "void*"
    },
    {
        "comment": "/**\n * Load all the data from a file path.\n *\n * The data is allocated with a zero byte at the end (null terminated) for\n * convenience. This extra byte is not included in the value reported via\n * `datasize`.\n *\n * The data should be freed with SDL_free().\n *\n * Prior to SDL 2.0.10, this function was a macro wrapping around\n * SDL_LoadFile_RW.\n *\n * \\param file the path to read all available data from\n * \\param datasize if not NULL, will store the number of bytes read\n * \\returns the data, or NULL if there was an error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_LoadFile",
        "parameter": [
            "const char *REWRITE_NAME",
            "size_t *REWRITE_NAME"
        ],
        "parameter_name": [
            "file",
            "datasize"
        ],
        "retval": "void*"
    },
    {
        "comment": "/**\n * Use this function to read a byte from an SDL_RWops.\n *\n * \\param src the SDL_RWops to read from\n * \\returns the read byte on success or 0 on failure; call SDL_GetError() for\n *          more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_WriteU8\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_ReadU8",
        "parameter": [
            "SDL_RWops *REWRITE_NAME"
        ],
        "parameter_name": [
            "src"
        ],
        "retval": "Uint8"
    },
    {
        "comment": "/**\n * Use this function to read 16 bits of little-endian data from an SDL_RWops\n * and return in native format.\n *\n * SDL byteswaps the data only if necessary, so the data returned will be in\n * the native byte order.\n *\n * \\param src the stream from which to read data\n * \\returns 16 bits of data in the native byte order of the platform.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ReadBE16\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_ReadLE16",
        "parameter": [
            "SDL_RWops *REWRITE_NAME"
        ],
        "parameter_name": [
            "src"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "/**\n * Use this function to read 16 bits of big-endian data from an SDL_RWops and\n * return in native format.\n *\n * SDL byteswaps the data only if necessary, so the data returned will be in\n * the native byte order.\n *\n * \\param src the stream from which to read data\n * \\returns 16 bits of data in the native byte order of the platform.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ReadLE16\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_ReadBE16",
        "parameter": [
            "SDL_RWops *REWRITE_NAME"
        ],
        "parameter_name": [
            "src"
        ],
        "retval": "Uint16"
    },
    {
        "comment": "/**\n * Use this function to read 32 bits of little-endian data from an SDL_RWops\n * and return in native format.\n *\n * SDL byteswaps the data only if necessary, so the data returned will be in\n * the native byte order.\n *\n * \\param src the stream from which to read data\n * \\returns 32 bits of data in the native byte order of the platform.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ReadBE32\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_ReadLE32",
        "parameter": [
            "SDL_RWops *REWRITE_NAME"
        ],
        "parameter_name": [
            "src"
        ],
        "retval": "Uint32"
    },
    {
        "comment": "/**\n * Use this function to read 32 bits of big-endian data from an SDL_RWops and\n * return in native format.\n *\n * SDL byteswaps the data only if necessary, so the data returned will be in\n * the native byte order.\n *\n * \\param src the stream from which to read data\n * \\returns 32 bits of data in the native byte order of the platform.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ReadLE32\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_ReadBE32",
        "parameter": [
            "SDL_RWops *REWRITE_NAME"
        ],
        "parameter_name": [
            "src"
        ],
        "retval": "Uint32"
    },
    {
        "comment": "/**\n * Use this function to read 64 bits of little-endian data from an SDL_RWops\n * and return in native format.\n *\n * SDL byteswaps the data only if necessary, so the data returned will be in\n * the native byte order.\n *\n * \\param src the stream from which to read data\n * \\returns 64 bits of data in the native byte order of the platform.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ReadBE64\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_ReadLE64",
        "parameter": [
            "SDL_RWops *REWRITE_NAME"
        ],
        "parameter_name": [
            "src"
        ],
        "retval": "Uint64"
    },
    {
        "comment": "/**\n * Use this function to read 64 bits of big-endian data from an SDL_RWops and\n * return in native format.\n *\n * SDL byteswaps the data only if necessary, so the data returned will be in\n * the native byte order.\n *\n * \\param src the stream from which to read data\n * \\returns 64 bits of data in the native byte order of the platform.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ReadLE64\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_ReadBE64",
        "parameter": [
            "SDL_RWops *REWRITE_NAME"
        ],
        "parameter_name": [
            "src"
        ],
        "retval": "Uint64"
    },
    {
        "comment": "/**\n * Use this function to write a byte to an SDL_RWops.\n *\n * \\param dst the SDL_RWops to write to\n * \\param value the byte value to write\n * \\returns 1 on success or 0 on failure; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ReadU8\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_WriteU8",
        "parameter": [
            "SDL_RWops *REWRITE_NAME",
            "Uint8 REWRITE_NAME"
        ],
        "parameter_name": [
            "dst",
            "value"
        ],
        "retval": "size_t"
    },
    {
        "comment": "/**\n * Use this function to write 16 bits in native format to a SDL_RWops as\n * little-endian data.\n *\n * SDL byteswaps the data only if necessary, so the application always\n * specifies native format, and the data written will be in little-endian\n * format.\n *\n * \\param dst the stream to which data will be written\n * \\param value the data to be written, in native format\n * \\returns 1 on successful write, 0 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_WriteBE16\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_WriteLE16",
        "parameter": [
            "SDL_RWops *REWRITE_NAME",
            "Uint16 REWRITE_NAME"
        ],
        "parameter_name": [
            "dst",
            "value"
        ],
        "retval": "size_t"
    },
    {
        "comment": "/**\n * Use this function to write 16 bits in native format to a SDL_RWops as\n * big-endian data.\n *\n * SDL byteswaps the data only if necessary, so the application always\n * specifies native format, and the data written will be in big-endian format.\n *\n * \\param dst the stream to which data will be written\n * \\param value the data to be written, in native format\n * \\returns 1 on successful write, 0 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_WriteLE16\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_WriteBE16",
        "parameter": [
            "SDL_RWops *REWRITE_NAME",
            "Uint16 REWRITE_NAME"
        ],
        "parameter_name": [
            "dst",
            "value"
        ],
        "retval": "size_t"
    },
    {
        "comment": "/**\n * Use this function to write 32 bits in native format to a SDL_RWops as\n * little-endian data.\n *\n * SDL byteswaps the data only if necessary, so the application always\n * specifies native format, and the data written will be in little-endian\n * format.\n *\n * \\param dst the stream to which data will be written\n * \\param value the data to be written, in native format\n * \\returns 1 on successful write, 0 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_WriteBE32\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_WriteLE32",
        "parameter": [
            "SDL_RWops *REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "dst",
            "value"
        ],
        "retval": "size_t"
    },
    {
        "comment": "/**\n * Use this function to write 32 bits in native format to a SDL_RWops as\n * big-endian data.\n *\n * SDL byteswaps the data only if necessary, so the application always\n * specifies native format, and the data written will be in big-endian format.\n *\n * \\param dst the stream to which data will be written\n * \\param value the data to be written, in native format\n * \\returns 1 on successful write, 0 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_WriteLE32\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_WriteBE32",
        "parameter": [
            "SDL_RWops *REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "dst",
            "value"
        ],
        "retval": "size_t"
    },
    {
        "comment": "/**\n * Use this function to write 64 bits in native format to a SDL_RWops as\n * little-endian data.\n *\n * SDL byteswaps the data only if necessary, so the application always\n * specifies native format, and the data written will be in little-endian\n * format.\n *\n * \\param dst the stream to which data will be written\n * \\param value the data to be written, in native format\n * \\returns 1 on successful write, 0 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_WriteBE64\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_WriteLE64",
        "parameter": [
            "SDL_RWops *REWRITE_NAME",
            "Uint64 REWRITE_NAME"
        ],
        "parameter_name": [
            "dst",
            "value"
        ],
        "retval": "size_t"
    },
    {
        "comment": "/**\n * Use this function to write 64 bits in native format to a SDL_RWops as\n * big-endian data.\n *\n * SDL byteswaps the data only if necessary, so the application always\n * specifies native format, and the data written will be in big-endian format.\n *\n * \\param dst the stream to which data will be written\n * \\param value the data to be written, in native format\n * \\returns 1 on successful write, 0 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_WriteLE64\n */\n",
        "header": "SDL_rwops.h",
        "name": "SDL_WriteBE64",
        "parameter": [
            "SDL_RWops *REWRITE_NAME",
            "Uint64 REWRITE_NAME"
        ],
        "parameter_name": [
            "dst",
            "value"
        ],
        "retval": "size_t"
    },
    {
        "comment": "/**\n * Get the current power supply details.\n *\n * You should never take a battery status as absolute truth. Batteries\n * (especially failing batteries) are delicate hardware, and the values\n * reported here are best estimates based on what that hardware reports. It's\n * not uncommon for older batteries to lose stored power much faster than it\n * reports, or completely drain when reporting it has 20 percent left, etc.\n *\n * Battery status can change at any time; if you are concerned with power\n * state, you should call this function frequently, and perhaps ignore changes\n * until they seem to be stable for a few seconds.\n *\n * It's possible a platform can only report battery percentage or time left\n * but not both.\n *\n * \\param seconds seconds of battery life left, you can pass a NULL here if you\n *             don't care, will return -1 if we can't determine a value, or\n *             we're not running on a battery\n * \\param percent percentage of battery life left, between 0 and 100, you can pass\n *            a NULL here if you don't care, will return -1 if we can't\n *            determine a value, or we're not running on a battery\n * \\returns an SDL_PowerState enum representing the current battery state.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_power.h",
        "name": "SDL_GetPowerInfo",
        "parameter": [
            "int *REWRITE_NAME",
            "int *REWRITE_NAME"
        ],
        "parameter_name": [
            "seconds",
            "percent"
        ],
        "retval": "SDL_PowerState"
    },
    {
        "comment": "/**\n * Get the number of CPU cores available.\n *\n * \\returns the total number of logical CPU cores. On CPUs that include\n *          technologies such as hyperthreading, the number of logical cores\n *          may be more than the number of physical cores.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_GetCPUCount",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Determine the L1 cache line size of the CPU.\n *\n * This is useful for determining multi-threaded structure padding or SIMD\n * prefetch sizes.\n *\n * \\returns the L1 cache line size of the CPU, in bytes.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_GetCPUCacheLineSize",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Determine whether the CPU has the RDTSC instruction.\n *\n * This always returns false on CPUs that aren't using Intel instruction sets.\n *\n * \\returns SDL_TRUE if the CPU has the RDTSC instruction or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasAltiVec\n * \\sa SDL_HasAVX\n * \\sa SDL_HasAVX2\n * \\sa SDL_HasMMX\n * \\sa SDL_HasSSE\n * \\sa SDL_HasSSE2\n * \\sa SDL_HasSSE3\n * \\sa SDL_HasSSE41\n * \\sa SDL_HasSSE42\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_HasRDTSC",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Determine whether the CPU has AltiVec features.\n *\n * This always returns false on CPUs that aren't using PowerPC instruction\n * sets.\n *\n * \\returns SDL_TRUE if the CPU has AltiVec features or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasAVX\n * \\sa SDL_HasAVX2\n * \\sa SDL_HasMMX\n * \\sa SDL_HasRDTSC\n * \\sa SDL_HasSSE\n * \\sa SDL_HasSSE2\n * \\sa SDL_HasSSE3\n * \\sa SDL_HasSSE41\n * \\sa SDL_HasSSE42\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_HasAltiVec",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Determine whether the CPU has MMX features.\n *\n * This always returns false on CPUs that aren't using Intel instruction sets.\n *\n * \\returns SDL_TRUE if the CPU has MMX features or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasAltiVec\n * \\sa SDL_HasAVX\n * \\sa SDL_HasAVX2\n * \\sa SDL_HasRDTSC\n * \\sa SDL_HasSSE\n * \\sa SDL_HasSSE2\n * \\sa SDL_HasSSE3\n * \\sa SDL_HasSSE41\n * \\sa SDL_HasSSE42\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_HasMMX",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Determine whether the CPU has SSE features.\n *\n * This always returns false on CPUs that aren't using Intel instruction sets.\n *\n * \\returns SDL_TRUE if the CPU has SSE features or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasAltiVec\n * \\sa SDL_HasAVX\n * \\sa SDL_HasAVX2\n * \\sa SDL_HasMMX\n * \\sa SDL_HasRDTSC\n * \\sa SDL_HasSSE2\n * \\sa SDL_HasSSE3\n * \\sa SDL_HasSSE41\n * \\sa SDL_HasSSE42\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_HasSSE",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Determine whether the CPU has SSE2 features.\n *\n * This always returns false on CPUs that aren't using Intel instruction sets.\n *\n * \\returns SDL_TRUE if the CPU has SSE2 features or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasAltiVec\n * \\sa SDL_HasAVX\n * \\sa SDL_HasAVX2\n * \\sa SDL_HasMMX\n * \\sa SDL_HasRDTSC\n * \\sa SDL_HasSSE\n * \\sa SDL_HasSSE3\n * \\sa SDL_HasSSE41\n * \\sa SDL_HasSSE42\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_HasSSE2",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Determine whether the CPU has SSE3 features.\n *\n * This always returns false on CPUs that aren't using Intel instruction sets.\n *\n * \\returns SDL_TRUE if the CPU has SSE3 features or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasAltiVec\n * \\sa SDL_HasAVX\n * \\sa SDL_HasAVX2\n * \\sa SDL_HasMMX\n * \\sa SDL_HasRDTSC\n * \\sa SDL_HasSSE\n * \\sa SDL_HasSSE2\n * \\sa SDL_HasSSE41\n * \\sa SDL_HasSSE42\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_HasSSE3",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Determine whether the CPU has SSE4.1 features.\n *\n * This always returns false on CPUs that aren't using Intel instruction sets.\n *\n * \\returns SDL_TRUE if the CPU has SSE4.1 features or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasAltiVec\n * \\sa SDL_HasAVX\n * \\sa SDL_HasAVX2\n * \\sa SDL_HasMMX\n * \\sa SDL_HasRDTSC\n * \\sa SDL_HasSSE\n * \\sa SDL_HasSSE2\n * \\sa SDL_HasSSE3\n * \\sa SDL_HasSSE42\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_HasSSE41",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Determine whether the CPU has SSE4.2 features.\n *\n * This always returns false on CPUs that aren't using Intel instruction sets.\n *\n * \\returns SDL_TRUE if the CPU has SSE4.2 features or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasAltiVec\n * \\sa SDL_HasAVX\n * \\sa SDL_HasAVX2\n * \\sa SDL_HasMMX\n * \\sa SDL_HasRDTSC\n * \\sa SDL_HasSSE\n * \\sa SDL_HasSSE2\n * \\sa SDL_HasSSE3\n * \\sa SDL_HasSSE41\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_HasSSE42",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Determine whether the CPU has AVX features.\n *\n * This always returns false on CPUs that aren't using Intel instruction sets.\n *\n * \\returns SDL_TRUE if the CPU has AVX features or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasAltiVec\n * \\sa SDL_HasAVX2\n * \\sa SDL_HasMMX\n * \\sa SDL_HasRDTSC\n * \\sa SDL_HasSSE\n * \\sa SDL_HasSSE2\n * \\sa SDL_HasSSE3\n * \\sa SDL_HasSSE41\n * \\sa SDL_HasSSE42\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_HasAVX",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Determine whether the CPU has AVX2 features.\n *\n * This always returns false on CPUs that aren't using Intel instruction sets.\n *\n * \\returns SDL_TRUE if the CPU has AVX2 features or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasAltiVec\n * \\sa SDL_HasAVX\n * \\sa SDL_HasMMX\n * \\sa SDL_HasRDTSC\n * \\sa SDL_HasSSE\n * \\sa SDL_HasSSE2\n * \\sa SDL_HasSSE3\n * \\sa SDL_HasSSE41\n * \\sa SDL_HasSSE42\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_HasAVX2",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Determine whether the CPU has AVX-512F (foundation) features.\n *\n * This always returns false on CPUs that aren't using Intel instruction sets.\n *\n * \\returns SDL_TRUE if the CPU has AVX-512F features or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasAVX\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_HasAVX512F",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Determine whether the CPU has ARM SIMD (ARMv6) features.\n *\n * This is different from ARM NEON, which is a different instruction set.\n *\n * This always returns false on CPUs that aren't using ARM instruction sets.\n *\n * \\returns SDL_TRUE if the CPU has ARM SIMD features or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_HasNEON\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_HasARMSIMD",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Determine whether the CPU has NEON (ARM SIMD) features.\n *\n * This always returns false on CPUs that aren't using ARM instruction sets.\n *\n * \\returns SDL_TRUE if the CPU has ARM NEON features or SDL_FALSE if not.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_HasNEON",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Determine whether the CPU has LSX (LOONGARCH SIMD) features.\n *\n * This always returns false on CPUs that aren't using LOONGARCH instruction\n * sets.\n *\n * \\returns SDL_TRUE if the CPU has LOONGARCH LSX features or SDL_FALSE if\n *          not.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_HasLSX",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Determine whether the CPU has LASX (LOONGARCH SIMD) features.\n *\n * This always returns false on CPUs that aren't using LOONGARCH instruction\n * sets.\n *\n * \\returns SDL_TRUE if the CPU has LOONGARCH LASX features or SDL_FALSE if\n *          not.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_HasLASX",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_bool"
    },
    {
        "comment": "/**\n * Get the amount of RAM configured in the system.\n *\n * \\returns the amount of RAM configured in the system in MiB.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_GetSystemRAM",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Report the alignment this system needs for SIMD allocations.\n *\n * This will return the minimum number of bytes to which a pointer must be\n * aligned to be compatible with SIMD instructions on the current machine. For\n * example, if the machine supports SSE only, it will return 16, but if it\n * supports AVX-512F, it'll return 64 (etc). This only reports values for\n * instruction sets SDL knows about, so if your SDL build doesn't have\n * SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and\n * not 64 for the AVX-512 instructions that exist but SDL doesn't know about.\n * Plan accordingly.\n *\n * \\returns the alignment in bytes needed for available, known SIMD\n *          instructions.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_aligned_alloc\n * \\sa SDL_aligned_free\n */\n",
        "header": "SDL_cpuinfo.h",
        "name": "SDL_SIMDGetAlignment",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "size_t"
    },
    {
        "comment": "/**\n * Create a new mutex.\n *\n * All newly-created mutexes begin in the _unlocked_ state.\n *\n * Calls to SDL_LockMutex() will not return while the mutex is locked by\n * another thread. See SDL_TryLockMutex() to attempt to lock without blocking.\n *\n * SDL mutexes are reentrant.\n *\n * \\returns the initialized and unlocked mutex or NULL on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_DestroyMutex\n * \\sa SDL_LockMutex\n * \\sa SDL_TryLockMutex\n * \\sa SDL_UnlockMutex\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_CreateMutex",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_mutex*"
    },
    {
        "comment": "/**\n * Lock the mutex.\n *\n * This will block until the mutex is available, which is to say it is in the\n * unlocked state and the OS has chosen the caller as the next thread to lock\n * it. Of all threads waiting to lock the mutex, only one may do so at a time.\n *\n * It is legal for the owning thread to lock an already-locked mutex. It must\n * unlock it the same number of times before it is actually made available for\n * other threads in the system (this is known as a \"recursive mutex\").\n *\n * \\param mutex the mutex to lock\n * \\return 0, or -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_LockMutex",
        "parameter": [
            "SDL_mutex *REWRITE_NAME"
        ],
        "parameter_name": [
            "mutex"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Try to lock a mutex without blocking.\n *\n * This works just like SDL_LockMutex(), but if the mutex is not available,\n * this function returns `SDL_MUTEX_TIMEOUT` immediately.\n *\n * This technique is useful if you need exclusive access to a resource but\n * don't want to wait for it, and will return to it to try again later.\n *\n * \\param mutex the mutex to try to lock\n * \\returns 0, `SDL_MUTEX_TIMEDOUT`, or -1 on error; call SDL_GetError() for\n *          more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateMutex\n * \\sa SDL_DestroyMutex\n * \\sa SDL_LockMutex\n * \\sa SDL_UnlockMutex\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_TryLockMutex",
        "parameter": [
            "SDL_mutex *REWRITE_NAME"
        ],
        "parameter_name": [
            "mutex"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Unlock the mutex.\n *\n * It is legal for the owning thread to lock an already-locked mutex. It must\n * unlock it the same number of times before it is actually made available for\n * other threads in the system (this is known as a \"recursive mutex\").\n *\n * It is an error to unlock a mutex that has not been locked by the current\n * thread, and doing so results in undefined behavior.\n *\n * It is also an error to unlock a mutex that isn't locked at all.\n *\n * \\param mutex the mutex to unlock.\n * \\returns 0, or -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_UnlockMutex",
        "parameter": [
            "SDL_mutex *REWRITE_NAME"
        ],
        "parameter_name": [
            "mutex"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Destroy a mutex created with SDL_CreateMutex().\n *\n * This function must be called on any mutex that is no longer needed. Failure\n * to destroy a mutex will result in a system memory or resource leak. While\n * it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt\n * to destroy a locked mutex, and may result in undefined behavior depending\n * on the platform.\n *\n * \\param mutex the mutex to destroy\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateMutex\n * \\sa SDL_LockMutex\n * \\sa SDL_TryLockMutex\n * \\sa SDL_UnlockMutex\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_DestroyMutex",
        "parameter": [
            "SDL_mutex *REWRITE_NAME"
        ],
        "parameter_name": [
            "mutex"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Create a semaphore.\n *\n * This function creates a new semaphore and initializes it with the value\n * `initial_value`. Each wait operation on the semaphore will atomically\n * decrement the semaphore value and potentially block if the semaphore value\n * is 0. Each post operation will atomically increment the semaphore value and\n * wake waiting threads and allow them to retry the wait operation.\n *\n * \\param initial_value the starting value of the semaphore\n * \\returns a new semaphore or NULL on failure; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_DestroySemaphore\n * \\sa SDL_SemPost\n * \\sa SDL_SemTryWait\n * \\sa SDL_SemValue\n * \\sa SDL_SemWait\n * \\sa SDL_SemWaitTimeout\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_CreateSemaphore",
        "parameter": [
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "initial_value"
        ],
        "retval": "SDL_sem*"
    },
    {
        "comment": "/**\n * Destroy a semaphore.\n *\n * It is not safe to destroy a semaphore if there are threads currently\n * waiting on it.\n *\n * \\param sem the semaphore to destroy\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateSemaphore\n * \\sa SDL_SemPost\n * \\sa SDL_SemTryWait\n * \\sa SDL_SemValue\n * \\sa SDL_SemWait\n * \\sa SDL_SemWaitTimeout\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_DestroySemaphore",
        "parameter": [
            "SDL_sem *REWRITE_NAME"
        ],
        "parameter_name": [
            "sem"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Wait until a semaphore has a positive value and then decrements it.\n *\n * This function suspends the calling thread until either the semaphore\n * pointed to by `sem` has a positive value or the call is interrupted by a\n * signal or error. If the call is successful it will atomically decrement the\n * semaphore value.\n *\n * This function is the equivalent of calling SDL_SemWaitTimeout() with a time\n * length of `SDL_MUTEX_MAXWAIT`.\n *\n * \\param sem the semaphore wait on\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateSemaphore\n * \\sa SDL_DestroySemaphore\n * \\sa SDL_SemPost\n * \\sa SDL_SemTryWait\n * \\sa SDL_SemValue\n * \\sa SDL_SemWait\n * \\sa SDL_SemWaitTimeout\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_SemWait",
        "parameter": [
            "SDL_sem *REWRITE_NAME"
        ],
        "parameter_name": [
            "sem"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * See if a semaphore has a positive value and decrement it if it does.\n *\n * This function checks to see if the semaphore pointed to by `sem` has a\n * positive value and atomically decrements the semaphore value if it does. If\n * the semaphore doesn't have a positive value, the function immediately\n * returns SDL_MUTEX_TIMEDOUT.\n *\n * \\param sem the semaphore to wait on\n * \\returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait would\n *          block, or a negative error code on failure; call SDL_GetError()\n *          for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateSemaphore\n * \\sa SDL_DestroySemaphore\n * \\sa SDL_SemPost\n * \\sa SDL_SemValue\n * \\sa SDL_SemWait\n * \\sa SDL_SemWaitTimeout\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_SemTryWait",
        "parameter": [
            "SDL_sem *REWRITE_NAME"
        ],
        "parameter_name": [
            "sem"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Wait until a semaphore has a positive value and then decrements it.\n *\n * This function suspends the calling thread until either the semaphore\n * pointed to by `sem` has a positive value, the call is interrupted by a\n * signal or error, or the specified time has elapsed. If the call is\n * successful it will atomically decrement the semaphore value.\n *\n * \\param sem the semaphore to wait on\n * \\param timeoutMS the length of the timeout, in milliseconds\n * \\returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait does not\n *          succeed in the allotted time, or a negative error code on failure;\n *          call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateSemaphore\n * \\sa SDL_DestroySemaphore\n * \\sa SDL_SemPost\n * \\sa SDL_SemTryWait\n * \\sa SDL_SemValue\n * \\sa SDL_SemWait\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_SemWaitTimeout",
        "parameter": [
            "SDL_sem *REWRITE_NAME",
            "Sint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "sem",
            "timeoutMS"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Atomically increment a semaphore's value and wake waiting threads.\n *\n * \\param sem the semaphore to increment\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateSemaphore\n * \\sa SDL_DestroySemaphore\n * \\sa SDL_SemTryWait\n * \\sa SDL_SemValue\n * \\sa SDL_SemWait\n * \\sa SDL_SemWaitTimeout\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_SemPost",
        "parameter": [
            "SDL_sem *REWRITE_NAME"
        ],
        "parameter_name": [
            "sem"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the current value of a semaphore.\n *\n * \\param sem the semaphore to query\n * \\returns the current value of the semaphore.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateSemaphore\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_SemValue",
        "parameter": [
            "SDL_sem *REWRITE_NAME"
        ],
        "parameter_name": [
            "sem"
        ],
        "retval": "Uint32"
    },
    {
        "comment": "/**\n * Create a condition variable.\n *\n * \\returns a new condition variable or NULL on failure; call SDL_GetError()\n *          for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CondBroadcast\n * \\sa SDL_CondSignal\n * \\sa SDL_CondWait\n * \\sa SDL_CondWaitTimeout\n * \\sa SDL_DestroyCond\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_CreateCond",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_cond*"
    },
    {
        "comment": "/**\n * Destroy a condition variable.\n *\n * \\param cond the condition variable to destroy\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CondBroadcast\n * \\sa SDL_CondSignal\n * \\sa SDL_CondWait\n * \\sa SDL_CondWaitTimeout\n * \\sa SDL_CreateCond\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_DestroyCond",
        "parameter": [
            "SDL_cond *REWRITE_NAME"
        ],
        "parameter_name": [
            "cond"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Restart one of the threads that are waiting on the condition variable.\n *\n * \\param cond the condition variable to signal\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CondBroadcast\n * \\sa SDL_CondWait\n * \\sa SDL_CondWaitTimeout\n * \\sa SDL_CreateCond\n * \\sa SDL_DestroyCond\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_CondSignal",
        "parameter": [
            "SDL_cond *REWRITE_NAME"
        ],
        "parameter_name": [
            "cond"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Restart all threads that are waiting on the condition variable.\n *\n * \\param cond the condition variable to signal\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CondSignal\n * \\sa SDL_CondWait\n * \\sa SDL_CondWaitTimeout\n * \\sa SDL_CreateCond\n * \\sa SDL_DestroyCond\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_CondBroadcast",
        "parameter": [
            "SDL_cond *REWRITE_NAME"
        ],
        "parameter_name": [
            "cond"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Wait until a condition variable is signaled.\n *\n * This function unlocks the specified `mutex` and waits for another thread to\n * call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable\n * `cond`. Once the condition variable is signaled, the mutex is re-locked and\n * the function returns.\n *\n * The mutex must be locked before calling this function. Locking the\n * mutex recursively (more than once) is not supported and leads to\n * undefined behavior.\n *\n * This function is the equivalent of calling SDL_CondWaitTimeout() with a\n * time length of `SDL_MUTEX_MAXWAIT`.\n *\n * \\param cond the condition variable to wait on\n * \\param mutex the mutex used to coordinate thread access\n * \\returns 0 when it is signaled or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CondBroadcast\n * \\sa SDL_CondSignal\n * \\sa SDL_CondWaitTimeout\n * \\sa SDL_CreateCond\n * \\sa SDL_DestroyCond\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_CondWait",
        "parameter": [
            "SDL_cond *REWRITE_NAME",
            "SDL_mutex *REWRITE_NAME"
        ],
        "parameter_name": [
            "cond",
            "mutex"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Wait until a condition variable is signaled or a certain time has passed.\n *\n * This function unlocks the specified `mutex` and waits for another thread to\n * call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable\n * `cond`, or for the specified time to elapse. Once the condition variable is\n * signaled or the time elapsed, the mutex is re-locked and the function\n * returns.\n *\n * The mutex must be locked before calling this function. Locking the\n * mutex recursively (more than once) is not supported and leads to\n * undefined behavior.\n *\n * \\param cond the condition variable to wait on\n * \\param mutex the mutex used to coordinate thread access\n * \\param timeoutMS the maximum time to wait, in milliseconds, or `SDL_MUTEX_MAXWAIT`\n *           to wait indefinitely\n * \\returns 0 if the condition variable is signaled, `SDL_MUTEX_TIMEDOUT` if\n *          the condition is not signaled in the allotted time, or a negative\n *          error code on failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CondBroadcast\n * \\sa SDL_CondSignal\n * \\sa SDL_CondWait\n * \\sa SDL_CreateCond\n * \\sa SDL_DestroyCond\n */\n",
        "header": "SDL_mutex.h",
        "name": "SDL_CondWaitTimeout",
        "parameter": [
            "SDL_cond *REWRITE_NAME",
            "SDL_mutex *REWRITE_NAME",
            "Sint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "cond",
            "mutex",
            "timeoutMS"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Use this function to get the number of built-in audio drivers.\n *\n * This function returns a hardcoded number. This never returns a negative\n * value; if there are no drivers compiled into this build of SDL, this\n * function returns zero. The presence of a driver in this list does not mean\n * it will function, it just means SDL is capable of interacting with that\n * interface. For example, a build of SDL might have esound support, but if\n * there's no esound server available, SDL's esound driver would fail if used.\n *\n * By default, SDL tries all drivers, in its preferred order, until one is\n * found to be usable.\n *\n * \\returns the number of built-in audio drivers.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetAudioDriver\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_GetNumAudioDrivers",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Use this function to get the name of a built in audio driver.\n *\n * The list of audio drivers is given in the order that they are normally\n * initialized by default; the drivers that seem more reasonable to choose\n * first (as far as the SDL developers believe) are earlier in the list.\n *\n * The names of drivers are all simple, low-ASCII identifiers, like \"alsa\",\n * \"coreaudio\" or \"xaudio2\". These never have Unicode characters, and are not\n * meant to be proper names.\n *\n * \\param index the index of the audio driver; the value ranges from 0 to\n *              SDL_GetNumAudioDrivers() - 1\n * \\returns the name of the audio driver at the requested index, or NULL if an\n *          invalid index was specified.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetNumAudioDrivers\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_GetAudioDriver",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "index"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the name of the current audio driver.\n *\n * The returned string points to internal static memory and thus never becomes\n * invalid, even if you quit the audio subsystem and initialize a new driver\n * (although such a case would return a different static string from another\n * call to this function, of course). As such, you should not modify or free\n * the returned string.\n *\n * \\returns the name of the current audio driver or NULL if no driver has been\n *          initialized.\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_GetCurrentAudioDriver",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the number of built-in audio devices.\n *\n * This function is only valid after successfully initializing the audio\n * subsystem.\n *\n * Note that audio capture support is not implemented as of SDL 2.0.4, so the\n * `iscapture` parameter is for future expansion and should always be zero for\n * now.\n *\n * This function will return -1 if an explicit list of devices can't be\n * determined. Returning -1 is not an error. For example, if SDL is set up to\n * talk to a remote audio server, it can't list every one available on the\n * Internet, but it will still allow a specific host to be specified in\n * SDL_OpenAudioDevice().\n *\n * In many common cases, when this function returns a value <= 0, it can still\n * successfully open the default device (NULL for first argument of\n * SDL_OpenAudioDevice()).\n *\n * This function may trigger a complete redetect of available hardware. It\n * should not be called for each iteration of a loop, but rather once at the\n * start of a loop:\n *\n * ```c\n * // Don't do this:\n * for (int i = 0; i < SDL_GetNumAudioDevices(0); i++)\n *\n * // do this instead:\n * const int count = SDL_GetNumAudioDevices(0);\n * for (int i = 0; i < count; ++i) { do_something_here(); }\n * ```\n *\n * \\param iscapture zero to request playback devices, non-zero to request\n *                  recording devices\n * \\returns the number of available devices exposed by the current driver or\n *          -1 if an explicit list of devices can't be determined. A return\n *          value of -1 does not necessarily mean an error condition.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetAudioDeviceName\n * \\sa SDL_OpenAudioDevice\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_GetNumAudioDevices",
        "parameter": [
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "iscapture"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the human-readable name of a specific audio device.\n *\n * This function is only valid after successfully initializing the audio\n * subsystem. The values returned by this function reflect the latest call to\n * SDL_GetNumAudioDevices(); re-call that function to redetect available\n * hardware.\n *\n * The string returned by this function is UTF-8 encoded, read-only, and\n * managed internally. You are not to free it. If you need to keep the string\n * for any length of time, you should make your own copy of it, as it will be\n * invalid next time any of several other SDL functions are called.\n *\n * \\param index the index of the audio device; valid values range from 0 to\n *              SDL_GetNumAudioDevices() - 1\n * \\param iscapture non-zero to query the list of recording devices, zero to\n *                  query the list of output devices.\n * \\returns the name of the audio device at the requested index, or NULL on\n *          error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetNumAudioDevices\n * \\sa SDL_GetDefaultAudioInfo\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_GetAudioDeviceName",
        "parameter": [
            "int REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "index",
            "iscapture"
        ],
        "retval": "const char*"
    },
    {
        "comment": "/**\n * Get the preferred audio format of a specific audio device.\n *\n * This function is only valid after a successfully initializing the audio\n * subsystem. The values returned by this function reflect the latest call to\n * SDL_GetNumAudioDevices(); re-call that function to redetect available\n * hardware.\n *\n * `spec` will be filled with the sample rate, sample format, and channel\n * count.\n *\n * \\param index the index of the audio device; valid values range from 0 to\n *              SDL_GetNumAudioDevices() - 1\n * \\param iscapture non-zero to query the list of recording devices, zero to\n *                  query the list of output devices.\n * \\param spec The SDL_AudioSpec to be initialized by this function.\n * \\returns 0 on success, nonzero on error\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetNumAudioDevices\n * \\sa SDL_GetDefaultAudioInfo\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_GetAudioDeviceSpec",
        "parameter": [
            "int REWRITE_NAME",
            "int REWRITE_NAME",
            "SDL_AudioSpec *REWRITE_NAME"
        ],
        "parameter_name": [
            "index",
            "iscapture",
            "spec"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the name and preferred format of the default audio device.\n *\n * Some (but not all!) platforms have an isolated mechanism to get information\n * about the \"default\" device. This can actually be a completely different\n * device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can\n * even be a network address! (This is discussed in SDL_OpenAudioDevice().)\n *\n * As a result, this call is not guaranteed to be performant, as it can query\n * the sound server directly every time, unlike the other query functions. You\n * should call this function sparingly!\n *\n * `spec` will be filled with the sample rate, sample format, and channel\n * count, if a default device exists on the system. If `name` is provided,\n * will be filled with either a dynamically-allocated UTF-8 string or NULL.\n *\n * \\param name A pointer to be filled with the name of the default device (can\n *             be NULL). Please call SDL_free() when you are done with this\n *             pointer!\n * \\param spec The SDL_AudioSpec to be initialized by this function.\n * \\param iscapture non-zero to query the default recording device, zero to\n *                  query the default output device.\n * \\returns 0 on success, nonzero on error\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetAudioDeviceName\n * \\sa SDL_GetAudioDeviceSpec\n * \\sa SDL_OpenAudioDevice\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_GetDefaultAudioInfo",
        "parameter": [
            "char **REWRITE_NAME",
            "SDL_AudioSpec *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "name",
            "spec",
            "iscapture"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Open a specific audio device.\n *\n * Passing in a `device` name of NULL requests the most reasonable default.\n * The `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but\n * some drivers allow arbitrary and driver-specific strings, such as a\n * hostname/IP address for a remote audio server, or a filename in the\n * diskaudio driver.\n *\n * An opened audio device starts out paused, and should be enabled for playing\n * by calling SDL_PlayAudioDevice(devid) when you are ready for your audio\n * callback function to be called. Since the audio driver may modify the\n * requested size of the audio buffer, you should allocate any local mixing\n * buffers after you open the audio device.\n *\n * The audio callback runs in a separate thread in most cases; you can prevent\n * race conditions between your callback and other threads without fully\n * pausing playback with SDL_LockAudioDevice(). For more information about the\n * callback, see SDL_AudioSpec.\n *\n * Managing the audio spec via 'desired' and 'obtained':\n *\n * When filling in the desired audio spec structure:\n *\n * - `desired->freq` should be the frequency in sample-frames-per-second (Hz).\n * - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).\n * - `desired->samples` is the desired size of the audio buffer, in _sample\n *   frames_ (with stereo output, two samples--left and right--would make a\n *   single sample frame). This number should be a power of two, and may be\n *   adjusted by the audio driver to a value more suitable for the hardware.\n *   Good values seem to range between 512 and 8096 inclusive, depending on\n *   the application and CPU speed. Smaller values reduce latency, but can\n *   lead to underflow if the application is doing heavy processing and cannot\n *   fill the audio buffer in time. Note that the number of sample frames is\n *   directly related to time by the following formula: `ms =\n *   (sampleframes*1000)/freq`\n * - `desired->size` is the size in _bytes_ of the audio buffer, and is\n *   calculated by SDL_OpenAudioDevice(). You don't initialize this.\n * - `desired->silence` is the value used to set the buffer to silence, and is\n *   calculated by SDL_OpenAudioDevice(). You don't initialize this.\n * - `desired->callback` should be set to a function that will be called when\n *   the audio device is ready for more data. It is passed a pointer to the\n *   audio buffer, and the length in bytes of the audio buffer. This function\n *   usually runs in a separate thread, and so you should protect data\n *   structures that it accesses by calling SDL_LockAudioDevice() and\n *   SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL\n *   pointer here, and call SDL_QueueAudio() with some frequency, to queue\n *   more audio samples to be played (or for capture devices, call\n *   SDL_DequeueAudio() with some frequency, to obtain audio samples).\n * - `desired->userdata` is passed as the first parameter to your callback\n *   function. If you passed a NULL callback, this value is ignored.\n *\n * `allowed_changes` can have the following flags OR'd together:\n *\n * - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`\n * - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`\n * - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`\n * - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`\n * - `SDL_AUDIO_ALLOW_ANY_CHANGE`\n *\n * These flags specify how SDL should behave when a device cannot offer a\n * specific feature. If the application requests a feature that the hardware\n * doesn't offer, SDL will always try to get the closest equivalent.\n *\n * For example, if you ask for float32 audio format, but the sound card only\n * supports int16, SDL will set the hardware to int16. If you had set\n * SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`\n * structure. If that flag was *not* set, SDL will prepare to convert your\n * callback's float32 audio to int16 before feeding it to the hardware and\n * will keep the originally requested format in the `obtained` structure.\n *\n * The resulting audio specs, varying depending on hardware and on what\n * changes were allowed, will then be written back to `obtained`.\n *\n * If your application can only handle one specific data format, pass a zero\n * for `allowed_changes` and let SDL transparently handle any differences.\n *\n * \\param device a UTF-8 string reported by SDL_GetAudioDeviceName() or a\n *               driver-specific name as appropriate. NULL requests the most\n *               reasonable default device.\n * \\param iscapture non-zero to specify a device should be opened for\n *                  recording, not playback\n * \\param desired an SDL_AudioSpec structure representing the desired output\n *                format\n * \\param obtained an SDL_AudioSpec structure filled in with the actual output\n *                 format\n * \\param allowed_changes 0, or one or more flags OR'd together\n * \\returns a valid device ID that is > 0 on success or 0 on failure; call\n *          SDL_GetError() for more information.\n *\n *          For compatibility with SDL 1.2, this will never return 1, since\n *          SDL reserves that ID for the legacy SDL_OpenAudio() function.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CloseAudioDevice\n * \\sa SDL_GetAudioDeviceName\n * \\sa SDL_LockAudioDevice\n * \\sa SDL_PlayAudioDevice\n * \\sa SDL_PauseAudioDevice\n * \\sa SDL_UnlockAudioDevice\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_OpenAudioDevice",
        "parameter": [
            "const char *REWRITE_NAME",
            "int REWRITE_NAME",
            "const SDL_AudioSpec *REWRITE_NAME",
            "SDL_AudioSpec *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "device",
            "iscapture",
            "desired",
            "obtained",
            "allowed_changes"
        ],
        "retval": "SDL_AudioDeviceID"
    },
    {
        "comment": "/**\n * Use this function to get the current audio state of an audio device.\n *\n * \\param dev the ID of an audio device previously opened with\n *            SDL_OpenAudioDevice()\n * \\returns the SDL_AudioStatus of the specified audio device.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_PlayAudioDevice\n * \\sa SDL_PauseAudioDevice\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_GetAudioDeviceStatus",
        "parameter": [
            "SDL_AudioDeviceID REWRITE_NAME"
        ],
        "parameter_name": [
            "dev"
        ],
        "retval": "SDL_AudioStatus"
    },
    {
        "comment": "/**\n * Use this function to play audio on a specified device.\n *\n * Newly-opened audio devices start in the paused state, so you must\n * call this function after opening the specified audio\n * device to start playing sound. This allows you to safely initialize data\n * for your callback function after opening the audio device. Silence will be\n * written to the audio device while paused, and the audio callback is\n * guaranteed to not be called. Pausing one device does not prevent other\n * unpaused devices from running their callbacks.\n *\n * \\param dev a device opened by SDL_OpenAudioDevice()\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_LockAudioDevice\n * \\sa SDL_PauseAudioDevice\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_PlayAudioDevice",
        "parameter": [
            "SDL_AudioDeviceID REWRITE_NAME"
        ],
        "parameter_name": [
            "dev"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Use this function to pause audio playback on a specified device.\n *\n * This function pauses the audio callback processing for a given\n * device.  Silence will be written to the audio device while paused, and\n * the audio callback is guaranteed to not be called.\n * Pausing one device does not prevent other unpaused devices from running\n * their callbacks.\n *\n * If you just need to protect a few variables from race conditions vs your\n * callback, you shouldn't pause the audio device, as it will lead to dropouts\n * in the audio playback. Instead, you should use SDL_LockAudioDevice().\n *\n * \\param dev a device opened by SDL_OpenAudioDevice()\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_LockAudioDevice\n * \\sa SDL_PlayAudioDevice\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_PauseAudioDevice",
        "parameter": [
            "SDL_AudioDeviceID REWRITE_NAME"
        ],
        "parameter_name": [
            "dev"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Load the audio data of a WAVE file into memory.\n *\n * Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to\n * be valid pointers. The entire data portion of the file is then loaded into\n * memory and decoded if necessary.\n *\n * If `freesrc` is non-zero, the data source gets automatically closed and\n * freed before the function returns.\n *\n * Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and\n * 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and\n * A-law and mu-law (8 bits). Other formats are currently unsupported and\n * cause an error.\n *\n * If this function succeeds, the pointer returned by it is equal to `spec`\n * and the pointer to the audio data allocated by the function is written to\n * `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec\n * members `freq`, `channels`, and `format` are set to the values of the audio\n * data in the buffer. The `samples` member is set to a sane default and all\n * others are set to zero.\n *\n * It's necessary to use SDL_free() to free the audio data returned in\n * `audio_buf` when it is no longer used.\n *\n * Because of the underspecification of the .WAV format, there are many\n * problematic files in the wild that cause issues with strict decoders. To\n * provide compatibility with these files, this decoder is lenient in regards\n * to the truncation of the file, the fact chunk, and the size of the RIFF\n * chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,\n * `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to\n * tune the behavior of the loading process.\n *\n * Any file that is invalid (due to truncation, corruption, or wrong values in\n * the headers), too big, or unsupported causes an error. Additionally, any\n * critical I/O error from the data source will terminate the loading process\n * with an error. The function returns NULL on error and in all cases (with\n * the exception of `src` being NULL), an appropriate error message will be\n * set.\n *\n * It is required that the data source supports seeking.\n *\n * Example:\n *\n * ```c\n * SDL_LoadWAV_RW(SDL_RWFromFile(\"sample.wav\", \"rb\"), 1, &spec, &buf, &len);\n * ```\n *\n * Note that the SDL_LoadWAV macro does this same thing for you, but in a less\n * messy way:\n *\n * ```c\n * SDL_LoadWAV(\"sample.wav\", &spec, &buf, &len);\n * ```\n *\n * \\param src The data source for the WAVE data\n * \\param freesrc If non-zero, SDL will _always_ free the data source\n * \\param spec An SDL_AudioSpec that will be filled in with the wave file's\n *             format details\n * \\param audio_buf A pointer filled with the audio data, allocated by the\n *                  function.\n * \\param audio_len A pointer filled with the length of the audio data buffer\n *                  in bytes\n * \\returns This function, if successfully called, returns `spec`, which will\n *          be filled with the audio data format of the wave source data.\n *          `audio_buf` will be filled with a pointer to an allocated buffer\n *          containing the audio data, and `audio_len` is filled with the\n *          length of that audio buffer in bytes.\n *\n *          This function returns NULL if the .WAV file cannot be opened, uses\n *          an unknown data format, or is corrupt; call SDL_GetError() for\n *          more information.\n *\n *          When the application is done with the data returned in\n *          `audio_buf`, it should call SDL_free() to dispose of it.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_free\n * \\sa SDL_LoadWAV\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_LoadWAV_RW",
        "parameter": [
            "SDL_RWops *REWRITE_NAME",
            "int REWRITE_NAME",
            "SDL_AudioSpec *REWRITE_NAME",
            "Uint8 **REWRITE_NAME",
            "Uint32 *REWRITE_NAME"
        ],
        "parameter_name": [
            "src",
            "freesrc",
            "spec",
            "audio_buf",
            "audio_len"
        ],
        "retval": "SDL_AudioSpec*"
    },
    {
        "comment": "/**\n * Initialize an SDL_AudioCVT structure for conversion.\n *\n * Before an SDL_AudioCVT structure can be used to convert audio data it must\n * be initialized with source and destination information.\n *\n * This function will zero out every field of the SDL_AudioCVT, so it must be\n * called before the application fills in the final buffer information.\n *\n * Once this function has returned successfully, and reported that a\n * conversion is necessary, the application fills in the rest of the fields in\n * SDL_AudioCVT, now that it knows how large a buffer it needs to allocate,\n * and then can call SDL_ConvertAudio() to complete the conversion.\n *\n * \\param cvt an SDL_AudioCVT structure filled in with audio conversion\n *            information\n * \\param src_format the source format of the audio data; for more info see\n *                   SDL_AudioFormat\n * \\param src_channels the number of channels in the source\n * \\param src_rate the frequency (sample-frames-per-second) of the source\n * \\param dst_format the destination format of the audio data; for more info\n *                   see SDL_AudioFormat\n * \\param dst_channels the number of channels in the destination\n * \\param dst_rate the frequency (sample-frames-per-second) of the destination\n * \\returns 1 if the audio filter is prepared, 0 if no conversion is needed,\n *          or a negative error code on failure; call SDL_GetError() for more\n *          information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ConvertAudio\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_BuildAudioCVT",
        "parameter": [
            "SDL_AudioCVT *REWRITE_NAME",
            "SDL_AudioFormat REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "int REWRITE_NAME",
            "SDL_AudioFormat REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "cvt",
            "src_format",
            "src_channels",
            "src_rate",
            "dst_format",
            "dst_channels",
            "dst_rate"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Convert audio data to a desired audio format.\n *\n * This function does the actual audio data conversion, after the application\n * has called SDL_BuildAudioCVT() to prepare the conversion information and\n * then filled in the buffer details.\n *\n * Once the application has initialized the `cvt` structure using\n * SDL_BuildAudioCVT(), allocated an audio buffer and filled it with audio\n * data in the source format, this function will convert the buffer, in-place,\n * to the desired format.\n *\n * The data conversion may go through several passes; any given pass may\n * possibly temporarily increase the size of the data. For example, SDL might\n * expand 16-bit data to 32 bits before resampling to a lower frequency,\n * shrinking the data size after having grown it briefly. Since the supplied\n * buffer will be both the source and destination, converting as necessary\n * in-place, the application must allocate a buffer that will fully contain\n * the data during its largest conversion pass. After SDL_BuildAudioCVT()\n * returns, the application should set the `cvt->len` field to the size, in\n * bytes, of the source data, and allocate a buffer that is `cvt->len *\n * cvt->len_mult` bytes long for the `buf` field.\n *\n * The source data should be copied into this buffer before the call to\n * SDL_ConvertAudio(). Upon successful return, this buffer will contain the\n * converted audio, and `cvt->len_cvt` will be the size of the converted data,\n * in bytes. Any bytes in the buffer past `cvt->len_cvt` are undefined once\n * this function returns.\n *\n * \\param cvt an SDL_AudioCVT structure that was previously set up by\n *            SDL_BuildAudioCVT().\n * \\returns 0 if the conversion was completed successfully or a negative error\n *          code on failure; call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_BuildAudioCVT\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_ConvertAudio",
        "parameter": [
            "SDL_AudioCVT *REWRITE_NAME"
        ],
        "parameter_name": [
            "cvt"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Create a new audio stream.\n *\n * \\param src_format The format of the source audio\n * \\param src_channels The number of channels of the source audio\n * \\param src_rate The sampling rate of the source audio\n * \\param dst_format The format of the desired audio output\n * \\param dst_channels The number of channels of the desired audio output\n * \\param dst_rate The sampling rate of the desired audio output\n * \\returns 0 on success, or -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_PutAudioStreamData\n * \\sa SDL_GetAudioStreamData\n * \\sa SDL_GetAudioStreamAvailable\n * \\sa SDL_FlushAudioStream\n * \\sa SDL_ClearAudioStream\n * \\sa SDL_DestroyAudioStream\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_CreateAudioStream",
        "parameter": [
            "SDL_AudioFormat REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "int REWRITE_NAME",
            "SDL_AudioFormat REWRITE_NAME",
            "Uint8 REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "src_format",
            "src_channels",
            "src_rate",
            "dst_format",
            "dst_channels",
            "dst_rate"
        ],
        "retval": "SDL_AudioStream*"
    },
    {
        "comment": "/**\n * Add data to be converted/resampled to the stream.\n *\n * \\param stream The stream the audio data is being added to\n * \\param buf A pointer to the audio data to add\n * \\param len The number of bytes to write to the stream\n * \\returns 0 on success, or -1 on error.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateAudioStream\n * \\sa SDL_GetAudioStreamData\n * \\sa SDL_GetAudioStreamAvailable\n * \\sa SDL_FlushAudioStream\n * \\sa SDL_ClearAudioStream\n * \\sa SDL_DestroyAudioStream\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_PutAudioStreamData",
        "parameter": [
            "SDL_AudioStream *REWRITE_NAME",
            "const void *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "stream",
            "buf",
            "len"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get converted/resampled data from the stream\n *\n * \\param stream The stream the audio is being requested from\n * \\param buf A buffer to fill with audio data\n * \\param len The maximum number of bytes to fill\n * \\returns the number of bytes read from the stream, or -1 on error\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateAudioStream\n * \\sa SDL_PutAudioStreamData\n * \\sa SDL_GetAudioStreamAvailable\n * \\sa SDL_FlushAudioStream\n * \\sa SDL_ClearAudioStream\n * \\sa SDL_DestroyAudioStream\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_GetAudioStreamData",
        "parameter": [
            "SDL_AudioStream *REWRITE_NAME",
            "void *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "stream",
            "buf",
            "len"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Get the number of converted/resampled bytes available.\n *\n * The stream may be buffering data behind the scenes until it has enough to\n * resample correctly, so this number might be lower than what you expect, or\n * even be zero. Add more data or flush the stream if you need the data now.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateAudioStream\n * \\sa SDL_PutAudioStreamData\n * \\sa SDL_GetAudioStreamData\n * \\sa SDL_FlushAudioStream\n * \\sa SDL_ClearAudioStream\n * \\sa SDL_DestroyAudioStream\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_GetAudioStreamAvailable",
        "parameter": [
            "SDL_AudioStream *REWRITE_NAME"
        ],
        "parameter_name": [
            "stream"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Tell the stream that you're done sending data, and anything being buffered\n * should be converted/resampled and made available immediately.\n *\n * It is legal to add more data to a stream after flushing, but there will be\n * audio gaps in the output. Generally this is intended to signal the end of\n * input, so the complete output becomes available.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateAudioStream\n * \\sa SDL_PutAudioStreamData\n * \\sa SDL_GetAudioStreamData\n * \\sa SDL_GetAudioStreamAvailable\n * \\sa SDL_ClearAudioStream\n * \\sa SDL_DestroyAudioStream\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_FlushAudioStream",
        "parameter": [
            "SDL_AudioStream *REWRITE_NAME"
        ],
        "parameter_name": [
            "stream"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Clear any pending data in the stream without converting it\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateAudioStream\n * \\sa SDL_PutAudioStreamData\n * \\sa SDL_GetAudioStreamData\n * \\sa SDL_GetAudioStreamAvailable\n * \\sa SDL_FlushAudioStream\n * \\sa SDL_DestroyAudioStream\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_ClearAudioStream",
        "parameter": [
            "SDL_AudioStream *REWRITE_NAME"
        ],
        "parameter_name": [
            "stream"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Free an audio stream\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_CreateAudioStream\n * \\sa SDL_PutAudioStreamData\n * \\sa SDL_GetAudioStreamData\n * \\sa SDL_GetAudioStreamAvailable\n * \\sa SDL_FlushAudioStream\n * \\sa SDL_ClearAudioStream\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_DestroyAudioStream",
        "parameter": [
            "SDL_AudioStream *REWRITE_NAME"
        ],
        "parameter_name": [
            "stream"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Mix audio data in a specified format.\n *\n * This takes an audio buffer `src` of `len` bytes of `format` data and mixes\n * it into `dst`, performing addition, volume adjustment, and overflow\n * clipping. The buffer pointed to by `dst` must also be `len` bytes of\n * `format` data.\n *\n * This is provided for convenience -- you can mix your own audio data.\n *\n * Do not use this function for mixing together more than two streams of\n * sample data. The output from repeated application of this function may be\n * distorted by clipping, because there is no accumulator with greater range\n * than the input (not to mention this being an inefficient way of doing it).\n *\n * It is a common misconception that this function is required to write audio\n * data to an output stream in an audio callback. While you can do that,\n * SDL_MixAudioFormat() is really only needed when you're mixing a single\n * audio stream with a volume adjustment.\n *\n * \\param dst the destination for the mixed audio\n * \\param src the source audio buffer to be mixed\n * \\param format the SDL_AudioFormat structure representing the desired audio\n *               format\n * \\param len the length of the audio buffer in bytes\n * \\param volume ranges from 0 - 128, and should be set to SDL_MIX_MAXVOLUME\n *               for full audio volume\n *\n * \\since This function is available since SDL 3.0.0.\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_MixAudioFormat",
        "parameter": [
            "Uint8 *REWRITE_NAME",
            "const Uint8 *REWRITE_NAME",
            "SDL_AudioFormat REWRITE_NAME",
            "Uint32 REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "dst",
            "src",
            "format",
            "len",
            "volume"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Queue more audio on non-callback devices.\n *\n * If you are looking to retrieve queued audio from a non-callback capture\n * device, you want SDL_DequeueAudio() instead. SDL_QueueAudio() will return\n * -1 to signify an error if you use it with capture devices.\n *\n * SDL offers two ways to feed audio to the device: you can either supply a\n * callback that SDL triggers with some frequency to obtain more audio (pull\n * method), or you can supply no callback, and then SDL will expect you to\n * supply data at regular intervals (push method) with this function.\n *\n * There are no limits on the amount of data you can queue, short of\n * exhaustion of address space. Queued data will drain to the device as\n * necessary without further intervention from you. If the device needs audio\n * but there is not enough queued, it will play silence to make up the\n * difference. This means you will have skips in your audio playback if you\n * aren't routinely queueing sufficient data.\n *\n * This function copies the supplied data, so you are safe to free it when the\n * function returns. This function is thread-safe, but queueing to the same\n * device from two threads at once does not promise which buffer will be\n * queued first.\n *\n * You may not queue audio on a device that is using an application-supplied\n * callback; doing so returns an error. You have to use the audio callback or\n * queue audio with this function, but not both.\n *\n * You should not call SDL_LockAudio() on the device before queueing; SDL\n * handles locking internally for this function.\n *\n * Note that SDL does not support planar audio. You will need to resample from\n * planar audio formats into a non-planar one (see SDL_AudioFormat) before\n * queuing audio.\n *\n * \\param dev the device ID to which we will queue audio\n * \\param data the data to queue to the device for later playback\n * \\param len the number of bytes (not samples!) to which `data` points\n * \\returns 0 on success or a negative error code on failure; call\n *          SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ClearQueuedAudio\n * \\sa SDL_GetQueuedAudioSize\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_QueueAudio",
        "parameter": [
            "SDL_AudioDeviceID REWRITE_NAME",
            "const void *REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "dev",
            "data",
            "len"
        ],
        "retval": "int"
    },
    {
        "comment": "/**\n * Dequeue more audio on non-callback devices.\n *\n * If you are looking to queue audio for output on a non-callback playback\n * device, you want SDL_QueueAudio() instead. SDL_DequeueAudio() will always\n * return 0 if you use it with playback devices.\n *\n * SDL offers two ways to retrieve audio from a capture device: you can either\n * supply a callback that SDL triggers with some frequency as the device\n * records more audio data, (push method), or you can supply no callback, and\n * then SDL will expect you to retrieve data at regular intervals (pull\n * method) with this function.\n *\n * There are no limits on the amount of data you can queue, short of\n * exhaustion of address space. Data from the device will keep queuing as\n * necessary without further intervention from you. This means you will\n * eventually run out of memory if you aren't routinely dequeueing data.\n *\n * Capture devices will not queue data when paused; if you are expecting to\n * not need captured audio for some length of time, use SDL_PauseAudioDevice()\n * to stop the capture device from queueing more data. This can be useful\n * during, say, level loading times. When unpaused, capture devices will start\n * queueing data from that point, having flushed any capturable data available\n * while paused.\n *\n * This function is thread-safe, but dequeueing from the same device from two\n * threads at once does not promise which thread will dequeue data first.\n *\n * You may not dequeue audio from a device that is using an\n * application-supplied callback; doing so returns an error. You have to use\n * the audio callback, or dequeue audio with this function, but not both.\n *\n * You should not call SDL_LockAudio() on the device before dequeueing; SDL\n * handles locking internally for this function.\n *\n * \\param dev the device ID from which we will dequeue audio\n * \\param data a pointer into where audio data should be copied\n * \\param len the number of bytes (not samples!) to which (data) points\n * \\returns the number of bytes dequeued, which could be less than requested;\n *          call SDL_GetError() for more information.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ClearQueuedAudio\n * \\sa SDL_GetQueuedAudioSize\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_DequeueAudio",
        "parameter": [
            "SDL_AudioDeviceID REWRITE_NAME",
            "void *REWRITE_NAME",
            "Uint32 REWRITE_NAME"
        ],
        "parameter_name": [
            "dev",
            "data",
            "len"
        ],
        "retval": "Uint32"
    },
    {
        "comment": "/**\n * Get the number of bytes of still-queued audio.\n *\n * For playback devices: this is the number of bytes that have been queued for\n * playback with SDL_QueueAudio(), but have not yet been sent to the hardware.\n *\n * Once we've sent it to the hardware, this function can not decide the exact\n * byte boundary of what has been played. It's possible that we just gave the\n * hardware several kilobytes right before you called this function, but it\n * hasn't played any of it yet, or maybe half of it, etc.\n *\n * For capture devices, this is the number of bytes that have been captured by\n * the device and are waiting for you to dequeue. This number may grow at any\n * time, so this only informs of the lower-bound of available data.\n *\n * You may not queue or dequeue audio on a device that is using an\n * application-supplied callback; calling this function on such a device\n * always returns 0. You have to use the audio callback or queue audio, but\n * not both.\n *\n * You should not call SDL_LockAudio() on the device before querying; SDL\n * handles locking internally for this function.\n *\n * \\param dev the device ID of which we will query queued audio size\n * \\returns the number of bytes (not samples!) of queued audio.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ClearQueuedAudio\n * \\sa SDL_QueueAudio\n * \\sa SDL_DequeueAudio\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_GetQueuedAudioSize",
        "parameter": [
            "SDL_AudioDeviceID REWRITE_NAME"
        ],
        "parameter_name": [
            "dev"
        ],
        "retval": "Uint32"
    },
    {
        "comment": "/**\n * Drop any queued audio data waiting to be sent to the hardware.\n *\n * Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For\n * output devices, the hardware will start playing silence if more audio isn't\n * queued. For capture devices, the hardware will start filling the empty\n * queue with new data if the capture device isn't paused.\n *\n * This will not prevent playback of queued audio that's already been sent to\n * the hardware, as we can not undo that, so expect there to be some fraction\n * of a second of audio that might still be heard. This can be useful if you\n * want to, say, drop any pending music or any unprocessed microphone input\n * during a level change in your game.\n *\n * You may not queue or dequeue audio on a device that is using an\n * application-supplied callback; calling this function on such a device\n * always returns 0. You have to use the audio callback or queue audio, but\n * not both.\n *\n * You should not call SDL_LockAudio() on the device before clearing the\n * queue; SDL handles locking internally for this function.\n *\n * This function always succeeds and thus returns void.\n *\n * \\param dev the device ID of which to clear the audio queue\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetQueuedAudioSize\n * \\sa SDL_QueueAudio\n * \\sa SDL_DequeueAudio\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_ClearQueuedAudio",
        "parameter": [
            "SDL_AudioDeviceID REWRITE_NAME"
        ],
        "parameter_name": [
            "dev"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Use this function to lock out the audio callback function for a specified\n * device.\n *\n * The lock manipulated by these functions protects the audio callback\n * function specified in SDL_OpenAudioDevice(). During a\n * SDL_LockAudioDevice()/SDL_UnlockAudioDevice() pair, you can be guaranteed\n * that the callback function for that device is not running, even if the\n * device is not paused. While a device is locked, any other unpaused,\n * unlocked devices may still run their callbacks.\n *\n * Calling this function from inside your audio callback is unnecessary. SDL\n * obtains this lock before calling your function, and releases it when the\n * function returns.\n *\n * You should not hold the lock longer than absolutely necessary. If you hold\n * it too long, you'll experience dropouts in your audio playback. Ideally,\n * your application locks the device, sets a few variables and unlocks again.\n * Do not do heavy work while holding the lock for a device.\n *\n * It is safe to lock the audio device multiple times, as long as you unlock\n * it an equivalent number of times. The callback will not run until the\n * device has been unlocked completely in this way. If your application fails\n * to unlock the device appropriately, your callback will never run, you might\n * hear repeating bursts of audio, and SDL_CloseAudioDevice() will probably\n * deadlock.\n *\n * Internally, the audio device lock is a mutex; if you lock from two threads\n * at once, not only will you block the audio callback, you'll block the other\n * thread.\n *\n * \\param dev the ID of the device to be locked\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_UnlockAudioDevice\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_LockAudioDevice",
        "parameter": [
            "SDL_AudioDeviceID REWRITE_NAME"
        ],
        "parameter_name": [
            "dev"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Use this function to unlock the audio callback function for a specified\n * device.\n *\n * This function should be paired with a previous SDL_LockAudioDevice() call.\n *\n * \\param dev the ID of the device to be unlocked\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_LockAudioDevice\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_UnlockAudioDevice",
        "parameter": [
            "SDL_AudioDeviceID REWRITE_NAME"
        ],
        "parameter_name": [
            "dev"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Use this function to shut down audio processing and close the audio device.\n *\n * The application should close open audio devices once they are no longer\n * needed. Calling this function will wait until the device's audio callback\n * is not running, release the audio hardware and then clean up internal\n * state. No further audio will play from this device once this function\n * returns.\n *\n * This function may block briefly while pending audio data is played by the\n * hardware, so that applications don't drop the last buffer of data they\n * supplied.\n *\n * The device ID is invalid as soon as the device is closed, and is eligible\n * for reuse in a new SDL_OpenAudioDevice() call immediately.\n *\n * \\param dev an audio device previously opened with SDL_OpenAudioDevice()\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_OpenAudioDevice\n */\n",
        "header": "SDL_audio.h",
        "name": "SDL_CloseAudioDevice",
        "parameter": [
            "SDL_AudioDeviceID REWRITE_NAME"
        ],
        "parameter_name": [
            "dev"
        ],
        "retval": "void"
    },
    {
        "comment": "/* this tells Clang's static analysis that we're a custom assert function,\n   and that the analyzer should assume the condition was always true past this\n   SDL_assert test. */\n",
        "header": "SDL_assert.h",
        "name": "SDL_ReportAssertion",
        "parameter": [
            "SDL_AssertData *REWRITE_NAME",
            "const char *REWRITE_NAME",
            "const char *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "param_name_not_specified",
            "param_name_not_specified",
            "param_name_not_specified",
            "param_name_not_specified"
        ],
        "retval": "SDL_AssertState"
    },
    {
        "comment": "/**\n * Set an application-defined assertion handler.\n *\n * This function allows an application to show its own assertion UI and/or\n * force the response to an assertion failure. If the application doesn't\n * provide this, SDL will try to do the right thing, popping up a\n * system-specific GUI dialog, and probably minimizing any fullscreen windows.\n *\n * This callback may fire from any thread, but it runs wrapped in a mutex, so\n * it will only fire from one thread at a time.\n *\n * This callback is NOT reset to SDL's internal handler upon SDL_Quit()!\n *\n * \\param handler the SDL_AssertionHandler function to call when an assertion\n *                fails or NULL for the default handler\n * \\param userdata a pointer that is passed to `handler`\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetAssertionHandler\n */\n",
        "header": "SDL_assert.h",
        "name": "SDL_SetAssertionHandler",
        "parameter": [
            "SDL_AssertionHandler REWRITE_NAME",
            "void *REWRITE_NAME"
        ],
        "parameter_name": [
            "handler",
            "userdata"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get the default assertion handler.\n *\n * This returns the function pointer that is called by default when an\n * assertion is triggered. This is an internal function provided by SDL, that\n * is used for assertions when SDL_SetAssertionHandler() hasn't been used to\n * provide a different function.\n *\n * \\returns the default SDL_AssertionHandler that is called when an assert\n *          triggers.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetAssertionHandler\n */\n",
        "header": "SDL_assert.h",
        "name": "SDL_GetDefaultAssertionHandler",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "SDL_AssertionHandler"
    },
    {
        "comment": "/**\n * Get the current assertion handler.\n *\n * This returns the function pointer that is called when an assertion is\n * triggered. This is either the value last passed to\n * SDL_SetAssertionHandler(), or if no application-specified function is set,\n * is equivalent to calling SDL_GetDefaultAssertionHandler().\n *\n * The parameter `puserdata` is a pointer to a void*, which will store the\n * \"userdata\" pointer that was passed to SDL_SetAssertionHandler(). This value\n * will always be NULL for the default handler. If you don't care about this\n * data, it is safe to pass a NULL pointer to this function to ignore it.\n *\n * \\param puserdata pointer which is filled with the \"userdata\" pointer that\n *                  was passed to SDL_SetAssertionHandler()\n * \\returns the SDL_AssertionHandler that is called when an assert triggers.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_SetAssertionHandler\n */\n",
        "header": "SDL_assert.h",
        "name": "SDL_GetAssertionHandler",
        "parameter": [
            "void **REWRITE_NAME"
        ],
        "parameter_name": [
            "puserdata"
        ],
        "retval": "SDL_AssertionHandler"
    },
    {
        "comment": "/**\n * Get a list of all assertion failures.\n *\n * This function gets all assertions triggered since the last call to\n * SDL_ResetAssertionReport(), or the start of the program.\n *\n * The proper way to examine this data looks something like this:\n *\n * ```c\n * const SDL_AssertData *item = SDL_GetAssertionReport();\n * while (item) {\n *    printf(\"'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\\\n\",\n *           item->condition, item->function, item->filename,\n *           item->linenum, item->trigger_count,\n *           item->always_ignore ? \"yes\" : \"no\");\n *    item = item->next;\n * }\n * ```\n *\n * \\returns a list of all failed assertions or NULL if the list is empty. This\n *          memory should not be modified or freed by the application.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_ResetAssertionReport\n */\n",
        "header": "SDL_assert.h",
        "name": "SDL_GetAssertionReport",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "const SDL_AssertData*"
    },
    {
        "comment": "/**\n * Clear the list of all assertion failures.\n *\n * This function will clear the list of all assertions triggered up to that\n * point. Immediately following this call, SDL_GetAssertionReport will return\n * no items. In addition, any previously-triggered assertions will be reset to\n * a trigger_count of zero, and their always_ignore state will be false.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GetAssertionReport\n */\n",
        "header": "SDL_assert.h",
        "name": "SDL_ResetAssertionReport",
        "parameter": [
            "void"
        ],
        "parameter_name": [
            ""
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Get an ASCII string representation for a given ::SDL_GUID.\n *\n * You should supply at least 33 bytes for pszGUID.\n *\n * \\param guid the ::SDL_GUID you wish to convert to string\n * \\param pszGUID buffer in which to write the ASCII string\n * \\param cbGUID the size of pszGUID\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GUIDFromString\n */\n",
        "header": "SDL_guid.h",
        "name": "SDL_GUIDToString",
        "parameter": [
            "SDL_GUID REWRITE_NAME",
            "char *REWRITE_NAME",
            "int REWRITE_NAME"
        ],
        "parameter_name": [
            "guid",
            "pszGUID",
            "cbGUID"
        ],
        "retval": "void"
    },
    {
        "comment": "/**\n * Convert a GUID string into a ::SDL_GUID structure.\n *\n * Performs no error checking. If this function is given a string containing\n * an invalid GUID, the function will silently succeed, but the GUID generated\n * will not be useful.\n *\n * \\param pchGUID string containing an ASCII representation of a GUID\n * \\returns a ::SDL_GUID structure.\n *\n * \\since This function is available since SDL 3.0.0.\n *\n * \\sa SDL_GUIDToString\n */\n",
        "header": "SDL_guid.h",
        "name": "SDL_GUIDFromString",
        "parameter": [
            "const char *REWRITE_NAME"
        ],
        "parameter_name": [
            "pchGUID"
        ],
        "retval": "SDL_GUID"
    }
]